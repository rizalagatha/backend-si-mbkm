
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AdminSiap
 * 
 */
export type AdminSiap = $Result.DefaultSelection<Prisma.$AdminSiapPayload>
/**
 * Model BerkasPenilaian
 * 
 */
export type BerkasPenilaian = $Result.DefaultSelection<Prisma.$BerkasPenilaianPayload>
/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model Dosbing
 * 
 */
export type Dosbing = $Result.DefaultSelection<Prisma.$DosbingPayload>
/**
 * Model KonversiNilai
 * 
 */
export type KonversiNilai = $Result.DefaultSelection<Prisma.$KonversiNilaiPayload>
/**
 * Model KoorMbkm
 * 
 */
export type KoorMbkm = $Result.DefaultSelection<Prisma.$KoorMbkmPayload>
/**
 * Model Mahasiswa
 * 
 */
export type Mahasiswa = $Result.DefaultSelection<Prisma.$MahasiswaPayload>
/**
 * Model PendaftaranAkun
 * 
 */
export type PendaftaranAkun = $Result.DefaultSelection<Prisma.$PendaftaranAkunPayload>
/**
 * Model PendaftaranMbkm
 * 
 */
export type PendaftaranMbkm = $Result.DefaultSelection<Prisma.$PendaftaranMbkmPayload>
/**
 * Model Pengumuman
 * 
 */
export type Pengumuman = $Result.DefaultSelection<Prisma.$PengumumanPayload>
/**
 * Model ProgramMbkm
 * 
 */
export type ProgramMbkm = $Result.DefaultSelection<Prisma.$ProgramMbkmPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  koor_mbkm: 'koor_mbkm',
  admin_siap: 'admin_siap',
  dosbing: 'dosbing',
  mahasiswa: 'mahasiswa'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdminSiaps
 * const adminSiaps = await prisma.adminSiap.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdminSiaps
   * const adminSiaps = await prisma.adminSiap.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.adminSiap`: Exposes CRUD operations for the **AdminSiap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSiaps
    * const adminSiaps = await prisma.adminSiap.findMany()
    * ```
    */
  get adminSiap(): Prisma.AdminSiapDelegate<ExtArgs>;

  /**
   * `prisma.berkasPenilaian`: Exposes CRUD operations for the **BerkasPenilaian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BerkasPenilaians
    * const berkasPenilaians = await prisma.berkasPenilaian.findMany()
    * ```
    */
  get berkasPenilaian(): Prisma.BerkasPenilaianDelegate<ExtArgs>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs>;

  /**
   * `prisma.dosbing`: Exposes CRUD operations for the **Dosbing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dosbings
    * const dosbings = await prisma.dosbing.findMany()
    * ```
    */
  get dosbing(): Prisma.DosbingDelegate<ExtArgs>;

  /**
   * `prisma.konversiNilai`: Exposes CRUD operations for the **KonversiNilai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KonversiNilais
    * const konversiNilais = await prisma.konversiNilai.findMany()
    * ```
    */
  get konversiNilai(): Prisma.KonversiNilaiDelegate<ExtArgs>;

  /**
   * `prisma.koorMbkm`: Exposes CRUD operations for the **KoorMbkm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KoorMbkms
    * const koorMbkms = await prisma.koorMbkm.findMany()
    * ```
    */
  get koorMbkm(): Prisma.KoorMbkmDelegate<ExtArgs>;

  /**
   * `prisma.mahasiswa`: Exposes CRUD operations for the **Mahasiswa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mahasiswas
    * const mahasiswas = await prisma.mahasiswa.findMany()
    * ```
    */
  get mahasiswa(): Prisma.MahasiswaDelegate<ExtArgs>;

  /**
   * `prisma.pendaftaranAkun`: Exposes CRUD operations for the **PendaftaranAkun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendaftaranAkuns
    * const pendaftaranAkuns = await prisma.pendaftaranAkun.findMany()
    * ```
    */
  get pendaftaranAkun(): Prisma.PendaftaranAkunDelegate<ExtArgs>;

  /**
   * `prisma.pendaftaranMbkm`: Exposes CRUD operations for the **PendaftaranMbkm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendaftaranMbkms
    * const pendaftaranMbkms = await prisma.pendaftaranMbkm.findMany()
    * ```
    */
  get pendaftaranMbkm(): Prisma.PendaftaranMbkmDelegate<ExtArgs>;

  /**
   * `prisma.pengumuman`: Exposes CRUD operations for the **Pengumuman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengumumen
    * const pengumumen = await prisma.pengumuman.findMany()
    * ```
    */
  get pengumuman(): Prisma.PengumumanDelegate<ExtArgs>;

  /**
   * `prisma.programMbkm`: Exposes CRUD operations for the **ProgramMbkm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramMbkms
    * const programMbkms = await prisma.programMbkm.findMany()
    * ```
    */
  get programMbkm(): Prisma.ProgramMbkmDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AdminSiap: 'AdminSiap',
    BerkasPenilaian: 'BerkasPenilaian',
    Categories: 'Categories',
    Dosbing: 'Dosbing',
    KonversiNilai: 'KonversiNilai',
    KoorMbkm: 'KoorMbkm',
    Mahasiswa: 'Mahasiswa',
    PendaftaranAkun: 'PendaftaranAkun',
    PendaftaranMbkm: 'PendaftaranMbkm',
    Pengumuman: 'Pengumuman',
    ProgramMbkm: 'ProgramMbkm',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "adminSiap" | "berkasPenilaian" | "categories" | "dosbing" | "konversiNilai" | "koorMbkm" | "mahasiswa" | "pendaftaranAkun" | "pendaftaranMbkm" | "pengumuman" | "programMbkm" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AdminSiap: {
        payload: Prisma.$AdminSiapPayload<ExtArgs>
        fields: Prisma.AdminSiapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSiapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSiapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          findFirst: {
            args: Prisma.AdminSiapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSiapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          findMany: {
            args: Prisma.AdminSiapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>[]
          }
          create: {
            args: Prisma.AdminSiapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          createMany: {
            args: Prisma.AdminSiapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSiapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>[]
          }
          delete: {
            args: Prisma.AdminSiapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          update: {
            args: Prisma.AdminSiapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          deleteMany: {
            args: Prisma.AdminSiapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSiapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminSiapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSiapPayload>
          }
          aggregate: {
            args: Prisma.AdminSiapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSiap>
          }
          groupBy: {
            args: Prisma.AdminSiapGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSiapGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSiapCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSiapCountAggregateOutputType> | number
          }
        }
      }
      BerkasPenilaian: {
        payload: Prisma.$BerkasPenilaianPayload<ExtArgs>
        fields: Prisma.BerkasPenilaianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BerkasPenilaianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BerkasPenilaianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          findFirst: {
            args: Prisma.BerkasPenilaianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BerkasPenilaianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          findMany: {
            args: Prisma.BerkasPenilaianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>[]
          }
          create: {
            args: Prisma.BerkasPenilaianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          createMany: {
            args: Prisma.BerkasPenilaianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BerkasPenilaianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>[]
          }
          delete: {
            args: Prisma.BerkasPenilaianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          update: {
            args: Prisma.BerkasPenilaianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          deleteMany: {
            args: Prisma.BerkasPenilaianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BerkasPenilaianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BerkasPenilaianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BerkasPenilaianPayload>
          }
          aggregate: {
            args: Prisma.BerkasPenilaianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBerkasPenilaian>
          }
          groupBy: {
            args: Prisma.BerkasPenilaianGroupByArgs<ExtArgs>
            result: $Utils.Optional<BerkasPenilaianGroupByOutputType>[]
          }
          count: {
            args: Prisma.BerkasPenilaianCountArgs<ExtArgs>
            result: $Utils.Optional<BerkasPenilaianCountAggregateOutputType> | number
          }
        }
      }
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      Dosbing: {
        payload: Prisma.$DosbingPayload<ExtArgs>
        fields: Prisma.DosbingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DosbingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DosbingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          findFirst: {
            args: Prisma.DosbingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DosbingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          findMany: {
            args: Prisma.DosbingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>[]
          }
          create: {
            args: Prisma.DosbingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          createMany: {
            args: Prisma.DosbingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DosbingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>[]
          }
          delete: {
            args: Prisma.DosbingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          update: {
            args: Prisma.DosbingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          deleteMany: {
            args: Prisma.DosbingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DosbingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DosbingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosbingPayload>
          }
          aggregate: {
            args: Prisma.DosbingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDosbing>
          }
          groupBy: {
            args: Prisma.DosbingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DosbingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DosbingCountArgs<ExtArgs>
            result: $Utils.Optional<DosbingCountAggregateOutputType> | number
          }
        }
      }
      KonversiNilai: {
        payload: Prisma.$KonversiNilaiPayload<ExtArgs>
        fields: Prisma.KonversiNilaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KonversiNilaiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KonversiNilaiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          findFirst: {
            args: Prisma.KonversiNilaiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KonversiNilaiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          findMany: {
            args: Prisma.KonversiNilaiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>[]
          }
          create: {
            args: Prisma.KonversiNilaiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          createMany: {
            args: Prisma.KonversiNilaiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KonversiNilaiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>[]
          }
          delete: {
            args: Prisma.KonversiNilaiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          update: {
            args: Prisma.KonversiNilaiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          deleteMany: {
            args: Prisma.KonversiNilaiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KonversiNilaiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KonversiNilaiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KonversiNilaiPayload>
          }
          aggregate: {
            args: Prisma.KonversiNilaiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKonversiNilai>
          }
          groupBy: {
            args: Prisma.KonversiNilaiGroupByArgs<ExtArgs>
            result: $Utils.Optional<KonversiNilaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.KonversiNilaiCountArgs<ExtArgs>
            result: $Utils.Optional<KonversiNilaiCountAggregateOutputType> | number
          }
        }
      }
      KoorMbkm: {
        payload: Prisma.$KoorMbkmPayload<ExtArgs>
        fields: Prisma.KoorMbkmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KoorMbkmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KoorMbkmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          findFirst: {
            args: Prisma.KoorMbkmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KoorMbkmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          findMany: {
            args: Prisma.KoorMbkmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>[]
          }
          create: {
            args: Prisma.KoorMbkmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          createMany: {
            args: Prisma.KoorMbkmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KoorMbkmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>[]
          }
          delete: {
            args: Prisma.KoorMbkmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          update: {
            args: Prisma.KoorMbkmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          deleteMany: {
            args: Prisma.KoorMbkmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KoorMbkmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KoorMbkmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KoorMbkmPayload>
          }
          aggregate: {
            args: Prisma.KoorMbkmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKoorMbkm>
          }
          groupBy: {
            args: Prisma.KoorMbkmGroupByArgs<ExtArgs>
            result: $Utils.Optional<KoorMbkmGroupByOutputType>[]
          }
          count: {
            args: Prisma.KoorMbkmCountArgs<ExtArgs>
            result: $Utils.Optional<KoorMbkmCountAggregateOutputType> | number
          }
        }
      }
      Mahasiswa: {
        payload: Prisma.$MahasiswaPayload<ExtArgs>
        fields: Prisma.MahasiswaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MahasiswaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MahasiswaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          findFirst: {
            args: Prisma.MahasiswaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MahasiswaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          findMany: {
            args: Prisma.MahasiswaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>[]
          }
          create: {
            args: Prisma.MahasiswaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          createMany: {
            args: Prisma.MahasiswaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MahasiswaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>[]
          }
          delete: {
            args: Prisma.MahasiswaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          update: {
            args: Prisma.MahasiswaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          deleteMany: {
            args: Prisma.MahasiswaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MahasiswaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MahasiswaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MahasiswaPayload>
          }
          aggregate: {
            args: Prisma.MahasiswaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMahasiswa>
          }
          groupBy: {
            args: Prisma.MahasiswaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MahasiswaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MahasiswaCountArgs<ExtArgs>
            result: $Utils.Optional<MahasiswaCountAggregateOutputType> | number
          }
        }
      }
      PendaftaranAkun: {
        payload: Prisma.$PendaftaranAkunPayload<ExtArgs>
        fields: Prisma.PendaftaranAkunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendaftaranAkunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendaftaranAkunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          findFirst: {
            args: Prisma.PendaftaranAkunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendaftaranAkunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          findMany: {
            args: Prisma.PendaftaranAkunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>[]
          }
          create: {
            args: Prisma.PendaftaranAkunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          createMany: {
            args: Prisma.PendaftaranAkunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendaftaranAkunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>[]
          }
          delete: {
            args: Prisma.PendaftaranAkunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          update: {
            args: Prisma.PendaftaranAkunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          deleteMany: {
            args: Prisma.PendaftaranAkunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendaftaranAkunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PendaftaranAkunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranAkunPayload>
          }
          aggregate: {
            args: Prisma.PendaftaranAkunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendaftaranAkun>
          }
          groupBy: {
            args: Prisma.PendaftaranAkunGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranAkunGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendaftaranAkunCountArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranAkunCountAggregateOutputType> | number
          }
        }
      }
      PendaftaranMbkm: {
        payload: Prisma.$PendaftaranMbkmPayload<ExtArgs>
        fields: Prisma.PendaftaranMbkmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendaftaranMbkmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendaftaranMbkmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          findFirst: {
            args: Prisma.PendaftaranMbkmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendaftaranMbkmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          findMany: {
            args: Prisma.PendaftaranMbkmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>[]
          }
          create: {
            args: Prisma.PendaftaranMbkmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          createMany: {
            args: Prisma.PendaftaranMbkmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendaftaranMbkmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>[]
          }
          delete: {
            args: Prisma.PendaftaranMbkmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          update: {
            args: Prisma.PendaftaranMbkmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          deleteMany: {
            args: Prisma.PendaftaranMbkmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendaftaranMbkmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PendaftaranMbkmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendaftaranMbkmPayload>
          }
          aggregate: {
            args: Prisma.PendaftaranMbkmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendaftaranMbkm>
          }
          groupBy: {
            args: Prisma.PendaftaranMbkmGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranMbkmGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendaftaranMbkmCountArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranMbkmCountAggregateOutputType> | number
          }
        }
      }
      Pengumuman: {
        payload: Prisma.$PengumumanPayload<ExtArgs>
        fields: Prisma.PengumumanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PengumumanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PengumumanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findFirst: {
            args: Prisma.PengumumanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PengumumanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findMany: {
            args: Prisma.PengumumanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          create: {
            args: Prisma.PengumumanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          createMany: {
            args: Prisma.PengumumanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PengumumanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          delete: {
            args: Prisma.PengumumanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          update: {
            args: Prisma.PengumumanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          deleteMany: {
            args: Prisma.PengumumanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PengumumanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PengumumanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          aggregate: {
            args: Prisma.PengumumanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengumuman>
          }
          groupBy: {
            args: Prisma.PengumumanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengumumanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PengumumanCountArgs<ExtArgs>
            result: $Utils.Optional<PengumumanCountAggregateOutputType> | number
          }
        }
      }
      ProgramMbkm: {
        payload: Prisma.$ProgramMbkmPayload<ExtArgs>
        fields: Prisma.ProgramMbkmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramMbkmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramMbkmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          findFirst: {
            args: Prisma.ProgramMbkmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramMbkmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          findMany: {
            args: Prisma.ProgramMbkmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>[]
          }
          create: {
            args: Prisma.ProgramMbkmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          createMany: {
            args: Prisma.ProgramMbkmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramMbkmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>[]
          }
          delete: {
            args: Prisma.ProgramMbkmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          update: {
            args: Prisma.ProgramMbkmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          deleteMany: {
            args: Prisma.ProgramMbkmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramMbkmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramMbkmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramMbkmPayload>
          }
          aggregate: {
            args: Prisma.ProgramMbkmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramMbkm>
          }
          groupBy: {
            args: Prisma.ProgramMbkmGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramMbkmGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramMbkmCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramMbkmCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminSiapCountOutputType
   */

  export type AdminSiapCountOutputType = {
    KonversiNilai: number
  }

  export type AdminSiapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KonversiNilai?: boolean | AdminSiapCountOutputTypeCountKonversiNilaiArgs
  }

  // Custom InputTypes
  /**
   * AdminSiapCountOutputType without action
   */
  export type AdminSiapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiapCountOutputType
     */
    select?: AdminSiapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminSiapCountOutputType without action
   */
  export type AdminSiapCountOutputTypeCountKonversiNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KonversiNilaiWhereInput
  }


  /**
   * Count Type BerkasPenilaianCountOutputType
   */

  export type BerkasPenilaianCountOutputType = {
    KonversiNilai: number
  }

  export type BerkasPenilaianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KonversiNilai?: boolean | BerkasPenilaianCountOutputTypeCountKonversiNilaiArgs
  }

  // Custom InputTypes
  /**
   * BerkasPenilaianCountOutputType without action
   */
  export type BerkasPenilaianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaianCountOutputType
     */
    select?: BerkasPenilaianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BerkasPenilaianCountOutputType without action
   */
  export type BerkasPenilaianCountOutputTypeCountKonversiNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KonversiNilaiWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    ProgramMbkm: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProgramMbkm?: boolean | CategoriesCountOutputTypeCountProgramMbkmArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountProgramMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramMbkmWhereInput
  }


  /**
   * Count Type DosbingCountOutputType
   */

  export type DosbingCountOutputType = {
    Mahasiswa: number
    PendaftaranMbkm: number
  }

  export type DosbingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | DosbingCountOutputTypeCountMahasiswaArgs
    PendaftaranMbkm?: boolean | DosbingCountOutputTypeCountPendaftaranMbkmArgs
  }

  // Custom InputTypes
  /**
   * DosbingCountOutputType without action
   */
  export type DosbingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosbingCountOutputType
     */
    select?: DosbingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DosbingCountOutputType without action
   */
  export type DosbingCountOutputTypeCountMahasiswaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahasiswaWhereInput
  }

  /**
   * DosbingCountOutputType without action
   */
  export type DosbingCountOutputTypeCountPendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranMbkmWhereInput
  }


  /**
   * Count Type KoorMbkmCountOutputType
   */

  export type KoorMbkmCountOutputType = {
    PendaftaranAkun: number
    PendaftaranMbkm: number
    Pengumuman: number
  }

  export type KoorMbkmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendaftaranAkun?: boolean | KoorMbkmCountOutputTypeCountPendaftaranAkunArgs
    PendaftaranMbkm?: boolean | KoorMbkmCountOutputTypeCountPendaftaranMbkmArgs
    Pengumuman?: boolean | KoorMbkmCountOutputTypeCountPengumumanArgs
  }

  // Custom InputTypes
  /**
   * KoorMbkmCountOutputType without action
   */
  export type KoorMbkmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkmCountOutputType
     */
    select?: KoorMbkmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KoorMbkmCountOutputType without action
   */
  export type KoorMbkmCountOutputTypeCountPendaftaranAkunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranAkunWhereInput
  }

  /**
   * KoorMbkmCountOutputType without action
   */
  export type KoorMbkmCountOutputTypeCountPendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranMbkmWhereInput
  }

  /**
   * KoorMbkmCountOutputType without action
   */
  export type KoorMbkmCountOutputTypeCountPengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
  }


  /**
   * Count Type MahasiswaCountOutputType
   */

  export type MahasiswaCountOutputType = {
    PendaftaranMbkm: number
    PendaftaranAkun: number
  }

  export type MahasiswaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendaftaranMbkm?: boolean | MahasiswaCountOutputTypeCountPendaftaranMbkmArgs
    PendaftaranAkun?: boolean | MahasiswaCountOutputTypeCountPendaftaranAkunArgs
  }

  // Custom InputTypes
  /**
   * MahasiswaCountOutputType without action
   */
  export type MahasiswaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MahasiswaCountOutputType
     */
    select?: MahasiswaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MahasiswaCountOutputType without action
   */
  export type MahasiswaCountOutputTypeCountPendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranMbkmWhereInput
  }

  /**
   * MahasiswaCountOutputType without action
   */
  export type MahasiswaCountOutputTypeCountPendaftaranAkunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranAkunWhereInput
  }


  /**
   * Count Type PendaftaranMbkmCountOutputType
   */

  export type PendaftaranMbkmCountOutputType = {
    BerkasPenilaian: number
  }

  export type PendaftaranMbkmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BerkasPenilaian?: boolean | PendaftaranMbkmCountOutputTypeCountBerkasPenilaianArgs
  }

  // Custom InputTypes
  /**
   * PendaftaranMbkmCountOutputType without action
   */
  export type PendaftaranMbkmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkmCountOutputType
     */
    select?: PendaftaranMbkmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PendaftaranMbkmCountOutputType without action
   */
  export type PendaftaranMbkmCountOutputTypeCountBerkasPenilaianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BerkasPenilaianWhereInput
  }


  /**
   * Count Type ProgramMbkmCountOutputType
   */

  export type ProgramMbkmCountOutputType = {
    Mahasiswa: number
  }

  export type ProgramMbkmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | ProgramMbkmCountOutputTypeCountMahasiswaArgs
  }

  // Custom InputTypes
  /**
   * ProgramMbkmCountOutputType without action
   */
  export type ProgramMbkmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkmCountOutputType
     */
    select?: ProgramMbkmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramMbkmCountOutputType without action
   */
  export type ProgramMbkmCountOutputTypeCountMahasiswaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahasiswaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AdminSiap
   */

  export type AggregateAdminSiap = {
    _count: AdminSiapCountAggregateOutputType | null
    _avg: AdminSiapAvgAggregateOutputType | null
    _sum: AdminSiapSumAggregateOutputType | null
    _min: AdminSiapMinAggregateOutputType | null
    _max: AdminSiapMaxAggregateOutputType | null
  }

  export type AdminSiapAvgAggregateOutputType = {
    NIP_admin_siap: number | null
  }

  export type AdminSiapSumAggregateOutputType = {
    NIP_admin_siap: bigint | null
  }

  export type AdminSiapMinAggregateOutputType = {
    NIP_admin_siap: bigint | null
    nama_admin_siap: string | null
  }

  export type AdminSiapMaxAggregateOutputType = {
    NIP_admin_siap: bigint | null
    nama_admin_siap: string | null
  }

  export type AdminSiapCountAggregateOutputType = {
    NIP_admin_siap: number
    nama_admin_siap: number
    _all: number
  }


  export type AdminSiapAvgAggregateInputType = {
    NIP_admin_siap?: true
  }

  export type AdminSiapSumAggregateInputType = {
    NIP_admin_siap?: true
  }

  export type AdminSiapMinAggregateInputType = {
    NIP_admin_siap?: true
    nama_admin_siap?: true
  }

  export type AdminSiapMaxAggregateInputType = {
    NIP_admin_siap?: true
    nama_admin_siap?: true
  }

  export type AdminSiapCountAggregateInputType = {
    NIP_admin_siap?: true
    nama_admin_siap?: true
    _all?: true
  }

  export type AdminSiapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSiap to aggregate.
     */
    where?: AdminSiapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSiaps to fetch.
     */
    orderBy?: AdminSiapOrderByWithRelationInput | AdminSiapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSiapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSiaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSiaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSiaps
    **/
    _count?: true | AdminSiapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminSiapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSiapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSiapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSiapMaxAggregateInputType
  }

  export type GetAdminSiapAggregateType<T extends AdminSiapAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSiap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSiap[P]>
      : GetScalarType<T[P], AggregateAdminSiap[P]>
  }




  export type AdminSiapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSiapWhereInput
    orderBy?: AdminSiapOrderByWithAggregationInput | AdminSiapOrderByWithAggregationInput[]
    by: AdminSiapScalarFieldEnum[] | AdminSiapScalarFieldEnum
    having?: AdminSiapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSiapCountAggregateInputType | true
    _avg?: AdminSiapAvgAggregateInputType
    _sum?: AdminSiapSumAggregateInputType
    _min?: AdminSiapMinAggregateInputType
    _max?: AdminSiapMaxAggregateInputType
  }

  export type AdminSiapGroupByOutputType = {
    NIP_admin_siap: bigint
    nama_admin_siap: string
    _count: AdminSiapCountAggregateOutputType | null
    _avg: AdminSiapAvgAggregateOutputType | null
    _sum: AdminSiapSumAggregateOutputType | null
    _min: AdminSiapMinAggregateOutputType | null
    _max: AdminSiapMaxAggregateOutputType | null
  }

  type GetAdminSiapGroupByPayload<T extends AdminSiapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSiapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSiapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSiapGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSiapGroupByOutputType[P]>
        }
      >
    >


  export type AdminSiapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_admin_siap?: boolean
    nama_admin_siap?: boolean
    KonversiNilai?: boolean | AdminSiap$KonversiNilaiArgs<ExtArgs>
    _count?: boolean | AdminSiapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSiap"]>

  export type AdminSiapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_admin_siap?: boolean
    nama_admin_siap?: boolean
  }, ExtArgs["result"]["adminSiap"]>

  export type AdminSiapSelectScalar = {
    NIP_admin_siap?: boolean
    nama_admin_siap?: boolean
  }

  export type AdminSiapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KonversiNilai?: boolean | AdminSiap$KonversiNilaiArgs<ExtArgs>
    _count?: boolean | AdminSiapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminSiapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminSiapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSiap"
    objects: {
      KonversiNilai: Prisma.$KonversiNilaiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      NIP_admin_siap: bigint
      nama_admin_siap: string
    }, ExtArgs["result"]["adminSiap"]>
    composites: {}
  }

  type AdminSiapGetPayload<S extends boolean | null | undefined | AdminSiapDefaultArgs> = $Result.GetResult<Prisma.$AdminSiapPayload, S>

  type AdminSiapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminSiapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminSiapCountAggregateInputType | true
    }

  export interface AdminSiapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSiap'], meta: { name: 'AdminSiap' } }
    /**
     * Find zero or one AdminSiap that matches the filter.
     * @param {AdminSiapFindUniqueArgs} args - Arguments to find a AdminSiap
     * @example
     * // Get one AdminSiap
     * const adminSiap = await prisma.adminSiap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSiapFindUniqueArgs>(args: SelectSubset<T, AdminSiapFindUniqueArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminSiap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminSiapFindUniqueOrThrowArgs} args - Arguments to find a AdminSiap
     * @example
     * // Get one AdminSiap
     * const adminSiap = await prisma.adminSiap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSiapFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSiapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminSiap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapFindFirstArgs} args - Arguments to find a AdminSiap
     * @example
     * // Get one AdminSiap
     * const adminSiap = await prisma.adminSiap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSiapFindFirstArgs>(args?: SelectSubset<T, AdminSiapFindFirstArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminSiap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapFindFirstOrThrowArgs} args - Arguments to find a AdminSiap
     * @example
     * // Get one AdminSiap
     * const adminSiap = await prisma.adminSiap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSiapFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSiapFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminSiaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSiaps
     * const adminSiaps = await prisma.adminSiap.findMany()
     * 
     * // Get first 10 AdminSiaps
     * const adminSiaps = await prisma.adminSiap.findMany({ take: 10 })
     * 
     * // Only select the `NIP_admin_siap`
     * const adminSiapWithNIP_admin_siapOnly = await prisma.adminSiap.findMany({ select: { NIP_admin_siap: true } })
     * 
     */
    findMany<T extends AdminSiapFindManyArgs>(args?: SelectSubset<T, AdminSiapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminSiap.
     * @param {AdminSiapCreateArgs} args - Arguments to create a AdminSiap.
     * @example
     * // Create one AdminSiap
     * const AdminSiap = await prisma.adminSiap.create({
     *   data: {
     *     // ... data to create a AdminSiap
     *   }
     * })
     * 
     */
    create<T extends AdminSiapCreateArgs>(args: SelectSubset<T, AdminSiapCreateArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminSiaps.
     * @param {AdminSiapCreateManyArgs} args - Arguments to create many AdminSiaps.
     * @example
     * // Create many AdminSiaps
     * const adminSiap = await prisma.adminSiap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSiapCreateManyArgs>(args?: SelectSubset<T, AdminSiapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSiaps and returns the data saved in the database.
     * @param {AdminSiapCreateManyAndReturnArgs} args - Arguments to create many AdminSiaps.
     * @example
     * // Create many AdminSiaps
     * const adminSiap = await prisma.adminSiap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSiaps and only return the `NIP_admin_siap`
     * const adminSiapWithNIP_admin_siapOnly = await prisma.adminSiap.createManyAndReturn({ 
     *   select: { NIP_admin_siap: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSiapCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSiapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminSiap.
     * @param {AdminSiapDeleteArgs} args - Arguments to delete one AdminSiap.
     * @example
     * // Delete one AdminSiap
     * const AdminSiap = await prisma.adminSiap.delete({
     *   where: {
     *     // ... filter to delete one AdminSiap
     *   }
     * })
     * 
     */
    delete<T extends AdminSiapDeleteArgs>(args: SelectSubset<T, AdminSiapDeleteArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminSiap.
     * @param {AdminSiapUpdateArgs} args - Arguments to update one AdminSiap.
     * @example
     * // Update one AdminSiap
     * const adminSiap = await prisma.adminSiap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSiapUpdateArgs>(args: SelectSubset<T, AdminSiapUpdateArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminSiaps.
     * @param {AdminSiapDeleteManyArgs} args - Arguments to filter AdminSiaps to delete.
     * @example
     * // Delete a few AdminSiaps
     * const { count } = await prisma.adminSiap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSiapDeleteManyArgs>(args?: SelectSubset<T, AdminSiapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSiaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSiaps
     * const adminSiap = await prisma.adminSiap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSiapUpdateManyArgs>(args: SelectSubset<T, AdminSiapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminSiap.
     * @param {AdminSiapUpsertArgs} args - Arguments to update or create a AdminSiap.
     * @example
     * // Update or create a AdminSiap
     * const adminSiap = await prisma.adminSiap.upsert({
     *   create: {
     *     // ... data to create a AdminSiap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSiap we want to update
     *   }
     * })
     */
    upsert<T extends AdminSiapUpsertArgs>(args: SelectSubset<T, AdminSiapUpsertArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminSiaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapCountArgs} args - Arguments to filter AdminSiaps to count.
     * @example
     * // Count the number of AdminSiaps
     * const count = await prisma.adminSiap.count({
     *   where: {
     *     // ... the filter for the AdminSiaps we want to count
     *   }
     * })
    **/
    count<T extends AdminSiapCountArgs>(
      args?: Subset<T, AdminSiapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSiapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSiap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSiapAggregateArgs>(args: Subset<T, AdminSiapAggregateArgs>): Prisma.PrismaPromise<GetAdminSiapAggregateType<T>>

    /**
     * Group by AdminSiap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSiapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSiapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSiapGroupByArgs['orderBy'] }
        : { orderBy?: AdminSiapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSiapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSiapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSiap model
   */
  readonly fields: AdminSiapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSiap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSiapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KonversiNilai<T extends AdminSiap$KonversiNilaiArgs<ExtArgs> = {}>(args?: Subset<T, AdminSiap$KonversiNilaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSiap model
   */ 
  interface AdminSiapFieldRefs {
    readonly NIP_admin_siap: FieldRef<"AdminSiap", 'BigInt'>
    readonly nama_admin_siap: FieldRef<"AdminSiap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminSiap findUnique
   */
  export type AdminSiapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter, which AdminSiap to fetch.
     */
    where: AdminSiapWhereUniqueInput
  }

  /**
   * AdminSiap findUniqueOrThrow
   */
  export type AdminSiapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter, which AdminSiap to fetch.
     */
    where: AdminSiapWhereUniqueInput
  }

  /**
   * AdminSiap findFirst
   */
  export type AdminSiapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter, which AdminSiap to fetch.
     */
    where?: AdminSiapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSiaps to fetch.
     */
    orderBy?: AdminSiapOrderByWithRelationInput | AdminSiapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSiaps.
     */
    cursor?: AdminSiapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSiaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSiaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSiaps.
     */
    distinct?: AdminSiapScalarFieldEnum | AdminSiapScalarFieldEnum[]
  }

  /**
   * AdminSiap findFirstOrThrow
   */
  export type AdminSiapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter, which AdminSiap to fetch.
     */
    where?: AdminSiapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSiaps to fetch.
     */
    orderBy?: AdminSiapOrderByWithRelationInput | AdminSiapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSiaps.
     */
    cursor?: AdminSiapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSiaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSiaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSiaps.
     */
    distinct?: AdminSiapScalarFieldEnum | AdminSiapScalarFieldEnum[]
  }

  /**
   * AdminSiap findMany
   */
  export type AdminSiapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter, which AdminSiaps to fetch.
     */
    where?: AdminSiapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSiaps to fetch.
     */
    orderBy?: AdminSiapOrderByWithRelationInput | AdminSiapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSiaps.
     */
    cursor?: AdminSiapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSiaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSiaps.
     */
    skip?: number
    distinct?: AdminSiapScalarFieldEnum | AdminSiapScalarFieldEnum[]
  }

  /**
   * AdminSiap create
   */
  export type AdminSiapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminSiap.
     */
    data: XOR<AdminSiapCreateInput, AdminSiapUncheckedCreateInput>
  }

  /**
   * AdminSiap createMany
   */
  export type AdminSiapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSiaps.
     */
    data: AdminSiapCreateManyInput | AdminSiapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSiap createManyAndReturn
   */
  export type AdminSiapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminSiaps.
     */
    data: AdminSiapCreateManyInput | AdminSiapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSiap update
   */
  export type AdminSiapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminSiap.
     */
    data: XOR<AdminSiapUpdateInput, AdminSiapUncheckedUpdateInput>
    /**
     * Choose, which AdminSiap to update.
     */
    where: AdminSiapWhereUniqueInput
  }

  /**
   * AdminSiap updateMany
   */
  export type AdminSiapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSiaps.
     */
    data: XOR<AdminSiapUpdateManyMutationInput, AdminSiapUncheckedUpdateManyInput>
    /**
     * Filter which AdminSiaps to update
     */
    where?: AdminSiapWhereInput
  }

  /**
   * AdminSiap upsert
   */
  export type AdminSiapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminSiap to update in case it exists.
     */
    where: AdminSiapWhereUniqueInput
    /**
     * In case the AdminSiap found by the `where` argument doesn't exist, create a new AdminSiap with this data.
     */
    create: XOR<AdminSiapCreateInput, AdminSiapUncheckedCreateInput>
    /**
     * In case the AdminSiap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSiapUpdateInput, AdminSiapUncheckedUpdateInput>
  }

  /**
   * AdminSiap delete
   */
  export type AdminSiapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
    /**
     * Filter which AdminSiap to delete.
     */
    where: AdminSiapWhereUniqueInput
  }

  /**
   * AdminSiap deleteMany
   */
  export type AdminSiapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSiaps to delete
     */
    where?: AdminSiapWhereInput
  }

  /**
   * AdminSiap.KonversiNilai
   */
  export type AdminSiap$KonversiNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    where?: KonversiNilaiWhereInput
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    cursor?: KonversiNilaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KonversiNilaiScalarFieldEnum | KonversiNilaiScalarFieldEnum[]
  }

  /**
   * AdminSiap without action
   */
  export type AdminSiapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSiap
     */
    select?: AdminSiapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSiapInclude<ExtArgs> | null
  }


  /**
   * Model BerkasPenilaian
   */

  export type AggregateBerkasPenilaian = {
    _count: BerkasPenilaianCountAggregateOutputType | null
    _avg: BerkasPenilaianAvgAggregateOutputType | null
    _sum: BerkasPenilaianSumAggregateOutputType | null
    _min: BerkasPenilaianMinAggregateOutputType | null
    _max: BerkasPenilaianMaxAggregateOutputType | null
  }

  export type BerkasPenilaianAvgAggregateOutputType = {
    id_berkas_penilaian: number | null
    id_pendaftaran_mbkm: number | null
  }

  export type BerkasPenilaianSumAggregateOutputType = {
    id_berkas_penilaian: number | null
    id_pendaftaran_mbkm: number | null
  }

  export type BerkasPenilaianMinAggregateOutputType = {
    id_berkas_penilaian: number | null
    id_pendaftaran_mbkm: number | null
    nama_berkas: string | null
  }

  export type BerkasPenilaianMaxAggregateOutputType = {
    id_berkas_penilaian: number | null
    id_pendaftaran_mbkm: number | null
    nama_berkas: string | null
  }

  export type BerkasPenilaianCountAggregateOutputType = {
    id_berkas_penilaian: number
    id_pendaftaran_mbkm: number
    nama_berkas: number
    _all: number
  }


  export type BerkasPenilaianAvgAggregateInputType = {
    id_berkas_penilaian?: true
    id_pendaftaran_mbkm?: true
  }

  export type BerkasPenilaianSumAggregateInputType = {
    id_berkas_penilaian?: true
    id_pendaftaran_mbkm?: true
  }

  export type BerkasPenilaianMinAggregateInputType = {
    id_berkas_penilaian?: true
    id_pendaftaran_mbkm?: true
    nama_berkas?: true
  }

  export type BerkasPenilaianMaxAggregateInputType = {
    id_berkas_penilaian?: true
    id_pendaftaran_mbkm?: true
    nama_berkas?: true
  }

  export type BerkasPenilaianCountAggregateInputType = {
    id_berkas_penilaian?: true
    id_pendaftaran_mbkm?: true
    nama_berkas?: true
    _all?: true
  }

  export type BerkasPenilaianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BerkasPenilaian to aggregate.
     */
    where?: BerkasPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BerkasPenilaians to fetch.
     */
    orderBy?: BerkasPenilaianOrderByWithRelationInput | BerkasPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BerkasPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BerkasPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BerkasPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BerkasPenilaians
    **/
    _count?: true | BerkasPenilaianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BerkasPenilaianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BerkasPenilaianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BerkasPenilaianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BerkasPenilaianMaxAggregateInputType
  }

  export type GetBerkasPenilaianAggregateType<T extends BerkasPenilaianAggregateArgs> = {
        [P in keyof T & keyof AggregateBerkasPenilaian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBerkasPenilaian[P]>
      : GetScalarType<T[P], AggregateBerkasPenilaian[P]>
  }




  export type BerkasPenilaianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BerkasPenilaianWhereInput
    orderBy?: BerkasPenilaianOrderByWithAggregationInput | BerkasPenilaianOrderByWithAggregationInput[]
    by: BerkasPenilaianScalarFieldEnum[] | BerkasPenilaianScalarFieldEnum
    having?: BerkasPenilaianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BerkasPenilaianCountAggregateInputType | true
    _avg?: BerkasPenilaianAvgAggregateInputType
    _sum?: BerkasPenilaianSumAggregateInputType
    _min?: BerkasPenilaianMinAggregateInputType
    _max?: BerkasPenilaianMaxAggregateInputType
  }

  export type BerkasPenilaianGroupByOutputType = {
    id_berkas_penilaian: number
    id_pendaftaran_mbkm: number
    nama_berkas: string
    _count: BerkasPenilaianCountAggregateOutputType | null
    _avg: BerkasPenilaianAvgAggregateOutputType | null
    _sum: BerkasPenilaianSumAggregateOutputType | null
    _min: BerkasPenilaianMinAggregateOutputType | null
    _max: BerkasPenilaianMaxAggregateOutputType | null
  }

  type GetBerkasPenilaianGroupByPayload<T extends BerkasPenilaianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BerkasPenilaianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BerkasPenilaianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BerkasPenilaianGroupByOutputType[P]>
            : GetScalarType<T[P], BerkasPenilaianGroupByOutputType[P]>
        }
      >
    >


  export type BerkasPenilaianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_berkas_penilaian?: boolean
    id_pendaftaran_mbkm?: boolean
    nama_berkas?: boolean
    PendaftaranMbkm?: boolean | PendaftaranMbkmDefaultArgs<ExtArgs>
    KonversiNilai?: boolean | BerkasPenilaian$KonversiNilaiArgs<ExtArgs>
    _count?: boolean | BerkasPenilaianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["berkasPenilaian"]>

  export type BerkasPenilaianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_berkas_penilaian?: boolean
    id_pendaftaran_mbkm?: boolean
    nama_berkas?: boolean
    PendaftaranMbkm?: boolean | PendaftaranMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["berkasPenilaian"]>

  export type BerkasPenilaianSelectScalar = {
    id_berkas_penilaian?: boolean
    id_pendaftaran_mbkm?: boolean
    nama_berkas?: boolean
  }

  export type BerkasPenilaianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendaftaranMbkm?: boolean | PendaftaranMbkmDefaultArgs<ExtArgs>
    KonversiNilai?: boolean | BerkasPenilaian$KonversiNilaiArgs<ExtArgs>
    _count?: boolean | BerkasPenilaianCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BerkasPenilaianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendaftaranMbkm?: boolean | PendaftaranMbkmDefaultArgs<ExtArgs>
  }

  export type $BerkasPenilaianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BerkasPenilaian"
    objects: {
      PendaftaranMbkm: Prisma.$PendaftaranMbkmPayload<ExtArgs>
      KonversiNilai: Prisma.$KonversiNilaiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_berkas_penilaian: number
      id_pendaftaran_mbkm: number
      nama_berkas: string
    }, ExtArgs["result"]["berkasPenilaian"]>
    composites: {}
  }

  type BerkasPenilaianGetPayload<S extends boolean | null | undefined | BerkasPenilaianDefaultArgs> = $Result.GetResult<Prisma.$BerkasPenilaianPayload, S>

  type BerkasPenilaianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BerkasPenilaianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BerkasPenilaianCountAggregateInputType | true
    }

  export interface BerkasPenilaianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BerkasPenilaian'], meta: { name: 'BerkasPenilaian' } }
    /**
     * Find zero or one BerkasPenilaian that matches the filter.
     * @param {BerkasPenilaianFindUniqueArgs} args - Arguments to find a BerkasPenilaian
     * @example
     * // Get one BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BerkasPenilaianFindUniqueArgs>(args: SelectSubset<T, BerkasPenilaianFindUniqueArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BerkasPenilaian that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BerkasPenilaianFindUniqueOrThrowArgs} args - Arguments to find a BerkasPenilaian
     * @example
     * // Get one BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BerkasPenilaianFindUniqueOrThrowArgs>(args: SelectSubset<T, BerkasPenilaianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BerkasPenilaian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianFindFirstArgs} args - Arguments to find a BerkasPenilaian
     * @example
     * // Get one BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BerkasPenilaianFindFirstArgs>(args?: SelectSubset<T, BerkasPenilaianFindFirstArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BerkasPenilaian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianFindFirstOrThrowArgs} args - Arguments to find a BerkasPenilaian
     * @example
     * // Get one BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BerkasPenilaianFindFirstOrThrowArgs>(args?: SelectSubset<T, BerkasPenilaianFindFirstOrThrowArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BerkasPenilaians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BerkasPenilaians
     * const berkasPenilaians = await prisma.berkasPenilaian.findMany()
     * 
     * // Get first 10 BerkasPenilaians
     * const berkasPenilaians = await prisma.berkasPenilaian.findMany({ take: 10 })
     * 
     * // Only select the `id_berkas_penilaian`
     * const berkasPenilaianWithId_berkas_penilaianOnly = await prisma.berkasPenilaian.findMany({ select: { id_berkas_penilaian: true } })
     * 
     */
    findMany<T extends BerkasPenilaianFindManyArgs>(args?: SelectSubset<T, BerkasPenilaianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BerkasPenilaian.
     * @param {BerkasPenilaianCreateArgs} args - Arguments to create a BerkasPenilaian.
     * @example
     * // Create one BerkasPenilaian
     * const BerkasPenilaian = await prisma.berkasPenilaian.create({
     *   data: {
     *     // ... data to create a BerkasPenilaian
     *   }
     * })
     * 
     */
    create<T extends BerkasPenilaianCreateArgs>(args: SelectSubset<T, BerkasPenilaianCreateArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BerkasPenilaians.
     * @param {BerkasPenilaianCreateManyArgs} args - Arguments to create many BerkasPenilaians.
     * @example
     * // Create many BerkasPenilaians
     * const berkasPenilaian = await prisma.berkasPenilaian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BerkasPenilaianCreateManyArgs>(args?: SelectSubset<T, BerkasPenilaianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BerkasPenilaians and returns the data saved in the database.
     * @param {BerkasPenilaianCreateManyAndReturnArgs} args - Arguments to create many BerkasPenilaians.
     * @example
     * // Create many BerkasPenilaians
     * const berkasPenilaian = await prisma.berkasPenilaian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BerkasPenilaians and only return the `id_berkas_penilaian`
     * const berkasPenilaianWithId_berkas_penilaianOnly = await prisma.berkasPenilaian.createManyAndReturn({ 
     *   select: { id_berkas_penilaian: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BerkasPenilaianCreateManyAndReturnArgs>(args?: SelectSubset<T, BerkasPenilaianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BerkasPenilaian.
     * @param {BerkasPenilaianDeleteArgs} args - Arguments to delete one BerkasPenilaian.
     * @example
     * // Delete one BerkasPenilaian
     * const BerkasPenilaian = await prisma.berkasPenilaian.delete({
     *   where: {
     *     // ... filter to delete one BerkasPenilaian
     *   }
     * })
     * 
     */
    delete<T extends BerkasPenilaianDeleteArgs>(args: SelectSubset<T, BerkasPenilaianDeleteArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BerkasPenilaian.
     * @param {BerkasPenilaianUpdateArgs} args - Arguments to update one BerkasPenilaian.
     * @example
     * // Update one BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BerkasPenilaianUpdateArgs>(args: SelectSubset<T, BerkasPenilaianUpdateArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BerkasPenilaians.
     * @param {BerkasPenilaianDeleteManyArgs} args - Arguments to filter BerkasPenilaians to delete.
     * @example
     * // Delete a few BerkasPenilaians
     * const { count } = await prisma.berkasPenilaian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BerkasPenilaianDeleteManyArgs>(args?: SelectSubset<T, BerkasPenilaianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BerkasPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BerkasPenilaians
     * const berkasPenilaian = await prisma.berkasPenilaian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BerkasPenilaianUpdateManyArgs>(args: SelectSubset<T, BerkasPenilaianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BerkasPenilaian.
     * @param {BerkasPenilaianUpsertArgs} args - Arguments to update or create a BerkasPenilaian.
     * @example
     * // Update or create a BerkasPenilaian
     * const berkasPenilaian = await prisma.berkasPenilaian.upsert({
     *   create: {
     *     // ... data to create a BerkasPenilaian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BerkasPenilaian we want to update
     *   }
     * })
     */
    upsert<T extends BerkasPenilaianUpsertArgs>(args: SelectSubset<T, BerkasPenilaianUpsertArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BerkasPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianCountArgs} args - Arguments to filter BerkasPenilaians to count.
     * @example
     * // Count the number of BerkasPenilaians
     * const count = await prisma.berkasPenilaian.count({
     *   where: {
     *     // ... the filter for the BerkasPenilaians we want to count
     *   }
     * })
    **/
    count<T extends BerkasPenilaianCountArgs>(
      args?: Subset<T, BerkasPenilaianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BerkasPenilaianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BerkasPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BerkasPenilaianAggregateArgs>(args: Subset<T, BerkasPenilaianAggregateArgs>): Prisma.PrismaPromise<GetBerkasPenilaianAggregateType<T>>

    /**
     * Group by BerkasPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BerkasPenilaianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BerkasPenilaianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BerkasPenilaianGroupByArgs['orderBy'] }
        : { orderBy?: BerkasPenilaianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BerkasPenilaianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBerkasPenilaianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BerkasPenilaian model
   */
  readonly fields: BerkasPenilaianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BerkasPenilaian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BerkasPenilaianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PendaftaranMbkm<T extends PendaftaranMbkmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendaftaranMbkmDefaultArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    KonversiNilai<T extends BerkasPenilaian$KonversiNilaiArgs<ExtArgs> = {}>(args?: Subset<T, BerkasPenilaian$KonversiNilaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BerkasPenilaian model
   */ 
  interface BerkasPenilaianFieldRefs {
    readonly id_berkas_penilaian: FieldRef<"BerkasPenilaian", 'Int'>
    readonly id_pendaftaran_mbkm: FieldRef<"BerkasPenilaian", 'Int'>
    readonly nama_berkas: FieldRef<"BerkasPenilaian", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BerkasPenilaian findUnique
   */
  export type BerkasPenilaianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which BerkasPenilaian to fetch.
     */
    where: BerkasPenilaianWhereUniqueInput
  }

  /**
   * BerkasPenilaian findUniqueOrThrow
   */
  export type BerkasPenilaianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which BerkasPenilaian to fetch.
     */
    where: BerkasPenilaianWhereUniqueInput
  }

  /**
   * BerkasPenilaian findFirst
   */
  export type BerkasPenilaianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which BerkasPenilaian to fetch.
     */
    where?: BerkasPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BerkasPenilaians to fetch.
     */
    orderBy?: BerkasPenilaianOrderByWithRelationInput | BerkasPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BerkasPenilaians.
     */
    cursor?: BerkasPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BerkasPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BerkasPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BerkasPenilaians.
     */
    distinct?: BerkasPenilaianScalarFieldEnum | BerkasPenilaianScalarFieldEnum[]
  }

  /**
   * BerkasPenilaian findFirstOrThrow
   */
  export type BerkasPenilaianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which BerkasPenilaian to fetch.
     */
    where?: BerkasPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BerkasPenilaians to fetch.
     */
    orderBy?: BerkasPenilaianOrderByWithRelationInput | BerkasPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BerkasPenilaians.
     */
    cursor?: BerkasPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BerkasPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BerkasPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BerkasPenilaians.
     */
    distinct?: BerkasPenilaianScalarFieldEnum | BerkasPenilaianScalarFieldEnum[]
  }

  /**
   * BerkasPenilaian findMany
   */
  export type BerkasPenilaianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which BerkasPenilaians to fetch.
     */
    where?: BerkasPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BerkasPenilaians to fetch.
     */
    orderBy?: BerkasPenilaianOrderByWithRelationInput | BerkasPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BerkasPenilaians.
     */
    cursor?: BerkasPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BerkasPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BerkasPenilaians.
     */
    skip?: number
    distinct?: BerkasPenilaianScalarFieldEnum | BerkasPenilaianScalarFieldEnum[]
  }

  /**
   * BerkasPenilaian create
   */
  export type BerkasPenilaianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * The data needed to create a BerkasPenilaian.
     */
    data: XOR<BerkasPenilaianCreateInput, BerkasPenilaianUncheckedCreateInput>
  }

  /**
   * BerkasPenilaian createMany
   */
  export type BerkasPenilaianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BerkasPenilaians.
     */
    data: BerkasPenilaianCreateManyInput | BerkasPenilaianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BerkasPenilaian createManyAndReturn
   */
  export type BerkasPenilaianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BerkasPenilaians.
     */
    data: BerkasPenilaianCreateManyInput | BerkasPenilaianCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BerkasPenilaian update
   */
  export type BerkasPenilaianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * The data needed to update a BerkasPenilaian.
     */
    data: XOR<BerkasPenilaianUpdateInput, BerkasPenilaianUncheckedUpdateInput>
    /**
     * Choose, which BerkasPenilaian to update.
     */
    where: BerkasPenilaianWhereUniqueInput
  }

  /**
   * BerkasPenilaian updateMany
   */
  export type BerkasPenilaianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BerkasPenilaians.
     */
    data: XOR<BerkasPenilaianUpdateManyMutationInput, BerkasPenilaianUncheckedUpdateManyInput>
    /**
     * Filter which BerkasPenilaians to update
     */
    where?: BerkasPenilaianWhereInput
  }

  /**
   * BerkasPenilaian upsert
   */
  export type BerkasPenilaianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * The filter to search for the BerkasPenilaian to update in case it exists.
     */
    where: BerkasPenilaianWhereUniqueInput
    /**
     * In case the BerkasPenilaian found by the `where` argument doesn't exist, create a new BerkasPenilaian with this data.
     */
    create: XOR<BerkasPenilaianCreateInput, BerkasPenilaianUncheckedCreateInput>
    /**
     * In case the BerkasPenilaian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BerkasPenilaianUpdateInput, BerkasPenilaianUncheckedUpdateInput>
  }

  /**
   * BerkasPenilaian delete
   */
  export type BerkasPenilaianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    /**
     * Filter which BerkasPenilaian to delete.
     */
    where: BerkasPenilaianWhereUniqueInput
  }

  /**
   * BerkasPenilaian deleteMany
   */
  export type BerkasPenilaianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BerkasPenilaians to delete
     */
    where?: BerkasPenilaianWhereInput
  }

  /**
   * BerkasPenilaian.KonversiNilai
   */
  export type BerkasPenilaian$KonversiNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    where?: KonversiNilaiWhereInput
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    cursor?: KonversiNilaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KonversiNilaiScalarFieldEnum | KonversiNilaiScalarFieldEnum[]
  }

  /**
   * BerkasPenilaian without action
   */
  export type BerkasPenilaianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
  }


  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    name: string
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ProgramMbkm?: boolean | Categories$ProgramMbkmArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProgramMbkm?: boolean | Categories$ProgramMbkmArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      ProgramMbkm: Prisma.$ProgramMbkmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesFindUniqueArgs>(args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesFindFirstArgs>(args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriesFindManyArgs>(args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends CategoriesCreateArgs>(args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesCreateManyArgs>(args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends CategoriesDeleteArgs>(args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesUpdateArgs>(args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesDeleteManyArgs>(args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesUpdateManyArgs>(args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesUpsertArgs>(args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProgramMbkm<T extends Categories$ProgramMbkmArgs<ExtArgs> = {}>(args?: Subset<T, Categories$ProgramMbkmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categories model
   */ 
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'String'>
    readonly name: FieldRef<"Categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories createManyAndReturn
   */
  export type CategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories.ProgramMbkm
   */
  export type Categories$ProgramMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    where?: ProgramMbkmWhereInput
    orderBy?: ProgramMbkmOrderByWithRelationInput | ProgramMbkmOrderByWithRelationInput[]
    cursor?: ProgramMbkmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramMbkmScalarFieldEnum | ProgramMbkmScalarFieldEnum[]
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Dosbing
   */

  export type AggregateDosbing = {
    _count: DosbingCountAggregateOutputType | null
    _avg: DosbingAvgAggregateOutputType | null
    _sum: DosbingSumAggregateOutputType | null
    _min: DosbingMinAggregateOutputType | null
    _max: DosbingMaxAggregateOutputType | null
  }

  export type DosbingAvgAggregateOutputType = {
    NIP_dosbing: number | null
  }

  export type DosbingSumAggregateOutputType = {
    NIP_dosbing: bigint | null
  }

  export type DosbingMinAggregateOutputType = {
    NIP_dosbing: bigint | null
    nama_dosbing: string | null
  }

  export type DosbingMaxAggregateOutputType = {
    NIP_dosbing: bigint | null
    nama_dosbing: string | null
  }

  export type DosbingCountAggregateOutputType = {
    NIP_dosbing: number
    nama_dosbing: number
    _all: number
  }


  export type DosbingAvgAggregateInputType = {
    NIP_dosbing?: true
  }

  export type DosbingSumAggregateInputType = {
    NIP_dosbing?: true
  }

  export type DosbingMinAggregateInputType = {
    NIP_dosbing?: true
    nama_dosbing?: true
  }

  export type DosbingMaxAggregateInputType = {
    NIP_dosbing?: true
    nama_dosbing?: true
  }

  export type DosbingCountAggregateInputType = {
    NIP_dosbing?: true
    nama_dosbing?: true
    _all?: true
  }

  export type DosbingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dosbing to aggregate.
     */
    where?: DosbingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dosbings to fetch.
     */
    orderBy?: DosbingOrderByWithRelationInput | DosbingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DosbingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dosbings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dosbings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dosbings
    **/
    _count?: true | DosbingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DosbingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DosbingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DosbingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DosbingMaxAggregateInputType
  }

  export type GetDosbingAggregateType<T extends DosbingAggregateArgs> = {
        [P in keyof T & keyof AggregateDosbing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDosbing[P]>
      : GetScalarType<T[P], AggregateDosbing[P]>
  }




  export type DosbingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DosbingWhereInput
    orderBy?: DosbingOrderByWithAggregationInput | DosbingOrderByWithAggregationInput[]
    by: DosbingScalarFieldEnum[] | DosbingScalarFieldEnum
    having?: DosbingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DosbingCountAggregateInputType | true
    _avg?: DosbingAvgAggregateInputType
    _sum?: DosbingSumAggregateInputType
    _min?: DosbingMinAggregateInputType
    _max?: DosbingMaxAggregateInputType
  }

  export type DosbingGroupByOutputType = {
    NIP_dosbing: bigint
    nama_dosbing: string
    _count: DosbingCountAggregateOutputType | null
    _avg: DosbingAvgAggregateOutputType | null
    _sum: DosbingSumAggregateOutputType | null
    _min: DosbingMinAggregateOutputType | null
    _max: DosbingMaxAggregateOutputType | null
  }

  type GetDosbingGroupByPayload<T extends DosbingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DosbingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DosbingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DosbingGroupByOutputType[P]>
            : GetScalarType<T[P], DosbingGroupByOutputType[P]>
        }
      >
    >


  export type DosbingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_dosbing?: boolean
    nama_dosbing?: boolean
    Mahasiswa?: boolean | Dosbing$MahasiswaArgs<ExtArgs>
    PendaftaranMbkm?: boolean | Dosbing$PendaftaranMbkmArgs<ExtArgs>
    _count?: boolean | DosbingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dosbing"]>

  export type DosbingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_dosbing?: boolean
    nama_dosbing?: boolean
  }, ExtArgs["result"]["dosbing"]>

  export type DosbingSelectScalar = {
    NIP_dosbing?: boolean
    nama_dosbing?: boolean
  }

  export type DosbingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | Dosbing$MahasiswaArgs<ExtArgs>
    PendaftaranMbkm?: boolean | Dosbing$PendaftaranMbkmArgs<ExtArgs>
    _count?: boolean | DosbingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DosbingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DosbingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dosbing"
    objects: {
      Mahasiswa: Prisma.$MahasiswaPayload<ExtArgs>[]
      PendaftaranMbkm: Prisma.$PendaftaranMbkmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      NIP_dosbing: bigint
      nama_dosbing: string
    }, ExtArgs["result"]["dosbing"]>
    composites: {}
  }

  type DosbingGetPayload<S extends boolean | null | undefined | DosbingDefaultArgs> = $Result.GetResult<Prisma.$DosbingPayload, S>

  type DosbingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DosbingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DosbingCountAggregateInputType | true
    }

  export interface DosbingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dosbing'], meta: { name: 'Dosbing' } }
    /**
     * Find zero or one Dosbing that matches the filter.
     * @param {DosbingFindUniqueArgs} args - Arguments to find a Dosbing
     * @example
     * // Get one Dosbing
     * const dosbing = await prisma.dosbing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DosbingFindUniqueArgs>(args: SelectSubset<T, DosbingFindUniqueArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dosbing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DosbingFindUniqueOrThrowArgs} args - Arguments to find a Dosbing
     * @example
     * // Get one Dosbing
     * const dosbing = await prisma.dosbing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DosbingFindUniqueOrThrowArgs>(args: SelectSubset<T, DosbingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dosbing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingFindFirstArgs} args - Arguments to find a Dosbing
     * @example
     * // Get one Dosbing
     * const dosbing = await prisma.dosbing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DosbingFindFirstArgs>(args?: SelectSubset<T, DosbingFindFirstArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dosbing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingFindFirstOrThrowArgs} args - Arguments to find a Dosbing
     * @example
     * // Get one Dosbing
     * const dosbing = await prisma.dosbing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DosbingFindFirstOrThrowArgs>(args?: SelectSubset<T, DosbingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dosbings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dosbings
     * const dosbings = await prisma.dosbing.findMany()
     * 
     * // Get first 10 Dosbings
     * const dosbings = await prisma.dosbing.findMany({ take: 10 })
     * 
     * // Only select the `NIP_dosbing`
     * const dosbingWithNIP_dosbingOnly = await prisma.dosbing.findMany({ select: { NIP_dosbing: true } })
     * 
     */
    findMany<T extends DosbingFindManyArgs>(args?: SelectSubset<T, DosbingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dosbing.
     * @param {DosbingCreateArgs} args - Arguments to create a Dosbing.
     * @example
     * // Create one Dosbing
     * const Dosbing = await prisma.dosbing.create({
     *   data: {
     *     // ... data to create a Dosbing
     *   }
     * })
     * 
     */
    create<T extends DosbingCreateArgs>(args: SelectSubset<T, DosbingCreateArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dosbings.
     * @param {DosbingCreateManyArgs} args - Arguments to create many Dosbings.
     * @example
     * // Create many Dosbings
     * const dosbing = await prisma.dosbing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DosbingCreateManyArgs>(args?: SelectSubset<T, DosbingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dosbings and returns the data saved in the database.
     * @param {DosbingCreateManyAndReturnArgs} args - Arguments to create many Dosbings.
     * @example
     * // Create many Dosbings
     * const dosbing = await prisma.dosbing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dosbings and only return the `NIP_dosbing`
     * const dosbingWithNIP_dosbingOnly = await prisma.dosbing.createManyAndReturn({ 
     *   select: { NIP_dosbing: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DosbingCreateManyAndReturnArgs>(args?: SelectSubset<T, DosbingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dosbing.
     * @param {DosbingDeleteArgs} args - Arguments to delete one Dosbing.
     * @example
     * // Delete one Dosbing
     * const Dosbing = await prisma.dosbing.delete({
     *   where: {
     *     // ... filter to delete one Dosbing
     *   }
     * })
     * 
     */
    delete<T extends DosbingDeleteArgs>(args: SelectSubset<T, DosbingDeleteArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dosbing.
     * @param {DosbingUpdateArgs} args - Arguments to update one Dosbing.
     * @example
     * // Update one Dosbing
     * const dosbing = await prisma.dosbing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DosbingUpdateArgs>(args: SelectSubset<T, DosbingUpdateArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dosbings.
     * @param {DosbingDeleteManyArgs} args - Arguments to filter Dosbings to delete.
     * @example
     * // Delete a few Dosbings
     * const { count } = await prisma.dosbing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DosbingDeleteManyArgs>(args?: SelectSubset<T, DosbingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dosbings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dosbings
     * const dosbing = await prisma.dosbing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DosbingUpdateManyArgs>(args: SelectSubset<T, DosbingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dosbing.
     * @param {DosbingUpsertArgs} args - Arguments to update or create a Dosbing.
     * @example
     * // Update or create a Dosbing
     * const dosbing = await prisma.dosbing.upsert({
     *   create: {
     *     // ... data to create a Dosbing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dosbing we want to update
     *   }
     * })
     */
    upsert<T extends DosbingUpsertArgs>(args: SelectSubset<T, DosbingUpsertArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dosbings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingCountArgs} args - Arguments to filter Dosbings to count.
     * @example
     * // Count the number of Dosbings
     * const count = await prisma.dosbing.count({
     *   where: {
     *     // ... the filter for the Dosbings we want to count
     *   }
     * })
    **/
    count<T extends DosbingCountArgs>(
      args?: Subset<T, DosbingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DosbingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dosbing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DosbingAggregateArgs>(args: Subset<T, DosbingAggregateArgs>): Prisma.PrismaPromise<GetDosbingAggregateType<T>>

    /**
     * Group by Dosbing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosbingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DosbingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DosbingGroupByArgs['orderBy'] }
        : { orderBy?: DosbingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DosbingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDosbingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dosbing model
   */
  readonly fields: DosbingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dosbing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DosbingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Mahasiswa<T extends Dosbing$MahasiswaArgs<ExtArgs> = {}>(args?: Subset<T, Dosbing$MahasiswaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findMany"> | Null>
    PendaftaranMbkm<T extends Dosbing$PendaftaranMbkmArgs<ExtArgs> = {}>(args?: Subset<T, Dosbing$PendaftaranMbkmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dosbing model
   */ 
  interface DosbingFieldRefs {
    readonly NIP_dosbing: FieldRef<"Dosbing", 'BigInt'>
    readonly nama_dosbing: FieldRef<"Dosbing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dosbing findUnique
   */
  export type DosbingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter, which Dosbing to fetch.
     */
    where: DosbingWhereUniqueInput
  }

  /**
   * Dosbing findUniqueOrThrow
   */
  export type DosbingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter, which Dosbing to fetch.
     */
    where: DosbingWhereUniqueInput
  }

  /**
   * Dosbing findFirst
   */
  export type DosbingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter, which Dosbing to fetch.
     */
    where?: DosbingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dosbings to fetch.
     */
    orderBy?: DosbingOrderByWithRelationInput | DosbingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dosbings.
     */
    cursor?: DosbingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dosbings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dosbings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dosbings.
     */
    distinct?: DosbingScalarFieldEnum | DosbingScalarFieldEnum[]
  }

  /**
   * Dosbing findFirstOrThrow
   */
  export type DosbingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter, which Dosbing to fetch.
     */
    where?: DosbingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dosbings to fetch.
     */
    orderBy?: DosbingOrderByWithRelationInput | DosbingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dosbings.
     */
    cursor?: DosbingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dosbings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dosbings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dosbings.
     */
    distinct?: DosbingScalarFieldEnum | DosbingScalarFieldEnum[]
  }

  /**
   * Dosbing findMany
   */
  export type DosbingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter, which Dosbings to fetch.
     */
    where?: DosbingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dosbings to fetch.
     */
    orderBy?: DosbingOrderByWithRelationInput | DosbingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dosbings.
     */
    cursor?: DosbingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dosbings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dosbings.
     */
    skip?: number
    distinct?: DosbingScalarFieldEnum | DosbingScalarFieldEnum[]
  }

  /**
   * Dosbing create
   */
  export type DosbingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * The data needed to create a Dosbing.
     */
    data: XOR<DosbingCreateInput, DosbingUncheckedCreateInput>
  }

  /**
   * Dosbing createMany
   */
  export type DosbingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dosbings.
     */
    data: DosbingCreateManyInput | DosbingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dosbing createManyAndReturn
   */
  export type DosbingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Dosbings.
     */
    data: DosbingCreateManyInput | DosbingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dosbing update
   */
  export type DosbingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * The data needed to update a Dosbing.
     */
    data: XOR<DosbingUpdateInput, DosbingUncheckedUpdateInput>
    /**
     * Choose, which Dosbing to update.
     */
    where: DosbingWhereUniqueInput
  }

  /**
   * Dosbing updateMany
   */
  export type DosbingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dosbings.
     */
    data: XOR<DosbingUpdateManyMutationInput, DosbingUncheckedUpdateManyInput>
    /**
     * Filter which Dosbings to update
     */
    where?: DosbingWhereInput
  }

  /**
   * Dosbing upsert
   */
  export type DosbingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * The filter to search for the Dosbing to update in case it exists.
     */
    where: DosbingWhereUniqueInput
    /**
     * In case the Dosbing found by the `where` argument doesn't exist, create a new Dosbing with this data.
     */
    create: XOR<DosbingCreateInput, DosbingUncheckedCreateInput>
    /**
     * In case the Dosbing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DosbingUpdateInput, DosbingUncheckedUpdateInput>
  }

  /**
   * Dosbing delete
   */
  export type DosbingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
    /**
     * Filter which Dosbing to delete.
     */
    where: DosbingWhereUniqueInput
  }

  /**
   * Dosbing deleteMany
   */
  export type DosbingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dosbings to delete
     */
    where?: DosbingWhereInput
  }

  /**
   * Dosbing.Mahasiswa
   */
  export type Dosbing$MahasiswaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    where?: MahasiswaWhereInput
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    cursor?: MahasiswaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MahasiswaScalarFieldEnum | MahasiswaScalarFieldEnum[]
  }

  /**
   * Dosbing.PendaftaranMbkm
   */
  export type Dosbing$PendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    where?: PendaftaranMbkmWhereInput
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    cursor?: PendaftaranMbkmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * Dosbing without action
   */
  export type DosbingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dosbing
     */
    select?: DosbingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosbingInclude<ExtArgs> | null
  }


  /**
   * Model KonversiNilai
   */

  export type AggregateKonversiNilai = {
    _count: KonversiNilaiCountAggregateOutputType | null
    _avg: KonversiNilaiAvgAggregateOutputType | null
    _sum: KonversiNilaiSumAggregateOutputType | null
    _min: KonversiNilaiMinAggregateOutputType | null
    _max: KonversiNilaiMaxAggregateOutputType | null
  }

  export type KonversiNilaiAvgAggregateOutputType = {
    id_konversi_nilai: number | null
    NIP_admin_siap: number | null
    id_berkas_penilaian: number | null
    nilai_akhir: number | null
  }

  export type KonversiNilaiSumAggregateOutputType = {
    id_konversi_nilai: number | null
    NIP_admin_siap: bigint | null
    id_berkas_penilaian: number | null
    nilai_akhir: number | null
  }

  export type KonversiNilaiMinAggregateOutputType = {
    id_konversi_nilai: number | null
    NIP_admin_siap: bigint | null
    id_berkas_penilaian: number | null
    nilai_akhir: number | null
    grade: string | null
  }

  export type KonversiNilaiMaxAggregateOutputType = {
    id_konversi_nilai: number | null
    NIP_admin_siap: bigint | null
    id_berkas_penilaian: number | null
    nilai_akhir: number | null
    grade: string | null
  }

  export type KonversiNilaiCountAggregateOutputType = {
    id_konversi_nilai: number
    NIP_admin_siap: number
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: number
    _all: number
  }


  export type KonversiNilaiAvgAggregateInputType = {
    id_konversi_nilai?: true
    NIP_admin_siap?: true
    id_berkas_penilaian?: true
    nilai_akhir?: true
  }

  export type KonversiNilaiSumAggregateInputType = {
    id_konversi_nilai?: true
    NIP_admin_siap?: true
    id_berkas_penilaian?: true
    nilai_akhir?: true
  }

  export type KonversiNilaiMinAggregateInputType = {
    id_konversi_nilai?: true
    NIP_admin_siap?: true
    id_berkas_penilaian?: true
    nilai_akhir?: true
    grade?: true
  }

  export type KonversiNilaiMaxAggregateInputType = {
    id_konversi_nilai?: true
    NIP_admin_siap?: true
    id_berkas_penilaian?: true
    nilai_akhir?: true
    grade?: true
  }

  export type KonversiNilaiCountAggregateInputType = {
    id_konversi_nilai?: true
    NIP_admin_siap?: true
    id_berkas_penilaian?: true
    nilai_akhir?: true
    grade?: true
    _all?: true
  }

  export type KonversiNilaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KonversiNilai to aggregate.
     */
    where?: KonversiNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonversiNilais to fetch.
     */
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KonversiNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonversiNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonversiNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KonversiNilais
    **/
    _count?: true | KonversiNilaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KonversiNilaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KonversiNilaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KonversiNilaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KonversiNilaiMaxAggregateInputType
  }

  export type GetKonversiNilaiAggregateType<T extends KonversiNilaiAggregateArgs> = {
        [P in keyof T & keyof AggregateKonversiNilai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKonversiNilai[P]>
      : GetScalarType<T[P], AggregateKonversiNilai[P]>
  }




  export type KonversiNilaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KonversiNilaiWhereInput
    orderBy?: KonversiNilaiOrderByWithAggregationInput | KonversiNilaiOrderByWithAggregationInput[]
    by: KonversiNilaiScalarFieldEnum[] | KonversiNilaiScalarFieldEnum
    having?: KonversiNilaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KonversiNilaiCountAggregateInputType | true
    _avg?: KonversiNilaiAvgAggregateInputType
    _sum?: KonversiNilaiSumAggregateInputType
    _min?: KonversiNilaiMinAggregateInputType
    _max?: KonversiNilaiMaxAggregateInputType
  }

  export type KonversiNilaiGroupByOutputType = {
    id_konversi_nilai: number
    NIP_admin_siap: bigint
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: string
    _count: KonversiNilaiCountAggregateOutputType | null
    _avg: KonversiNilaiAvgAggregateOutputType | null
    _sum: KonversiNilaiSumAggregateOutputType | null
    _min: KonversiNilaiMinAggregateOutputType | null
    _max: KonversiNilaiMaxAggregateOutputType | null
  }

  type GetKonversiNilaiGroupByPayload<T extends KonversiNilaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KonversiNilaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KonversiNilaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KonversiNilaiGroupByOutputType[P]>
            : GetScalarType<T[P], KonversiNilaiGroupByOutputType[P]>
        }
      >
    >


  export type KonversiNilaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_konversi_nilai?: boolean
    NIP_admin_siap?: boolean
    id_berkas_penilaian?: boolean
    nilai_akhir?: boolean
    grade?: boolean
    AdminSiap?: boolean | AdminSiapDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | BerkasPenilaianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["konversiNilai"]>

  export type KonversiNilaiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_konversi_nilai?: boolean
    NIP_admin_siap?: boolean
    id_berkas_penilaian?: boolean
    nilai_akhir?: boolean
    grade?: boolean
    AdminSiap?: boolean | AdminSiapDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | BerkasPenilaianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["konversiNilai"]>

  export type KonversiNilaiSelectScalar = {
    id_konversi_nilai?: boolean
    NIP_admin_siap?: boolean
    id_berkas_penilaian?: boolean
    nilai_akhir?: boolean
    grade?: boolean
  }

  export type KonversiNilaiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminSiap?: boolean | AdminSiapDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | BerkasPenilaianDefaultArgs<ExtArgs>
  }
  export type KonversiNilaiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminSiap?: boolean | AdminSiapDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | BerkasPenilaianDefaultArgs<ExtArgs>
  }

  export type $KonversiNilaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KonversiNilai"
    objects: {
      AdminSiap: Prisma.$AdminSiapPayload<ExtArgs>
      BerkasPenilaian: Prisma.$BerkasPenilaianPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_konversi_nilai: number
      NIP_admin_siap: bigint
      id_berkas_penilaian: number
      nilai_akhir: number
      grade: string
    }, ExtArgs["result"]["konversiNilai"]>
    composites: {}
  }

  type KonversiNilaiGetPayload<S extends boolean | null | undefined | KonversiNilaiDefaultArgs> = $Result.GetResult<Prisma.$KonversiNilaiPayload, S>

  type KonversiNilaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KonversiNilaiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KonversiNilaiCountAggregateInputType | true
    }

  export interface KonversiNilaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KonversiNilai'], meta: { name: 'KonversiNilai' } }
    /**
     * Find zero or one KonversiNilai that matches the filter.
     * @param {KonversiNilaiFindUniqueArgs} args - Arguments to find a KonversiNilai
     * @example
     * // Get one KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KonversiNilaiFindUniqueArgs>(args: SelectSubset<T, KonversiNilaiFindUniqueArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KonversiNilai that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KonversiNilaiFindUniqueOrThrowArgs} args - Arguments to find a KonversiNilai
     * @example
     * // Get one KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KonversiNilaiFindUniqueOrThrowArgs>(args: SelectSubset<T, KonversiNilaiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KonversiNilai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiFindFirstArgs} args - Arguments to find a KonversiNilai
     * @example
     * // Get one KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KonversiNilaiFindFirstArgs>(args?: SelectSubset<T, KonversiNilaiFindFirstArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KonversiNilai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiFindFirstOrThrowArgs} args - Arguments to find a KonversiNilai
     * @example
     * // Get one KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KonversiNilaiFindFirstOrThrowArgs>(args?: SelectSubset<T, KonversiNilaiFindFirstOrThrowArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KonversiNilais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KonversiNilais
     * const konversiNilais = await prisma.konversiNilai.findMany()
     * 
     * // Get first 10 KonversiNilais
     * const konversiNilais = await prisma.konversiNilai.findMany({ take: 10 })
     * 
     * // Only select the `id_konversi_nilai`
     * const konversiNilaiWithId_konversi_nilaiOnly = await prisma.konversiNilai.findMany({ select: { id_konversi_nilai: true } })
     * 
     */
    findMany<T extends KonversiNilaiFindManyArgs>(args?: SelectSubset<T, KonversiNilaiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KonversiNilai.
     * @param {KonversiNilaiCreateArgs} args - Arguments to create a KonversiNilai.
     * @example
     * // Create one KonversiNilai
     * const KonversiNilai = await prisma.konversiNilai.create({
     *   data: {
     *     // ... data to create a KonversiNilai
     *   }
     * })
     * 
     */
    create<T extends KonversiNilaiCreateArgs>(args: SelectSubset<T, KonversiNilaiCreateArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KonversiNilais.
     * @param {KonversiNilaiCreateManyArgs} args - Arguments to create many KonversiNilais.
     * @example
     * // Create many KonversiNilais
     * const konversiNilai = await prisma.konversiNilai.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KonversiNilaiCreateManyArgs>(args?: SelectSubset<T, KonversiNilaiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KonversiNilais and returns the data saved in the database.
     * @param {KonversiNilaiCreateManyAndReturnArgs} args - Arguments to create many KonversiNilais.
     * @example
     * // Create many KonversiNilais
     * const konversiNilai = await prisma.konversiNilai.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KonversiNilais and only return the `id_konversi_nilai`
     * const konversiNilaiWithId_konversi_nilaiOnly = await prisma.konversiNilai.createManyAndReturn({ 
     *   select: { id_konversi_nilai: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KonversiNilaiCreateManyAndReturnArgs>(args?: SelectSubset<T, KonversiNilaiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KonversiNilai.
     * @param {KonversiNilaiDeleteArgs} args - Arguments to delete one KonversiNilai.
     * @example
     * // Delete one KonversiNilai
     * const KonversiNilai = await prisma.konversiNilai.delete({
     *   where: {
     *     // ... filter to delete one KonversiNilai
     *   }
     * })
     * 
     */
    delete<T extends KonversiNilaiDeleteArgs>(args: SelectSubset<T, KonversiNilaiDeleteArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KonversiNilai.
     * @param {KonversiNilaiUpdateArgs} args - Arguments to update one KonversiNilai.
     * @example
     * // Update one KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KonversiNilaiUpdateArgs>(args: SelectSubset<T, KonversiNilaiUpdateArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KonversiNilais.
     * @param {KonversiNilaiDeleteManyArgs} args - Arguments to filter KonversiNilais to delete.
     * @example
     * // Delete a few KonversiNilais
     * const { count } = await prisma.konversiNilai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KonversiNilaiDeleteManyArgs>(args?: SelectSubset<T, KonversiNilaiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KonversiNilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KonversiNilais
     * const konversiNilai = await prisma.konversiNilai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KonversiNilaiUpdateManyArgs>(args: SelectSubset<T, KonversiNilaiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KonversiNilai.
     * @param {KonversiNilaiUpsertArgs} args - Arguments to update or create a KonversiNilai.
     * @example
     * // Update or create a KonversiNilai
     * const konversiNilai = await prisma.konversiNilai.upsert({
     *   create: {
     *     // ... data to create a KonversiNilai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KonversiNilai we want to update
     *   }
     * })
     */
    upsert<T extends KonversiNilaiUpsertArgs>(args: SelectSubset<T, KonversiNilaiUpsertArgs<ExtArgs>>): Prisma__KonversiNilaiClient<$Result.GetResult<Prisma.$KonversiNilaiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KonversiNilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiCountArgs} args - Arguments to filter KonversiNilais to count.
     * @example
     * // Count the number of KonversiNilais
     * const count = await prisma.konversiNilai.count({
     *   where: {
     *     // ... the filter for the KonversiNilais we want to count
     *   }
     * })
    **/
    count<T extends KonversiNilaiCountArgs>(
      args?: Subset<T, KonversiNilaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KonversiNilaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KonversiNilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KonversiNilaiAggregateArgs>(args: Subset<T, KonversiNilaiAggregateArgs>): Prisma.PrismaPromise<GetKonversiNilaiAggregateType<T>>

    /**
     * Group by KonversiNilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonversiNilaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KonversiNilaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KonversiNilaiGroupByArgs['orderBy'] }
        : { orderBy?: KonversiNilaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KonversiNilaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKonversiNilaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KonversiNilai model
   */
  readonly fields: KonversiNilaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KonversiNilai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KonversiNilaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AdminSiap<T extends AdminSiapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminSiapDefaultArgs<ExtArgs>>): Prisma__AdminSiapClient<$Result.GetResult<Prisma.$AdminSiapPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    BerkasPenilaian<T extends BerkasPenilaianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BerkasPenilaianDefaultArgs<ExtArgs>>): Prisma__BerkasPenilaianClient<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KonversiNilai model
   */ 
  interface KonversiNilaiFieldRefs {
    readonly id_konversi_nilai: FieldRef<"KonversiNilai", 'Int'>
    readonly NIP_admin_siap: FieldRef<"KonversiNilai", 'BigInt'>
    readonly id_berkas_penilaian: FieldRef<"KonversiNilai", 'Int'>
    readonly nilai_akhir: FieldRef<"KonversiNilai", 'Int'>
    readonly grade: FieldRef<"KonversiNilai", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KonversiNilai findUnique
   */
  export type KonversiNilaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter, which KonversiNilai to fetch.
     */
    where: KonversiNilaiWhereUniqueInput
  }

  /**
   * KonversiNilai findUniqueOrThrow
   */
  export type KonversiNilaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter, which KonversiNilai to fetch.
     */
    where: KonversiNilaiWhereUniqueInput
  }

  /**
   * KonversiNilai findFirst
   */
  export type KonversiNilaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter, which KonversiNilai to fetch.
     */
    where?: KonversiNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonversiNilais to fetch.
     */
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonversiNilais.
     */
    cursor?: KonversiNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonversiNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonversiNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonversiNilais.
     */
    distinct?: KonversiNilaiScalarFieldEnum | KonversiNilaiScalarFieldEnum[]
  }

  /**
   * KonversiNilai findFirstOrThrow
   */
  export type KonversiNilaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter, which KonversiNilai to fetch.
     */
    where?: KonversiNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonversiNilais to fetch.
     */
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonversiNilais.
     */
    cursor?: KonversiNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonversiNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonversiNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonversiNilais.
     */
    distinct?: KonversiNilaiScalarFieldEnum | KonversiNilaiScalarFieldEnum[]
  }

  /**
   * KonversiNilai findMany
   */
  export type KonversiNilaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter, which KonversiNilais to fetch.
     */
    where?: KonversiNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonversiNilais to fetch.
     */
    orderBy?: KonversiNilaiOrderByWithRelationInput | KonversiNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KonversiNilais.
     */
    cursor?: KonversiNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonversiNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonversiNilais.
     */
    skip?: number
    distinct?: KonversiNilaiScalarFieldEnum | KonversiNilaiScalarFieldEnum[]
  }

  /**
   * KonversiNilai create
   */
  export type KonversiNilaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * The data needed to create a KonversiNilai.
     */
    data: XOR<KonversiNilaiCreateInput, KonversiNilaiUncheckedCreateInput>
  }

  /**
   * KonversiNilai createMany
   */
  export type KonversiNilaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KonversiNilais.
     */
    data: KonversiNilaiCreateManyInput | KonversiNilaiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KonversiNilai createManyAndReturn
   */
  export type KonversiNilaiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KonversiNilais.
     */
    data: KonversiNilaiCreateManyInput | KonversiNilaiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KonversiNilai update
   */
  export type KonversiNilaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * The data needed to update a KonversiNilai.
     */
    data: XOR<KonversiNilaiUpdateInput, KonversiNilaiUncheckedUpdateInput>
    /**
     * Choose, which KonversiNilai to update.
     */
    where: KonversiNilaiWhereUniqueInput
  }

  /**
   * KonversiNilai updateMany
   */
  export type KonversiNilaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KonversiNilais.
     */
    data: XOR<KonversiNilaiUpdateManyMutationInput, KonversiNilaiUncheckedUpdateManyInput>
    /**
     * Filter which KonversiNilais to update
     */
    where?: KonversiNilaiWhereInput
  }

  /**
   * KonversiNilai upsert
   */
  export type KonversiNilaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * The filter to search for the KonversiNilai to update in case it exists.
     */
    where: KonversiNilaiWhereUniqueInput
    /**
     * In case the KonversiNilai found by the `where` argument doesn't exist, create a new KonversiNilai with this data.
     */
    create: XOR<KonversiNilaiCreateInput, KonversiNilaiUncheckedCreateInput>
    /**
     * In case the KonversiNilai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KonversiNilaiUpdateInput, KonversiNilaiUncheckedUpdateInput>
  }

  /**
   * KonversiNilai delete
   */
  export type KonversiNilaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
    /**
     * Filter which KonversiNilai to delete.
     */
    where: KonversiNilaiWhereUniqueInput
  }

  /**
   * KonversiNilai deleteMany
   */
  export type KonversiNilaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KonversiNilais to delete
     */
    where?: KonversiNilaiWhereInput
  }

  /**
   * KonversiNilai without action
   */
  export type KonversiNilaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KonversiNilai
     */
    select?: KonversiNilaiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KonversiNilaiInclude<ExtArgs> | null
  }


  /**
   * Model KoorMbkm
   */

  export type AggregateKoorMbkm = {
    _count: KoorMbkmCountAggregateOutputType | null
    _avg: KoorMbkmAvgAggregateOutputType | null
    _sum: KoorMbkmSumAggregateOutputType | null
    _min: KoorMbkmMinAggregateOutputType | null
    _max: KoorMbkmMaxAggregateOutputType | null
  }

  export type KoorMbkmAvgAggregateOutputType = {
    NIP_koor_mbkm: number | null
  }

  export type KoorMbkmSumAggregateOutputType = {
    NIP_koor_mbkm: bigint | null
  }

  export type KoorMbkmMinAggregateOutputType = {
    NIP_koor_mbkm: bigint | null
    nama_koor_mbkm: string | null
  }

  export type KoorMbkmMaxAggregateOutputType = {
    NIP_koor_mbkm: bigint | null
    nama_koor_mbkm: string | null
  }

  export type KoorMbkmCountAggregateOutputType = {
    NIP_koor_mbkm: number
    nama_koor_mbkm: number
    _all: number
  }


  export type KoorMbkmAvgAggregateInputType = {
    NIP_koor_mbkm?: true
  }

  export type KoorMbkmSumAggregateInputType = {
    NIP_koor_mbkm?: true
  }

  export type KoorMbkmMinAggregateInputType = {
    NIP_koor_mbkm?: true
    nama_koor_mbkm?: true
  }

  export type KoorMbkmMaxAggregateInputType = {
    NIP_koor_mbkm?: true
    nama_koor_mbkm?: true
  }

  export type KoorMbkmCountAggregateInputType = {
    NIP_koor_mbkm?: true
    nama_koor_mbkm?: true
    _all?: true
  }

  export type KoorMbkmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KoorMbkm to aggregate.
     */
    where?: KoorMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KoorMbkms to fetch.
     */
    orderBy?: KoorMbkmOrderByWithRelationInput | KoorMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KoorMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KoorMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KoorMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KoorMbkms
    **/
    _count?: true | KoorMbkmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KoorMbkmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KoorMbkmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KoorMbkmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KoorMbkmMaxAggregateInputType
  }

  export type GetKoorMbkmAggregateType<T extends KoorMbkmAggregateArgs> = {
        [P in keyof T & keyof AggregateKoorMbkm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKoorMbkm[P]>
      : GetScalarType<T[P], AggregateKoorMbkm[P]>
  }




  export type KoorMbkmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KoorMbkmWhereInput
    orderBy?: KoorMbkmOrderByWithAggregationInput | KoorMbkmOrderByWithAggregationInput[]
    by: KoorMbkmScalarFieldEnum[] | KoorMbkmScalarFieldEnum
    having?: KoorMbkmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KoorMbkmCountAggregateInputType | true
    _avg?: KoorMbkmAvgAggregateInputType
    _sum?: KoorMbkmSumAggregateInputType
    _min?: KoorMbkmMinAggregateInputType
    _max?: KoorMbkmMaxAggregateInputType
  }

  export type KoorMbkmGroupByOutputType = {
    NIP_koor_mbkm: bigint
    nama_koor_mbkm: string
    _count: KoorMbkmCountAggregateOutputType | null
    _avg: KoorMbkmAvgAggregateOutputType | null
    _sum: KoorMbkmSumAggregateOutputType | null
    _min: KoorMbkmMinAggregateOutputType | null
    _max: KoorMbkmMaxAggregateOutputType | null
  }

  type GetKoorMbkmGroupByPayload<T extends KoorMbkmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KoorMbkmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KoorMbkmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KoorMbkmGroupByOutputType[P]>
            : GetScalarType<T[P], KoorMbkmGroupByOutputType[P]>
        }
      >
    >


  export type KoorMbkmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_koor_mbkm?: boolean
    nama_koor_mbkm?: boolean
    PendaftaranAkun?: boolean | KoorMbkm$PendaftaranAkunArgs<ExtArgs>
    PendaftaranMbkm?: boolean | KoorMbkm$PendaftaranMbkmArgs<ExtArgs>
    Pengumuman?: boolean | KoorMbkm$PengumumanArgs<ExtArgs>
    _count?: boolean | KoorMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["koorMbkm"]>

  export type KoorMbkmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP_koor_mbkm?: boolean
    nama_koor_mbkm?: boolean
  }, ExtArgs["result"]["koorMbkm"]>

  export type KoorMbkmSelectScalar = {
    NIP_koor_mbkm?: boolean
    nama_koor_mbkm?: boolean
  }

  export type KoorMbkmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PendaftaranAkun?: boolean | KoorMbkm$PendaftaranAkunArgs<ExtArgs>
    PendaftaranMbkm?: boolean | KoorMbkm$PendaftaranMbkmArgs<ExtArgs>
    Pengumuman?: boolean | KoorMbkm$PengumumanArgs<ExtArgs>
    _count?: boolean | KoorMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KoorMbkmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KoorMbkmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KoorMbkm"
    objects: {
      PendaftaranAkun: Prisma.$PendaftaranAkunPayload<ExtArgs>[]
      PendaftaranMbkm: Prisma.$PendaftaranMbkmPayload<ExtArgs>[]
      Pengumuman: Prisma.$PengumumanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      NIP_koor_mbkm: bigint
      nama_koor_mbkm: string
    }, ExtArgs["result"]["koorMbkm"]>
    composites: {}
  }

  type KoorMbkmGetPayload<S extends boolean | null | undefined | KoorMbkmDefaultArgs> = $Result.GetResult<Prisma.$KoorMbkmPayload, S>

  type KoorMbkmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KoorMbkmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KoorMbkmCountAggregateInputType | true
    }

  export interface KoorMbkmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KoorMbkm'], meta: { name: 'KoorMbkm' } }
    /**
     * Find zero or one KoorMbkm that matches the filter.
     * @param {KoorMbkmFindUniqueArgs} args - Arguments to find a KoorMbkm
     * @example
     * // Get one KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KoorMbkmFindUniqueArgs>(args: SelectSubset<T, KoorMbkmFindUniqueArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KoorMbkm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KoorMbkmFindUniqueOrThrowArgs} args - Arguments to find a KoorMbkm
     * @example
     * // Get one KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KoorMbkmFindUniqueOrThrowArgs>(args: SelectSubset<T, KoorMbkmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KoorMbkm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmFindFirstArgs} args - Arguments to find a KoorMbkm
     * @example
     * // Get one KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KoorMbkmFindFirstArgs>(args?: SelectSubset<T, KoorMbkmFindFirstArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KoorMbkm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmFindFirstOrThrowArgs} args - Arguments to find a KoorMbkm
     * @example
     * // Get one KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KoorMbkmFindFirstOrThrowArgs>(args?: SelectSubset<T, KoorMbkmFindFirstOrThrowArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KoorMbkms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KoorMbkms
     * const koorMbkms = await prisma.koorMbkm.findMany()
     * 
     * // Get first 10 KoorMbkms
     * const koorMbkms = await prisma.koorMbkm.findMany({ take: 10 })
     * 
     * // Only select the `NIP_koor_mbkm`
     * const koorMbkmWithNIP_koor_mbkmOnly = await prisma.koorMbkm.findMany({ select: { NIP_koor_mbkm: true } })
     * 
     */
    findMany<T extends KoorMbkmFindManyArgs>(args?: SelectSubset<T, KoorMbkmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KoorMbkm.
     * @param {KoorMbkmCreateArgs} args - Arguments to create a KoorMbkm.
     * @example
     * // Create one KoorMbkm
     * const KoorMbkm = await prisma.koorMbkm.create({
     *   data: {
     *     // ... data to create a KoorMbkm
     *   }
     * })
     * 
     */
    create<T extends KoorMbkmCreateArgs>(args: SelectSubset<T, KoorMbkmCreateArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KoorMbkms.
     * @param {KoorMbkmCreateManyArgs} args - Arguments to create many KoorMbkms.
     * @example
     * // Create many KoorMbkms
     * const koorMbkm = await prisma.koorMbkm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KoorMbkmCreateManyArgs>(args?: SelectSubset<T, KoorMbkmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KoorMbkms and returns the data saved in the database.
     * @param {KoorMbkmCreateManyAndReturnArgs} args - Arguments to create many KoorMbkms.
     * @example
     * // Create many KoorMbkms
     * const koorMbkm = await prisma.koorMbkm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KoorMbkms and only return the `NIP_koor_mbkm`
     * const koorMbkmWithNIP_koor_mbkmOnly = await prisma.koorMbkm.createManyAndReturn({ 
     *   select: { NIP_koor_mbkm: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KoorMbkmCreateManyAndReturnArgs>(args?: SelectSubset<T, KoorMbkmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KoorMbkm.
     * @param {KoorMbkmDeleteArgs} args - Arguments to delete one KoorMbkm.
     * @example
     * // Delete one KoorMbkm
     * const KoorMbkm = await prisma.koorMbkm.delete({
     *   where: {
     *     // ... filter to delete one KoorMbkm
     *   }
     * })
     * 
     */
    delete<T extends KoorMbkmDeleteArgs>(args: SelectSubset<T, KoorMbkmDeleteArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KoorMbkm.
     * @param {KoorMbkmUpdateArgs} args - Arguments to update one KoorMbkm.
     * @example
     * // Update one KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KoorMbkmUpdateArgs>(args: SelectSubset<T, KoorMbkmUpdateArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KoorMbkms.
     * @param {KoorMbkmDeleteManyArgs} args - Arguments to filter KoorMbkms to delete.
     * @example
     * // Delete a few KoorMbkms
     * const { count } = await prisma.koorMbkm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KoorMbkmDeleteManyArgs>(args?: SelectSubset<T, KoorMbkmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KoorMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KoorMbkms
     * const koorMbkm = await prisma.koorMbkm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KoorMbkmUpdateManyArgs>(args: SelectSubset<T, KoorMbkmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KoorMbkm.
     * @param {KoorMbkmUpsertArgs} args - Arguments to update or create a KoorMbkm.
     * @example
     * // Update or create a KoorMbkm
     * const koorMbkm = await prisma.koorMbkm.upsert({
     *   create: {
     *     // ... data to create a KoorMbkm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KoorMbkm we want to update
     *   }
     * })
     */
    upsert<T extends KoorMbkmUpsertArgs>(args: SelectSubset<T, KoorMbkmUpsertArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KoorMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmCountArgs} args - Arguments to filter KoorMbkms to count.
     * @example
     * // Count the number of KoorMbkms
     * const count = await prisma.koorMbkm.count({
     *   where: {
     *     // ... the filter for the KoorMbkms we want to count
     *   }
     * })
    **/
    count<T extends KoorMbkmCountArgs>(
      args?: Subset<T, KoorMbkmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KoorMbkmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KoorMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KoorMbkmAggregateArgs>(args: Subset<T, KoorMbkmAggregateArgs>): Prisma.PrismaPromise<GetKoorMbkmAggregateType<T>>

    /**
     * Group by KoorMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KoorMbkmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KoorMbkmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KoorMbkmGroupByArgs['orderBy'] }
        : { orderBy?: KoorMbkmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KoorMbkmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKoorMbkmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KoorMbkm model
   */
  readonly fields: KoorMbkmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KoorMbkm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KoorMbkmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PendaftaranAkun<T extends KoorMbkm$PendaftaranAkunArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkm$PendaftaranAkunArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findMany"> | Null>
    PendaftaranMbkm<T extends KoorMbkm$PendaftaranMbkmArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkm$PendaftaranMbkmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findMany"> | Null>
    Pengumuman<T extends KoorMbkm$PengumumanArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkm$PengumumanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KoorMbkm model
   */ 
  interface KoorMbkmFieldRefs {
    readonly NIP_koor_mbkm: FieldRef<"KoorMbkm", 'BigInt'>
    readonly nama_koor_mbkm: FieldRef<"KoorMbkm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KoorMbkm findUnique
   */
  export type KoorMbkmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter, which KoorMbkm to fetch.
     */
    where: KoorMbkmWhereUniqueInput
  }

  /**
   * KoorMbkm findUniqueOrThrow
   */
  export type KoorMbkmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter, which KoorMbkm to fetch.
     */
    where: KoorMbkmWhereUniqueInput
  }

  /**
   * KoorMbkm findFirst
   */
  export type KoorMbkmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter, which KoorMbkm to fetch.
     */
    where?: KoorMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KoorMbkms to fetch.
     */
    orderBy?: KoorMbkmOrderByWithRelationInput | KoorMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KoorMbkms.
     */
    cursor?: KoorMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KoorMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KoorMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KoorMbkms.
     */
    distinct?: KoorMbkmScalarFieldEnum | KoorMbkmScalarFieldEnum[]
  }

  /**
   * KoorMbkm findFirstOrThrow
   */
  export type KoorMbkmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter, which KoorMbkm to fetch.
     */
    where?: KoorMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KoorMbkms to fetch.
     */
    orderBy?: KoorMbkmOrderByWithRelationInput | KoorMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KoorMbkms.
     */
    cursor?: KoorMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KoorMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KoorMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KoorMbkms.
     */
    distinct?: KoorMbkmScalarFieldEnum | KoorMbkmScalarFieldEnum[]
  }

  /**
   * KoorMbkm findMany
   */
  export type KoorMbkmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter, which KoorMbkms to fetch.
     */
    where?: KoorMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KoorMbkms to fetch.
     */
    orderBy?: KoorMbkmOrderByWithRelationInput | KoorMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KoorMbkms.
     */
    cursor?: KoorMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KoorMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KoorMbkms.
     */
    skip?: number
    distinct?: KoorMbkmScalarFieldEnum | KoorMbkmScalarFieldEnum[]
  }

  /**
   * KoorMbkm create
   */
  export type KoorMbkmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * The data needed to create a KoorMbkm.
     */
    data: XOR<KoorMbkmCreateInput, KoorMbkmUncheckedCreateInput>
  }

  /**
   * KoorMbkm createMany
   */
  export type KoorMbkmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KoorMbkms.
     */
    data: KoorMbkmCreateManyInput | KoorMbkmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KoorMbkm createManyAndReturn
   */
  export type KoorMbkmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KoorMbkms.
     */
    data: KoorMbkmCreateManyInput | KoorMbkmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KoorMbkm update
   */
  export type KoorMbkmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * The data needed to update a KoorMbkm.
     */
    data: XOR<KoorMbkmUpdateInput, KoorMbkmUncheckedUpdateInput>
    /**
     * Choose, which KoorMbkm to update.
     */
    where: KoorMbkmWhereUniqueInput
  }

  /**
   * KoorMbkm updateMany
   */
  export type KoorMbkmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KoorMbkms.
     */
    data: XOR<KoorMbkmUpdateManyMutationInput, KoorMbkmUncheckedUpdateManyInput>
    /**
     * Filter which KoorMbkms to update
     */
    where?: KoorMbkmWhereInput
  }

  /**
   * KoorMbkm upsert
   */
  export type KoorMbkmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * The filter to search for the KoorMbkm to update in case it exists.
     */
    where: KoorMbkmWhereUniqueInput
    /**
     * In case the KoorMbkm found by the `where` argument doesn't exist, create a new KoorMbkm with this data.
     */
    create: XOR<KoorMbkmCreateInput, KoorMbkmUncheckedCreateInput>
    /**
     * In case the KoorMbkm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KoorMbkmUpdateInput, KoorMbkmUncheckedUpdateInput>
  }

  /**
   * KoorMbkm delete
   */
  export type KoorMbkmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
    /**
     * Filter which KoorMbkm to delete.
     */
    where: KoorMbkmWhereUniqueInput
  }

  /**
   * KoorMbkm deleteMany
   */
  export type KoorMbkmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KoorMbkms to delete
     */
    where?: KoorMbkmWhereInput
  }

  /**
   * KoorMbkm.PendaftaranAkun
   */
  export type KoorMbkm$PendaftaranAkunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    where?: PendaftaranAkunWhereInput
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    cursor?: PendaftaranAkunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranAkunScalarFieldEnum | PendaftaranAkunScalarFieldEnum[]
  }

  /**
   * KoorMbkm.PendaftaranMbkm
   */
  export type KoorMbkm$PendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    where?: PendaftaranMbkmWhereInput
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    cursor?: PendaftaranMbkmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * KoorMbkm.Pengumuman
   */
  export type KoorMbkm$PengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    cursor?: PengumumanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * KoorMbkm without action
   */
  export type KoorMbkmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KoorMbkm
     */
    select?: KoorMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KoorMbkmInclude<ExtArgs> | null
  }


  /**
   * Model Mahasiswa
   */

  export type AggregateMahasiswa = {
    _count: MahasiswaCountAggregateOutputType | null
    _avg: MahasiswaAvgAggregateOutputType | null
    _sum: MahasiswaSumAggregateOutputType | null
    _min: MahasiswaMinAggregateOutputType | null
    _max: MahasiswaMaxAggregateOutputType | null
  }

  export type MahasiswaAvgAggregateOutputType = {
    NIM: number | null
    semester: number | null
    id_program_mbkm: number | null
    NIP_dosbing: number | null
  }

  export type MahasiswaSumAggregateOutputType = {
    NIM: bigint | null
    semester: number | null
    id_program_mbkm: number | null
    NIP_dosbing: bigint | null
  }

  export type MahasiswaMinAggregateOutputType = {
    NIM: bigint | null
    nama_mahasiswa: string | null
    semester: number | null
    id_program_mbkm: number | null
    NIP_dosbing: bigint | null
  }

  export type MahasiswaMaxAggregateOutputType = {
    NIM: bigint | null
    nama_mahasiswa: string | null
    semester: number | null
    id_program_mbkm: number | null
    NIP_dosbing: bigint | null
  }

  export type MahasiswaCountAggregateOutputType = {
    NIM: number
    nama_mahasiswa: number
    semester: number
    id_program_mbkm: number
    NIP_dosbing: number
    _all: number
  }


  export type MahasiswaAvgAggregateInputType = {
    NIM?: true
    semester?: true
    id_program_mbkm?: true
    NIP_dosbing?: true
  }

  export type MahasiswaSumAggregateInputType = {
    NIM?: true
    semester?: true
    id_program_mbkm?: true
    NIP_dosbing?: true
  }

  export type MahasiswaMinAggregateInputType = {
    NIM?: true
    nama_mahasiswa?: true
    semester?: true
    id_program_mbkm?: true
    NIP_dosbing?: true
  }

  export type MahasiswaMaxAggregateInputType = {
    NIM?: true
    nama_mahasiswa?: true
    semester?: true
    id_program_mbkm?: true
    NIP_dosbing?: true
  }

  export type MahasiswaCountAggregateInputType = {
    NIM?: true
    nama_mahasiswa?: true
    semester?: true
    id_program_mbkm?: true
    NIP_dosbing?: true
    _all?: true
  }

  export type MahasiswaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mahasiswa to aggregate.
     */
    where?: MahasiswaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahasiswas to fetch.
     */
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MahasiswaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahasiswas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahasiswas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mahasiswas
    **/
    _count?: true | MahasiswaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MahasiswaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MahasiswaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MahasiswaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MahasiswaMaxAggregateInputType
  }

  export type GetMahasiswaAggregateType<T extends MahasiswaAggregateArgs> = {
        [P in keyof T & keyof AggregateMahasiswa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMahasiswa[P]>
      : GetScalarType<T[P], AggregateMahasiswa[P]>
  }




  export type MahasiswaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MahasiswaWhereInput
    orderBy?: MahasiswaOrderByWithAggregationInput | MahasiswaOrderByWithAggregationInput[]
    by: MahasiswaScalarFieldEnum[] | MahasiswaScalarFieldEnum
    having?: MahasiswaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MahasiswaCountAggregateInputType | true
    _avg?: MahasiswaAvgAggregateInputType
    _sum?: MahasiswaSumAggregateInputType
    _min?: MahasiswaMinAggregateInputType
    _max?: MahasiswaMaxAggregateInputType
  }

  export type MahasiswaGroupByOutputType = {
    NIM: bigint
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    NIP_dosbing: bigint
    _count: MahasiswaCountAggregateOutputType | null
    _avg: MahasiswaAvgAggregateOutputType | null
    _sum: MahasiswaSumAggregateOutputType | null
    _min: MahasiswaMinAggregateOutputType | null
    _max: MahasiswaMaxAggregateOutputType | null
  }

  type GetMahasiswaGroupByPayload<T extends MahasiswaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MahasiswaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MahasiswaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MahasiswaGroupByOutputType[P]>
            : GetScalarType<T[P], MahasiswaGroupByOutputType[P]>
        }
      >
    >


  export type MahasiswaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIM?: boolean
    nama_mahasiswa?: boolean
    semester?: boolean
    id_program_mbkm?: boolean
    NIP_dosbing?: boolean
    ProgramMbkm?: boolean | ProgramMbkmDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    PendaftaranMbkm?: boolean | Mahasiswa$PendaftaranMbkmArgs<ExtArgs>
    PendaftaranAkun?: boolean | Mahasiswa$PendaftaranAkunArgs<ExtArgs>
    _count?: boolean | MahasiswaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mahasiswa"]>

  export type MahasiswaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIM?: boolean
    nama_mahasiswa?: boolean
    semester?: boolean
    id_program_mbkm?: boolean
    NIP_dosbing?: boolean
    ProgramMbkm?: boolean | ProgramMbkmDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mahasiswa"]>

  export type MahasiswaSelectScalar = {
    NIM?: boolean
    nama_mahasiswa?: boolean
    semester?: boolean
    id_program_mbkm?: boolean
    NIP_dosbing?: boolean
  }

  export type MahasiswaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProgramMbkm?: boolean | ProgramMbkmDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    PendaftaranMbkm?: boolean | Mahasiswa$PendaftaranMbkmArgs<ExtArgs>
    PendaftaranAkun?: boolean | Mahasiswa$PendaftaranAkunArgs<ExtArgs>
    _count?: boolean | MahasiswaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MahasiswaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProgramMbkm?: boolean | ProgramMbkmDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
  }

  export type $MahasiswaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mahasiswa"
    objects: {
      ProgramMbkm: Prisma.$ProgramMbkmPayload<ExtArgs>
      Dosbing: Prisma.$DosbingPayload<ExtArgs>
      PendaftaranMbkm: Prisma.$PendaftaranMbkmPayload<ExtArgs>[]
      PendaftaranAkun: Prisma.$PendaftaranAkunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      NIM: bigint
      nama_mahasiswa: string
      semester: number
      id_program_mbkm: number
      NIP_dosbing: bigint
    }, ExtArgs["result"]["mahasiswa"]>
    composites: {}
  }

  type MahasiswaGetPayload<S extends boolean | null | undefined | MahasiswaDefaultArgs> = $Result.GetResult<Prisma.$MahasiswaPayload, S>

  type MahasiswaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MahasiswaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MahasiswaCountAggregateInputType | true
    }

  export interface MahasiswaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mahasiswa'], meta: { name: 'Mahasiswa' } }
    /**
     * Find zero or one Mahasiswa that matches the filter.
     * @param {MahasiswaFindUniqueArgs} args - Arguments to find a Mahasiswa
     * @example
     * // Get one Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MahasiswaFindUniqueArgs>(args: SelectSubset<T, MahasiswaFindUniqueArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mahasiswa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MahasiswaFindUniqueOrThrowArgs} args - Arguments to find a Mahasiswa
     * @example
     * // Get one Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MahasiswaFindUniqueOrThrowArgs>(args: SelectSubset<T, MahasiswaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mahasiswa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaFindFirstArgs} args - Arguments to find a Mahasiswa
     * @example
     * // Get one Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MahasiswaFindFirstArgs>(args?: SelectSubset<T, MahasiswaFindFirstArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mahasiswa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaFindFirstOrThrowArgs} args - Arguments to find a Mahasiswa
     * @example
     * // Get one Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MahasiswaFindFirstOrThrowArgs>(args?: SelectSubset<T, MahasiswaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mahasiswas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mahasiswas
     * const mahasiswas = await prisma.mahasiswa.findMany()
     * 
     * // Get first 10 Mahasiswas
     * const mahasiswas = await prisma.mahasiswa.findMany({ take: 10 })
     * 
     * // Only select the `NIM`
     * const mahasiswaWithNIMOnly = await prisma.mahasiswa.findMany({ select: { NIM: true } })
     * 
     */
    findMany<T extends MahasiswaFindManyArgs>(args?: SelectSubset<T, MahasiswaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mahasiswa.
     * @param {MahasiswaCreateArgs} args - Arguments to create a Mahasiswa.
     * @example
     * // Create one Mahasiswa
     * const Mahasiswa = await prisma.mahasiswa.create({
     *   data: {
     *     // ... data to create a Mahasiswa
     *   }
     * })
     * 
     */
    create<T extends MahasiswaCreateArgs>(args: SelectSubset<T, MahasiswaCreateArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mahasiswas.
     * @param {MahasiswaCreateManyArgs} args - Arguments to create many Mahasiswas.
     * @example
     * // Create many Mahasiswas
     * const mahasiswa = await prisma.mahasiswa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MahasiswaCreateManyArgs>(args?: SelectSubset<T, MahasiswaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mahasiswas and returns the data saved in the database.
     * @param {MahasiswaCreateManyAndReturnArgs} args - Arguments to create many Mahasiswas.
     * @example
     * // Create many Mahasiswas
     * const mahasiswa = await prisma.mahasiswa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mahasiswas and only return the `NIM`
     * const mahasiswaWithNIMOnly = await prisma.mahasiswa.createManyAndReturn({ 
     *   select: { NIM: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MahasiswaCreateManyAndReturnArgs>(args?: SelectSubset<T, MahasiswaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mahasiswa.
     * @param {MahasiswaDeleteArgs} args - Arguments to delete one Mahasiswa.
     * @example
     * // Delete one Mahasiswa
     * const Mahasiswa = await prisma.mahasiswa.delete({
     *   where: {
     *     // ... filter to delete one Mahasiswa
     *   }
     * })
     * 
     */
    delete<T extends MahasiswaDeleteArgs>(args: SelectSubset<T, MahasiswaDeleteArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mahasiswa.
     * @param {MahasiswaUpdateArgs} args - Arguments to update one Mahasiswa.
     * @example
     * // Update one Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MahasiswaUpdateArgs>(args: SelectSubset<T, MahasiswaUpdateArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mahasiswas.
     * @param {MahasiswaDeleteManyArgs} args - Arguments to filter Mahasiswas to delete.
     * @example
     * // Delete a few Mahasiswas
     * const { count } = await prisma.mahasiswa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MahasiswaDeleteManyArgs>(args?: SelectSubset<T, MahasiswaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mahasiswas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mahasiswas
     * const mahasiswa = await prisma.mahasiswa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MahasiswaUpdateManyArgs>(args: SelectSubset<T, MahasiswaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mahasiswa.
     * @param {MahasiswaUpsertArgs} args - Arguments to update or create a Mahasiswa.
     * @example
     * // Update or create a Mahasiswa
     * const mahasiswa = await prisma.mahasiswa.upsert({
     *   create: {
     *     // ... data to create a Mahasiswa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mahasiswa we want to update
     *   }
     * })
     */
    upsert<T extends MahasiswaUpsertArgs>(args: SelectSubset<T, MahasiswaUpsertArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mahasiswas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaCountArgs} args - Arguments to filter Mahasiswas to count.
     * @example
     * // Count the number of Mahasiswas
     * const count = await prisma.mahasiswa.count({
     *   where: {
     *     // ... the filter for the Mahasiswas we want to count
     *   }
     * })
    **/
    count<T extends MahasiswaCountArgs>(
      args?: Subset<T, MahasiswaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MahasiswaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mahasiswa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MahasiswaAggregateArgs>(args: Subset<T, MahasiswaAggregateArgs>): Prisma.PrismaPromise<GetMahasiswaAggregateType<T>>

    /**
     * Group by Mahasiswa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MahasiswaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MahasiswaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MahasiswaGroupByArgs['orderBy'] }
        : { orderBy?: MahasiswaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MahasiswaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMahasiswaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mahasiswa model
   */
  readonly fields: MahasiswaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mahasiswa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MahasiswaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProgramMbkm<T extends ProgramMbkmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramMbkmDefaultArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Dosbing<T extends DosbingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DosbingDefaultArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PendaftaranMbkm<T extends Mahasiswa$PendaftaranMbkmArgs<ExtArgs> = {}>(args?: Subset<T, Mahasiswa$PendaftaranMbkmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findMany"> | Null>
    PendaftaranAkun<T extends Mahasiswa$PendaftaranAkunArgs<ExtArgs> = {}>(args?: Subset<T, Mahasiswa$PendaftaranAkunArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mahasiswa model
   */ 
  interface MahasiswaFieldRefs {
    readonly NIM: FieldRef<"Mahasiswa", 'BigInt'>
    readonly nama_mahasiswa: FieldRef<"Mahasiswa", 'String'>
    readonly semester: FieldRef<"Mahasiswa", 'Int'>
    readonly id_program_mbkm: FieldRef<"Mahasiswa", 'Int'>
    readonly NIP_dosbing: FieldRef<"Mahasiswa", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Mahasiswa findUnique
   */
  export type MahasiswaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter, which Mahasiswa to fetch.
     */
    where: MahasiswaWhereUniqueInput
  }

  /**
   * Mahasiswa findUniqueOrThrow
   */
  export type MahasiswaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter, which Mahasiswa to fetch.
     */
    where: MahasiswaWhereUniqueInput
  }

  /**
   * Mahasiswa findFirst
   */
  export type MahasiswaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter, which Mahasiswa to fetch.
     */
    where?: MahasiswaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahasiswas to fetch.
     */
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahasiswas.
     */
    cursor?: MahasiswaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahasiswas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahasiswas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahasiswas.
     */
    distinct?: MahasiswaScalarFieldEnum | MahasiswaScalarFieldEnum[]
  }

  /**
   * Mahasiswa findFirstOrThrow
   */
  export type MahasiswaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter, which Mahasiswa to fetch.
     */
    where?: MahasiswaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahasiswas to fetch.
     */
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mahasiswas.
     */
    cursor?: MahasiswaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahasiswas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahasiswas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mahasiswas.
     */
    distinct?: MahasiswaScalarFieldEnum | MahasiswaScalarFieldEnum[]
  }

  /**
   * Mahasiswa findMany
   */
  export type MahasiswaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter, which Mahasiswas to fetch.
     */
    where?: MahasiswaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mahasiswas to fetch.
     */
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mahasiswas.
     */
    cursor?: MahasiswaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mahasiswas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mahasiswas.
     */
    skip?: number
    distinct?: MahasiswaScalarFieldEnum | MahasiswaScalarFieldEnum[]
  }

  /**
   * Mahasiswa create
   */
  export type MahasiswaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * The data needed to create a Mahasiswa.
     */
    data: XOR<MahasiswaCreateInput, MahasiswaUncheckedCreateInput>
  }

  /**
   * Mahasiswa createMany
   */
  export type MahasiswaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mahasiswas.
     */
    data: MahasiswaCreateManyInput | MahasiswaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mahasiswa createManyAndReturn
   */
  export type MahasiswaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mahasiswas.
     */
    data: MahasiswaCreateManyInput | MahasiswaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mahasiswa update
   */
  export type MahasiswaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * The data needed to update a Mahasiswa.
     */
    data: XOR<MahasiswaUpdateInput, MahasiswaUncheckedUpdateInput>
    /**
     * Choose, which Mahasiswa to update.
     */
    where: MahasiswaWhereUniqueInput
  }

  /**
   * Mahasiswa updateMany
   */
  export type MahasiswaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mahasiswas.
     */
    data: XOR<MahasiswaUpdateManyMutationInput, MahasiswaUncheckedUpdateManyInput>
    /**
     * Filter which Mahasiswas to update
     */
    where?: MahasiswaWhereInput
  }

  /**
   * Mahasiswa upsert
   */
  export type MahasiswaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * The filter to search for the Mahasiswa to update in case it exists.
     */
    where: MahasiswaWhereUniqueInput
    /**
     * In case the Mahasiswa found by the `where` argument doesn't exist, create a new Mahasiswa with this data.
     */
    create: XOR<MahasiswaCreateInput, MahasiswaUncheckedCreateInput>
    /**
     * In case the Mahasiswa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MahasiswaUpdateInput, MahasiswaUncheckedUpdateInput>
  }

  /**
   * Mahasiswa delete
   */
  export type MahasiswaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    /**
     * Filter which Mahasiswa to delete.
     */
    where: MahasiswaWhereUniqueInput
  }

  /**
   * Mahasiswa deleteMany
   */
  export type MahasiswaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mahasiswas to delete
     */
    where?: MahasiswaWhereInput
  }

  /**
   * Mahasiswa.PendaftaranMbkm
   */
  export type Mahasiswa$PendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    where?: PendaftaranMbkmWhereInput
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    cursor?: PendaftaranMbkmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * Mahasiswa.PendaftaranAkun
   */
  export type Mahasiswa$PendaftaranAkunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    where?: PendaftaranAkunWhereInput
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    cursor?: PendaftaranAkunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranAkunScalarFieldEnum | PendaftaranAkunScalarFieldEnum[]
  }

  /**
   * Mahasiswa without action
   */
  export type MahasiswaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
  }


  /**
   * Model PendaftaranAkun
   */

  export type AggregatePendaftaranAkun = {
    _count: PendaftaranAkunCountAggregateOutputType | null
    _avg: PendaftaranAkunAvgAggregateOutputType | null
    _sum: PendaftaranAkunSumAggregateOutputType | null
    _min: PendaftaranAkunMinAggregateOutputType | null
    _max: PendaftaranAkunMaxAggregateOutputType | null
  }

  export type PendaftaranAkunAvgAggregateOutputType = {
    id_pendaftaran_akun: number | null
    NIM: number | null
    NIP_koor_mbkm: number | null
  }

  export type PendaftaranAkunSumAggregateOutputType = {
    id_pendaftaran_akun: number | null
    NIM: bigint | null
    NIP_koor_mbkm: bigint | null
  }

  export type PendaftaranAkunMinAggregateOutputType = {
    id_pendaftaran_akun: number | null
    NIM: bigint | null
    NIP_koor_mbkm: bigint | null
    tanggal: Date | null
  }

  export type PendaftaranAkunMaxAggregateOutputType = {
    id_pendaftaran_akun: number | null
    NIM: bigint | null
    NIP_koor_mbkm: bigint | null
    tanggal: Date | null
  }

  export type PendaftaranAkunCountAggregateOutputType = {
    id_pendaftaran_akun: number
    NIM: number
    NIP_koor_mbkm: number
    tanggal: number
    _all: number
  }


  export type PendaftaranAkunAvgAggregateInputType = {
    id_pendaftaran_akun?: true
    NIM?: true
    NIP_koor_mbkm?: true
  }

  export type PendaftaranAkunSumAggregateInputType = {
    id_pendaftaran_akun?: true
    NIM?: true
    NIP_koor_mbkm?: true
  }

  export type PendaftaranAkunMinAggregateInputType = {
    id_pendaftaran_akun?: true
    NIM?: true
    NIP_koor_mbkm?: true
    tanggal?: true
  }

  export type PendaftaranAkunMaxAggregateInputType = {
    id_pendaftaran_akun?: true
    NIM?: true
    NIP_koor_mbkm?: true
    tanggal?: true
  }

  export type PendaftaranAkunCountAggregateInputType = {
    id_pendaftaran_akun?: true
    NIM?: true
    NIP_koor_mbkm?: true
    tanggal?: true
    _all?: true
  }

  export type PendaftaranAkunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendaftaranAkun to aggregate.
     */
    where?: PendaftaranAkunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranAkuns to fetch.
     */
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendaftaranAkunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranAkuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranAkuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendaftaranAkuns
    **/
    _count?: true | PendaftaranAkunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendaftaranAkunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendaftaranAkunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendaftaranAkunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendaftaranAkunMaxAggregateInputType
  }

  export type GetPendaftaranAkunAggregateType<T extends PendaftaranAkunAggregateArgs> = {
        [P in keyof T & keyof AggregatePendaftaranAkun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendaftaranAkun[P]>
      : GetScalarType<T[P], AggregatePendaftaranAkun[P]>
  }




  export type PendaftaranAkunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranAkunWhereInput
    orderBy?: PendaftaranAkunOrderByWithAggregationInput | PendaftaranAkunOrderByWithAggregationInput[]
    by: PendaftaranAkunScalarFieldEnum[] | PendaftaranAkunScalarFieldEnum
    having?: PendaftaranAkunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendaftaranAkunCountAggregateInputType | true
    _avg?: PendaftaranAkunAvgAggregateInputType
    _sum?: PendaftaranAkunSumAggregateInputType
    _min?: PendaftaranAkunMinAggregateInputType
    _max?: PendaftaranAkunMaxAggregateInputType
  }

  export type PendaftaranAkunGroupByOutputType = {
    id_pendaftaran_akun: number
    NIM: bigint
    NIP_koor_mbkm: bigint
    tanggal: Date
    _count: PendaftaranAkunCountAggregateOutputType | null
    _avg: PendaftaranAkunAvgAggregateOutputType | null
    _sum: PendaftaranAkunSumAggregateOutputType | null
    _min: PendaftaranAkunMinAggregateOutputType | null
    _max: PendaftaranAkunMaxAggregateOutputType | null
  }

  type GetPendaftaranAkunGroupByPayload<T extends PendaftaranAkunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendaftaranAkunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendaftaranAkunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendaftaranAkunGroupByOutputType[P]>
            : GetScalarType<T[P], PendaftaranAkunGroupByOutputType[P]>
        }
      >
    >


  export type PendaftaranAkunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran_akun?: boolean
    NIM?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendaftaranAkun"]>

  export type PendaftaranAkunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran_akun?: boolean
    NIM?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendaftaranAkun"]>

  export type PendaftaranAkunSelectScalar = {
    id_pendaftaran_akun?: boolean
    NIM?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
  }

  export type PendaftaranAkunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }
  export type PendaftaranAkunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }

  export type $PendaftaranAkunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendaftaranAkun"
    objects: {
      Mahasiswa: Prisma.$MahasiswaPayload<ExtArgs>
      KoorMbkm: Prisma.$KoorMbkmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pendaftaran_akun: number
      NIM: bigint
      NIP_koor_mbkm: bigint
      tanggal: Date
    }, ExtArgs["result"]["pendaftaranAkun"]>
    composites: {}
  }

  type PendaftaranAkunGetPayload<S extends boolean | null | undefined | PendaftaranAkunDefaultArgs> = $Result.GetResult<Prisma.$PendaftaranAkunPayload, S>

  type PendaftaranAkunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendaftaranAkunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PendaftaranAkunCountAggregateInputType | true
    }

  export interface PendaftaranAkunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendaftaranAkun'], meta: { name: 'PendaftaranAkun' } }
    /**
     * Find zero or one PendaftaranAkun that matches the filter.
     * @param {PendaftaranAkunFindUniqueArgs} args - Arguments to find a PendaftaranAkun
     * @example
     * // Get one PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendaftaranAkunFindUniqueArgs>(args: SelectSubset<T, PendaftaranAkunFindUniqueArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PendaftaranAkun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PendaftaranAkunFindUniqueOrThrowArgs} args - Arguments to find a PendaftaranAkun
     * @example
     * // Get one PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendaftaranAkunFindUniqueOrThrowArgs>(args: SelectSubset<T, PendaftaranAkunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PendaftaranAkun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunFindFirstArgs} args - Arguments to find a PendaftaranAkun
     * @example
     * // Get one PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendaftaranAkunFindFirstArgs>(args?: SelectSubset<T, PendaftaranAkunFindFirstArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PendaftaranAkun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunFindFirstOrThrowArgs} args - Arguments to find a PendaftaranAkun
     * @example
     * // Get one PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendaftaranAkunFindFirstOrThrowArgs>(args?: SelectSubset<T, PendaftaranAkunFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PendaftaranAkuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendaftaranAkuns
     * const pendaftaranAkuns = await prisma.pendaftaranAkun.findMany()
     * 
     * // Get first 10 PendaftaranAkuns
     * const pendaftaranAkuns = await prisma.pendaftaranAkun.findMany({ take: 10 })
     * 
     * // Only select the `id_pendaftaran_akun`
     * const pendaftaranAkunWithId_pendaftaran_akunOnly = await prisma.pendaftaranAkun.findMany({ select: { id_pendaftaran_akun: true } })
     * 
     */
    findMany<T extends PendaftaranAkunFindManyArgs>(args?: SelectSubset<T, PendaftaranAkunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PendaftaranAkun.
     * @param {PendaftaranAkunCreateArgs} args - Arguments to create a PendaftaranAkun.
     * @example
     * // Create one PendaftaranAkun
     * const PendaftaranAkun = await prisma.pendaftaranAkun.create({
     *   data: {
     *     // ... data to create a PendaftaranAkun
     *   }
     * })
     * 
     */
    create<T extends PendaftaranAkunCreateArgs>(args: SelectSubset<T, PendaftaranAkunCreateArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PendaftaranAkuns.
     * @param {PendaftaranAkunCreateManyArgs} args - Arguments to create many PendaftaranAkuns.
     * @example
     * // Create many PendaftaranAkuns
     * const pendaftaranAkun = await prisma.pendaftaranAkun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendaftaranAkunCreateManyArgs>(args?: SelectSubset<T, PendaftaranAkunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendaftaranAkuns and returns the data saved in the database.
     * @param {PendaftaranAkunCreateManyAndReturnArgs} args - Arguments to create many PendaftaranAkuns.
     * @example
     * // Create many PendaftaranAkuns
     * const pendaftaranAkun = await prisma.pendaftaranAkun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendaftaranAkuns and only return the `id_pendaftaran_akun`
     * const pendaftaranAkunWithId_pendaftaran_akunOnly = await prisma.pendaftaranAkun.createManyAndReturn({ 
     *   select: { id_pendaftaran_akun: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendaftaranAkunCreateManyAndReturnArgs>(args?: SelectSubset<T, PendaftaranAkunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PendaftaranAkun.
     * @param {PendaftaranAkunDeleteArgs} args - Arguments to delete one PendaftaranAkun.
     * @example
     * // Delete one PendaftaranAkun
     * const PendaftaranAkun = await prisma.pendaftaranAkun.delete({
     *   where: {
     *     // ... filter to delete one PendaftaranAkun
     *   }
     * })
     * 
     */
    delete<T extends PendaftaranAkunDeleteArgs>(args: SelectSubset<T, PendaftaranAkunDeleteArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PendaftaranAkun.
     * @param {PendaftaranAkunUpdateArgs} args - Arguments to update one PendaftaranAkun.
     * @example
     * // Update one PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendaftaranAkunUpdateArgs>(args: SelectSubset<T, PendaftaranAkunUpdateArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PendaftaranAkuns.
     * @param {PendaftaranAkunDeleteManyArgs} args - Arguments to filter PendaftaranAkuns to delete.
     * @example
     * // Delete a few PendaftaranAkuns
     * const { count } = await prisma.pendaftaranAkun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendaftaranAkunDeleteManyArgs>(args?: SelectSubset<T, PendaftaranAkunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendaftaranAkuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendaftaranAkuns
     * const pendaftaranAkun = await prisma.pendaftaranAkun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendaftaranAkunUpdateManyArgs>(args: SelectSubset<T, PendaftaranAkunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendaftaranAkun.
     * @param {PendaftaranAkunUpsertArgs} args - Arguments to update or create a PendaftaranAkun.
     * @example
     * // Update or create a PendaftaranAkun
     * const pendaftaranAkun = await prisma.pendaftaranAkun.upsert({
     *   create: {
     *     // ... data to create a PendaftaranAkun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendaftaranAkun we want to update
     *   }
     * })
     */
    upsert<T extends PendaftaranAkunUpsertArgs>(args: SelectSubset<T, PendaftaranAkunUpsertArgs<ExtArgs>>): Prisma__PendaftaranAkunClient<$Result.GetResult<Prisma.$PendaftaranAkunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PendaftaranAkuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunCountArgs} args - Arguments to filter PendaftaranAkuns to count.
     * @example
     * // Count the number of PendaftaranAkuns
     * const count = await prisma.pendaftaranAkun.count({
     *   where: {
     *     // ... the filter for the PendaftaranAkuns we want to count
     *   }
     * })
    **/
    count<T extends PendaftaranAkunCountArgs>(
      args?: Subset<T, PendaftaranAkunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendaftaranAkunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendaftaranAkun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendaftaranAkunAggregateArgs>(args: Subset<T, PendaftaranAkunAggregateArgs>): Prisma.PrismaPromise<GetPendaftaranAkunAggregateType<T>>

    /**
     * Group by PendaftaranAkun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAkunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendaftaranAkunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendaftaranAkunGroupByArgs['orderBy'] }
        : { orderBy?: PendaftaranAkunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendaftaranAkunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendaftaranAkunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendaftaranAkun model
   */
  readonly fields: PendaftaranAkunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendaftaranAkun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendaftaranAkunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Mahasiswa<T extends MahasiswaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MahasiswaDefaultArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    KoorMbkm<T extends KoorMbkmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkmDefaultArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendaftaranAkun model
   */ 
  interface PendaftaranAkunFieldRefs {
    readonly id_pendaftaran_akun: FieldRef<"PendaftaranAkun", 'Int'>
    readonly NIM: FieldRef<"PendaftaranAkun", 'BigInt'>
    readonly NIP_koor_mbkm: FieldRef<"PendaftaranAkun", 'BigInt'>
    readonly tanggal: FieldRef<"PendaftaranAkun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendaftaranAkun findUnique
   */
  export type PendaftaranAkunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranAkun to fetch.
     */
    where: PendaftaranAkunWhereUniqueInput
  }

  /**
   * PendaftaranAkun findUniqueOrThrow
   */
  export type PendaftaranAkunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranAkun to fetch.
     */
    where: PendaftaranAkunWhereUniqueInput
  }

  /**
   * PendaftaranAkun findFirst
   */
  export type PendaftaranAkunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranAkun to fetch.
     */
    where?: PendaftaranAkunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranAkuns to fetch.
     */
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendaftaranAkuns.
     */
    cursor?: PendaftaranAkunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranAkuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranAkuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendaftaranAkuns.
     */
    distinct?: PendaftaranAkunScalarFieldEnum | PendaftaranAkunScalarFieldEnum[]
  }

  /**
   * PendaftaranAkun findFirstOrThrow
   */
  export type PendaftaranAkunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranAkun to fetch.
     */
    where?: PendaftaranAkunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranAkuns to fetch.
     */
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendaftaranAkuns.
     */
    cursor?: PendaftaranAkunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranAkuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranAkuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendaftaranAkuns.
     */
    distinct?: PendaftaranAkunScalarFieldEnum | PendaftaranAkunScalarFieldEnum[]
  }

  /**
   * PendaftaranAkun findMany
   */
  export type PendaftaranAkunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranAkuns to fetch.
     */
    where?: PendaftaranAkunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranAkuns to fetch.
     */
    orderBy?: PendaftaranAkunOrderByWithRelationInput | PendaftaranAkunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendaftaranAkuns.
     */
    cursor?: PendaftaranAkunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranAkuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranAkuns.
     */
    skip?: number
    distinct?: PendaftaranAkunScalarFieldEnum | PendaftaranAkunScalarFieldEnum[]
  }

  /**
   * PendaftaranAkun create
   */
  export type PendaftaranAkunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * The data needed to create a PendaftaranAkun.
     */
    data: XOR<PendaftaranAkunCreateInput, PendaftaranAkunUncheckedCreateInput>
  }

  /**
   * PendaftaranAkun createMany
   */
  export type PendaftaranAkunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendaftaranAkuns.
     */
    data: PendaftaranAkunCreateManyInput | PendaftaranAkunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendaftaranAkun createManyAndReturn
   */
  export type PendaftaranAkunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PendaftaranAkuns.
     */
    data: PendaftaranAkunCreateManyInput | PendaftaranAkunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendaftaranAkun update
   */
  export type PendaftaranAkunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * The data needed to update a PendaftaranAkun.
     */
    data: XOR<PendaftaranAkunUpdateInput, PendaftaranAkunUncheckedUpdateInput>
    /**
     * Choose, which PendaftaranAkun to update.
     */
    where: PendaftaranAkunWhereUniqueInput
  }

  /**
   * PendaftaranAkun updateMany
   */
  export type PendaftaranAkunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendaftaranAkuns.
     */
    data: XOR<PendaftaranAkunUpdateManyMutationInput, PendaftaranAkunUncheckedUpdateManyInput>
    /**
     * Filter which PendaftaranAkuns to update
     */
    where?: PendaftaranAkunWhereInput
  }

  /**
   * PendaftaranAkun upsert
   */
  export type PendaftaranAkunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * The filter to search for the PendaftaranAkun to update in case it exists.
     */
    where: PendaftaranAkunWhereUniqueInput
    /**
     * In case the PendaftaranAkun found by the `where` argument doesn't exist, create a new PendaftaranAkun with this data.
     */
    create: XOR<PendaftaranAkunCreateInput, PendaftaranAkunUncheckedCreateInput>
    /**
     * In case the PendaftaranAkun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendaftaranAkunUpdateInput, PendaftaranAkunUncheckedUpdateInput>
  }

  /**
   * PendaftaranAkun delete
   */
  export type PendaftaranAkunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
    /**
     * Filter which PendaftaranAkun to delete.
     */
    where: PendaftaranAkunWhereUniqueInput
  }

  /**
   * PendaftaranAkun deleteMany
   */
  export type PendaftaranAkunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendaftaranAkuns to delete
     */
    where?: PendaftaranAkunWhereInput
  }

  /**
   * PendaftaranAkun without action
   */
  export type PendaftaranAkunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranAkun
     */
    select?: PendaftaranAkunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranAkunInclude<ExtArgs> | null
  }


  /**
   * Model PendaftaranMbkm
   */

  export type AggregatePendaftaranMbkm = {
    _count: PendaftaranMbkmCountAggregateOutputType | null
    _avg: PendaftaranMbkmAvgAggregateOutputType | null
    _sum: PendaftaranMbkmSumAggregateOutputType | null
    _min: PendaftaranMbkmMinAggregateOutputType | null
    _max: PendaftaranMbkmMaxAggregateOutputType | null
  }

  export type PendaftaranMbkmAvgAggregateOutputType = {
    id_pendaftaran_mbkm: number | null
    NIM: number | null
    NIP_dosbing: number | null
    NIP_koor_mbkm: number | null
  }

  export type PendaftaranMbkmSumAggregateOutputType = {
    id_pendaftaran_mbkm: number | null
    NIM: bigint | null
    NIP_dosbing: bigint | null
    NIP_koor_mbkm: bigint | null
  }

  export type PendaftaranMbkmMinAggregateOutputType = {
    id_pendaftaran_mbkm: number | null
    NIM: bigint | null
    NIP_dosbing: bigint | null
    NIP_koor_mbkm: bigint | null
    tanggal: Date | null
  }

  export type PendaftaranMbkmMaxAggregateOutputType = {
    id_pendaftaran_mbkm: number | null
    NIM: bigint | null
    NIP_dosbing: bigint | null
    NIP_koor_mbkm: bigint | null
    tanggal: Date | null
  }

  export type PendaftaranMbkmCountAggregateOutputType = {
    id_pendaftaran_mbkm: number
    NIM: number
    NIP_dosbing: number
    NIP_koor_mbkm: number
    tanggal: number
    _all: number
  }


  export type PendaftaranMbkmAvgAggregateInputType = {
    id_pendaftaran_mbkm?: true
    NIM?: true
    NIP_dosbing?: true
    NIP_koor_mbkm?: true
  }

  export type PendaftaranMbkmSumAggregateInputType = {
    id_pendaftaran_mbkm?: true
    NIM?: true
    NIP_dosbing?: true
    NIP_koor_mbkm?: true
  }

  export type PendaftaranMbkmMinAggregateInputType = {
    id_pendaftaran_mbkm?: true
    NIM?: true
    NIP_dosbing?: true
    NIP_koor_mbkm?: true
    tanggal?: true
  }

  export type PendaftaranMbkmMaxAggregateInputType = {
    id_pendaftaran_mbkm?: true
    NIM?: true
    NIP_dosbing?: true
    NIP_koor_mbkm?: true
    tanggal?: true
  }

  export type PendaftaranMbkmCountAggregateInputType = {
    id_pendaftaran_mbkm?: true
    NIM?: true
    NIP_dosbing?: true
    NIP_koor_mbkm?: true
    tanggal?: true
    _all?: true
  }

  export type PendaftaranMbkmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendaftaranMbkm to aggregate.
     */
    where?: PendaftaranMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranMbkms to fetch.
     */
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendaftaranMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendaftaranMbkms
    **/
    _count?: true | PendaftaranMbkmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendaftaranMbkmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendaftaranMbkmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendaftaranMbkmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendaftaranMbkmMaxAggregateInputType
  }

  export type GetPendaftaranMbkmAggregateType<T extends PendaftaranMbkmAggregateArgs> = {
        [P in keyof T & keyof AggregatePendaftaranMbkm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendaftaranMbkm[P]>
      : GetScalarType<T[P], AggregatePendaftaranMbkm[P]>
  }




  export type PendaftaranMbkmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendaftaranMbkmWhereInput
    orderBy?: PendaftaranMbkmOrderByWithAggregationInput | PendaftaranMbkmOrderByWithAggregationInput[]
    by: PendaftaranMbkmScalarFieldEnum[] | PendaftaranMbkmScalarFieldEnum
    having?: PendaftaranMbkmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendaftaranMbkmCountAggregateInputType | true
    _avg?: PendaftaranMbkmAvgAggregateInputType
    _sum?: PendaftaranMbkmSumAggregateInputType
    _min?: PendaftaranMbkmMinAggregateInputType
    _max?: PendaftaranMbkmMaxAggregateInputType
  }

  export type PendaftaranMbkmGroupByOutputType = {
    id_pendaftaran_mbkm: number
    NIM: bigint
    NIP_dosbing: bigint
    NIP_koor_mbkm: bigint
    tanggal: Date
    _count: PendaftaranMbkmCountAggregateOutputType | null
    _avg: PendaftaranMbkmAvgAggregateOutputType | null
    _sum: PendaftaranMbkmSumAggregateOutputType | null
    _min: PendaftaranMbkmMinAggregateOutputType | null
    _max: PendaftaranMbkmMaxAggregateOutputType | null
  }

  type GetPendaftaranMbkmGroupByPayload<T extends PendaftaranMbkmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendaftaranMbkmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendaftaranMbkmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendaftaranMbkmGroupByOutputType[P]>
            : GetScalarType<T[P], PendaftaranMbkmGroupByOutputType[P]>
        }
      >
    >


  export type PendaftaranMbkmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran_mbkm?: boolean
    NIM?: boolean
    NIP_dosbing?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | PendaftaranMbkm$BerkasPenilaianArgs<ExtArgs>
    _count?: boolean | PendaftaranMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendaftaranMbkm"]>

  export type PendaftaranMbkmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran_mbkm?: boolean
    NIM?: boolean
    NIP_dosbing?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendaftaranMbkm"]>

  export type PendaftaranMbkmSelectScalar = {
    id_pendaftaran_mbkm?: boolean
    NIM?: boolean
    NIP_dosbing?: boolean
    NIP_koor_mbkm?: boolean
    tanggal?: boolean
  }

  export type PendaftaranMbkmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
    BerkasPenilaian?: boolean | PendaftaranMbkm$BerkasPenilaianArgs<ExtArgs>
    _count?: boolean | PendaftaranMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PendaftaranMbkmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Mahasiswa?: boolean | MahasiswaDefaultArgs<ExtArgs>
    Dosbing?: boolean | DosbingDefaultArgs<ExtArgs>
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }

  export type $PendaftaranMbkmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendaftaranMbkm"
    objects: {
      Mahasiswa: Prisma.$MahasiswaPayload<ExtArgs>
      Dosbing: Prisma.$DosbingPayload<ExtArgs>
      KoorMbkm: Prisma.$KoorMbkmPayload<ExtArgs>
      BerkasPenilaian: Prisma.$BerkasPenilaianPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pendaftaran_mbkm: number
      NIM: bigint
      NIP_dosbing: bigint
      NIP_koor_mbkm: bigint
      tanggal: Date
    }, ExtArgs["result"]["pendaftaranMbkm"]>
    composites: {}
  }

  type PendaftaranMbkmGetPayload<S extends boolean | null | undefined | PendaftaranMbkmDefaultArgs> = $Result.GetResult<Prisma.$PendaftaranMbkmPayload, S>

  type PendaftaranMbkmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PendaftaranMbkmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PendaftaranMbkmCountAggregateInputType | true
    }

  export interface PendaftaranMbkmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendaftaranMbkm'], meta: { name: 'PendaftaranMbkm' } }
    /**
     * Find zero or one PendaftaranMbkm that matches the filter.
     * @param {PendaftaranMbkmFindUniqueArgs} args - Arguments to find a PendaftaranMbkm
     * @example
     * // Get one PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendaftaranMbkmFindUniqueArgs>(args: SelectSubset<T, PendaftaranMbkmFindUniqueArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PendaftaranMbkm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PendaftaranMbkmFindUniqueOrThrowArgs} args - Arguments to find a PendaftaranMbkm
     * @example
     * // Get one PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendaftaranMbkmFindUniqueOrThrowArgs>(args: SelectSubset<T, PendaftaranMbkmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PendaftaranMbkm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmFindFirstArgs} args - Arguments to find a PendaftaranMbkm
     * @example
     * // Get one PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendaftaranMbkmFindFirstArgs>(args?: SelectSubset<T, PendaftaranMbkmFindFirstArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PendaftaranMbkm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmFindFirstOrThrowArgs} args - Arguments to find a PendaftaranMbkm
     * @example
     * // Get one PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendaftaranMbkmFindFirstOrThrowArgs>(args?: SelectSubset<T, PendaftaranMbkmFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PendaftaranMbkms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendaftaranMbkms
     * const pendaftaranMbkms = await prisma.pendaftaranMbkm.findMany()
     * 
     * // Get first 10 PendaftaranMbkms
     * const pendaftaranMbkms = await prisma.pendaftaranMbkm.findMany({ take: 10 })
     * 
     * // Only select the `id_pendaftaran_mbkm`
     * const pendaftaranMbkmWithId_pendaftaran_mbkmOnly = await prisma.pendaftaranMbkm.findMany({ select: { id_pendaftaran_mbkm: true } })
     * 
     */
    findMany<T extends PendaftaranMbkmFindManyArgs>(args?: SelectSubset<T, PendaftaranMbkmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PendaftaranMbkm.
     * @param {PendaftaranMbkmCreateArgs} args - Arguments to create a PendaftaranMbkm.
     * @example
     * // Create one PendaftaranMbkm
     * const PendaftaranMbkm = await prisma.pendaftaranMbkm.create({
     *   data: {
     *     // ... data to create a PendaftaranMbkm
     *   }
     * })
     * 
     */
    create<T extends PendaftaranMbkmCreateArgs>(args: SelectSubset<T, PendaftaranMbkmCreateArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PendaftaranMbkms.
     * @param {PendaftaranMbkmCreateManyArgs} args - Arguments to create many PendaftaranMbkms.
     * @example
     * // Create many PendaftaranMbkms
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendaftaranMbkmCreateManyArgs>(args?: SelectSubset<T, PendaftaranMbkmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendaftaranMbkms and returns the data saved in the database.
     * @param {PendaftaranMbkmCreateManyAndReturnArgs} args - Arguments to create many PendaftaranMbkms.
     * @example
     * // Create many PendaftaranMbkms
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendaftaranMbkms and only return the `id_pendaftaran_mbkm`
     * const pendaftaranMbkmWithId_pendaftaran_mbkmOnly = await prisma.pendaftaranMbkm.createManyAndReturn({ 
     *   select: { id_pendaftaran_mbkm: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendaftaranMbkmCreateManyAndReturnArgs>(args?: SelectSubset<T, PendaftaranMbkmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PendaftaranMbkm.
     * @param {PendaftaranMbkmDeleteArgs} args - Arguments to delete one PendaftaranMbkm.
     * @example
     * // Delete one PendaftaranMbkm
     * const PendaftaranMbkm = await prisma.pendaftaranMbkm.delete({
     *   where: {
     *     // ... filter to delete one PendaftaranMbkm
     *   }
     * })
     * 
     */
    delete<T extends PendaftaranMbkmDeleteArgs>(args: SelectSubset<T, PendaftaranMbkmDeleteArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PendaftaranMbkm.
     * @param {PendaftaranMbkmUpdateArgs} args - Arguments to update one PendaftaranMbkm.
     * @example
     * // Update one PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendaftaranMbkmUpdateArgs>(args: SelectSubset<T, PendaftaranMbkmUpdateArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PendaftaranMbkms.
     * @param {PendaftaranMbkmDeleteManyArgs} args - Arguments to filter PendaftaranMbkms to delete.
     * @example
     * // Delete a few PendaftaranMbkms
     * const { count } = await prisma.pendaftaranMbkm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendaftaranMbkmDeleteManyArgs>(args?: SelectSubset<T, PendaftaranMbkmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendaftaranMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendaftaranMbkms
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendaftaranMbkmUpdateManyArgs>(args: SelectSubset<T, PendaftaranMbkmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PendaftaranMbkm.
     * @param {PendaftaranMbkmUpsertArgs} args - Arguments to update or create a PendaftaranMbkm.
     * @example
     * // Update or create a PendaftaranMbkm
     * const pendaftaranMbkm = await prisma.pendaftaranMbkm.upsert({
     *   create: {
     *     // ... data to create a PendaftaranMbkm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendaftaranMbkm we want to update
     *   }
     * })
     */
    upsert<T extends PendaftaranMbkmUpsertArgs>(args: SelectSubset<T, PendaftaranMbkmUpsertArgs<ExtArgs>>): Prisma__PendaftaranMbkmClient<$Result.GetResult<Prisma.$PendaftaranMbkmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PendaftaranMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmCountArgs} args - Arguments to filter PendaftaranMbkms to count.
     * @example
     * // Count the number of PendaftaranMbkms
     * const count = await prisma.pendaftaranMbkm.count({
     *   where: {
     *     // ... the filter for the PendaftaranMbkms we want to count
     *   }
     * })
    **/
    count<T extends PendaftaranMbkmCountArgs>(
      args?: Subset<T, PendaftaranMbkmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendaftaranMbkmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendaftaranMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendaftaranMbkmAggregateArgs>(args: Subset<T, PendaftaranMbkmAggregateArgs>): Prisma.PrismaPromise<GetPendaftaranMbkmAggregateType<T>>

    /**
     * Group by PendaftaranMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranMbkmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendaftaranMbkmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendaftaranMbkmGroupByArgs['orderBy'] }
        : { orderBy?: PendaftaranMbkmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendaftaranMbkmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendaftaranMbkmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendaftaranMbkm model
   */
  readonly fields: PendaftaranMbkmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendaftaranMbkm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendaftaranMbkmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Mahasiswa<T extends MahasiswaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MahasiswaDefaultArgs<ExtArgs>>): Prisma__MahasiswaClient<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Dosbing<T extends DosbingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DosbingDefaultArgs<ExtArgs>>): Prisma__DosbingClient<$Result.GetResult<Prisma.$DosbingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    KoorMbkm<T extends KoorMbkmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkmDefaultArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    BerkasPenilaian<T extends PendaftaranMbkm$BerkasPenilaianArgs<ExtArgs> = {}>(args?: Subset<T, PendaftaranMbkm$BerkasPenilaianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BerkasPenilaianPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendaftaranMbkm model
   */ 
  interface PendaftaranMbkmFieldRefs {
    readonly id_pendaftaran_mbkm: FieldRef<"PendaftaranMbkm", 'Int'>
    readonly NIM: FieldRef<"PendaftaranMbkm", 'BigInt'>
    readonly NIP_dosbing: FieldRef<"PendaftaranMbkm", 'BigInt'>
    readonly NIP_koor_mbkm: FieldRef<"PendaftaranMbkm", 'BigInt'>
    readonly tanggal: FieldRef<"PendaftaranMbkm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendaftaranMbkm findUnique
   */
  export type PendaftaranMbkmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranMbkm to fetch.
     */
    where: PendaftaranMbkmWhereUniqueInput
  }

  /**
   * PendaftaranMbkm findUniqueOrThrow
   */
  export type PendaftaranMbkmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranMbkm to fetch.
     */
    where: PendaftaranMbkmWhereUniqueInput
  }

  /**
   * PendaftaranMbkm findFirst
   */
  export type PendaftaranMbkmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranMbkm to fetch.
     */
    where?: PendaftaranMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranMbkms to fetch.
     */
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendaftaranMbkms.
     */
    cursor?: PendaftaranMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendaftaranMbkms.
     */
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * PendaftaranMbkm findFirstOrThrow
   */
  export type PendaftaranMbkmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranMbkm to fetch.
     */
    where?: PendaftaranMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranMbkms to fetch.
     */
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendaftaranMbkms.
     */
    cursor?: PendaftaranMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendaftaranMbkms.
     */
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * PendaftaranMbkm findMany
   */
  export type PendaftaranMbkmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter, which PendaftaranMbkms to fetch.
     */
    where?: PendaftaranMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendaftaranMbkms to fetch.
     */
    orderBy?: PendaftaranMbkmOrderByWithRelationInput | PendaftaranMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendaftaranMbkms.
     */
    cursor?: PendaftaranMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendaftaranMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendaftaranMbkms.
     */
    skip?: number
    distinct?: PendaftaranMbkmScalarFieldEnum | PendaftaranMbkmScalarFieldEnum[]
  }

  /**
   * PendaftaranMbkm create
   */
  export type PendaftaranMbkmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * The data needed to create a PendaftaranMbkm.
     */
    data: XOR<PendaftaranMbkmCreateInput, PendaftaranMbkmUncheckedCreateInput>
  }

  /**
   * PendaftaranMbkm createMany
   */
  export type PendaftaranMbkmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendaftaranMbkms.
     */
    data: PendaftaranMbkmCreateManyInput | PendaftaranMbkmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendaftaranMbkm createManyAndReturn
   */
  export type PendaftaranMbkmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PendaftaranMbkms.
     */
    data: PendaftaranMbkmCreateManyInput | PendaftaranMbkmCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendaftaranMbkm update
   */
  export type PendaftaranMbkmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * The data needed to update a PendaftaranMbkm.
     */
    data: XOR<PendaftaranMbkmUpdateInput, PendaftaranMbkmUncheckedUpdateInput>
    /**
     * Choose, which PendaftaranMbkm to update.
     */
    where: PendaftaranMbkmWhereUniqueInput
  }

  /**
   * PendaftaranMbkm updateMany
   */
  export type PendaftaranMbkmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendaftaranMbkms.
     */
    data: XOR<PendaftaranMbkmUpdateManyMutationInput, PendaftaranMbkmUncheckedUpdateManyInput>
    /**
     * Filter which PendaftaranMbkms to update
     */
    where?: PendaftaranMbkmWhereInput
  }

  /**
   * PendaftaranMbkm upsert
   */
  export type PendaftaranMbkmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * The filter to search for the PendaftaranMbkm to update in case it exists.
     */
    where: PendaftaranMbkmWhereUniqueInput
    /**
     * In case the PendaftaranMbkm found by the `where` argument doesn't exist, create a new PendaftaranMbkm with this data.
     */
    create: XOR<PendaftaranMbkmCreateInput, PendaftaranMbkmUncheckedCreateInput>
    /**
     * In case the PendaftaranMbkm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendaftaranMbkmUpdateInput, PendaftaranMbkmUncheckedUpdateInput>
  }

  /**
   * PendaftaranMbkm delete
   */
  export type PendaftaranMbkmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
    /**
     * Filter which PendaftaranMbkm to delete.
     */
    where: PendaftaranMbkmWhereUniqueInput
  }

  /**
   * PendaftaranMbkm deleteMany
   */
  export type PendaftaranMbkmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendaftaranMbkms to delete
     */
    where?: PendaftaranMbkmWhereInput
  }

  /**
   * PendaftaranMbkm.BerkasPenilaian
   */
  export type PendaftaranMbkm$BerkasPenilaianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BerkasPenilaian
     */
    select?: BerkasPenilaianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BerkasPenilaianInclude<ExtArgs> | null
    where?: BerkasPenilaianWhereInput
    orderBy?: BerkasPenilaianOrderByWithRelationInput | BerkasPenilaianOrderByWithRelationInput[]
    cursor?: BerkasPenilaianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BerkasPenilaianScalarFieldEnum | BerkasPenilaianScalarFieldEnum[]
  }

  /**
   * PendaftaranMbkm without action
   */
  export type PendaftaranMbkmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendaftaranMbkm
     */
    select?: PendaftaranMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendaftaranMbkmInclude<ExtArgs> | null
  }


  /**
   * Model Pengumuman
   */

  export type AggregatePengumuman = {
    _count: PengumumanCountAggregateOutputType | null
    _avg: PengumumanAvgAggregateOutputType | null
    _sum: PengumumanSumAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  export type PengumumanAvgAggregateOutputType = {
    id_pengumuman: number | null
    NIP_koor_mbkm: number | null
  }

  export type PengumumanSumAggregateOutputType = {
    id_pengumuman: number | null
    NIP_koor_mbkm: bigint | null
  }

  export type PengumumanMinAggregateOutputType = {
    id_pengumuman: number | null
    judul: string | null
    isi: string | null
    tanggal: Date | null
    NIP_koor_mbkm: bigint | null
  }

  export type PengumumanMaxAggregateOutputType = {
    id_pengumuman: number | null
    judul: string | null
    isi: string | null
    tanggal: Date | null
    NIP_koor_mbkm: bigint | null
  }

  export type PengumumanCountAggregateOutputType = {
    id_pengumuman: number
    judul: number
    isi: number
    tanggal: number
    NIP_koor_mbkm: number
    _all: number
  }


  export type PengumumanAvgAggregateInputType = {
    id_pengumuman?: true
    NIP_koor_mbkm?: true
  }

  export type PengumumanSumAggregateInputType = {
    id_pengumuman?: true
    NIP_koor_mbkm?: true
  }

  export type PengumumanMinAggregateInputType = {
    id_pengumuman?: true
    judul?: true
    isi?: true
    tanggal?: true
    NIP_koor_mbkm?: true
  }

  export type PengumumanMaxAggregateInputType = {
    id_pengumuman?: true
    judul?: true
    isi?: true
    tanggal?: true
    NIP_koor_mbkm?: true
  }

  export type PengumumanCountAggregateInputType = {
    id_pengumuman?: true
    judul?: true
    isi?: true
    tanggal?: true
    NIP_koor_mbkm?: true
    _all?: true
  }

  export type PengumumanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumuman to aggregate.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pengumumen
    **/
    _count?: true | PengumumanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PengumumanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PengumumanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengumumanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengumumanMaxAggregateInputType
  }

  export type GetPengumumanAggregateType<T extends PengumumanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengumuman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengumuman[P]>
      : GetScalarType<T[P], AggregatePengumuman[P]>
  }




  export type PengumumanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithAggregationInput | PengumumanOrderByWithAggregationInput[]
    by: PengumumanScalarFieldEnum[] | PengumumanScalarFieldEnum
    having?: PengumumanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengumumanCountAggregateInputType | true
    _avg?: PengumumanAvgAggregateInputType
    _sum?: PengumumanSumAggregateInputType
    _min?: PengumumanMinAggregateInputType
    _max?: PengumumanMaxAggregateInputType
  }

  export type PengumumanGroupByOutputType = {
    id_pengumuman: number
    judul: string
    isi: string
    tanggal: Date
    NIP_koor_mbkm: bigint
    _count: PengumumanCountAggregateOutputType | null
    _avg: PengumumanAvgAggregateOutputType | null
    _sum: PengumumanSumAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  type GetPengumumanGroupByPayload<T extends PengumumanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengumumanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengumumanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
            : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
        }
      >
    >


  export type PengumumanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pengumuman?: boolean
    judul?: boolean
    isi?: boolean
    tanggal?: boolean
    NIP_koor_mbkm?: boolean
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pengumuman?: boolean
    judul?: boolean
    isi?: boolean
    tanggal?: boolean
    NIP_koor_mbkm?: boolean
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectScalar = {
    id_pengumuman?: boolean
    judul?: boolean
    isi?: boolean
    tanggal?: boolean
    NIP_koor_mbkm?: boolean
  }

  export type PengumumanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }
  export type PengumumanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KoorMbkm?: boolean | KoorMbkmDefaultArgs<ExtArgs>
  }

  export type $PengumumanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pengumuman"
    objects: {
      KoorMbkm: Prisma.$KoorMbkmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pengumuman: number
      judul: string
      isi: string
      tanggal: Date
      NIP_koor_mbkm: bigint
    }, ExtArgs["result"]["pengumuman"]>
    composites: {}
  }

  type PengumumanGetPayload<S extends boolean | null | undefined | PengumumanDefaultArgs> = $Result.GetResult<Prisma.$PengumumanPayload, S>

  type PengumumanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PengumumanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PengumumanCountAggregateInputType | true
    }

  export interface PengumumanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pengumuman'], meta: { name: 'Pengumuman' } }
    /**
     * Find zero or one Pengumuman that matches the filter.
     * @param {PengumumanFindUniqueArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PengumumanFindUniqueArgs>(args: SelectSubset<T, PengumumanFindUniqueArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pengumuman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PengumumanFindUniqueOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PengumumanFindUniqueOrThrowArgs>(args: SelectSubset<T, PengumumanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PengumumanFindFirstArgs>(args?: SelectSubset<T, PengumumanFindFirstArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PengumumanFindFirstOrThrowArgs>(args?: SelectSubset<T, PengumumanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pengumumen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany()
     * 
     * // Get first 10 Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany({ take: 10 })
     * 
     * // Only select the `id_pengumuman`
     * const pengumumanWithId_pengumumanOnly = await prisma.pengumuman.findMany({ select: { id_pengumuman: true } })
     * 
     */
    findMany<T extends PengumumanFindManyArgs>(args?: SelectSubset<T, PengumumanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pengumuman.
     * @param {PengumumanCreateArgs} args - Arguments to create a Pengumuman.
     * @example
     * // Create one Pengumuman
     * const Pengumuman = await prisma.pengumuman.create({
     *   data: {
     *     // ... data to create a Pengumuman
     *   }
     * })
     * 
     */
    create<T extends PengumumanCreateArgs>(args: SelectSubset<T, PengumumanCreateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pengumumen.
     * @param {PengumumanCreateManyArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PengumumanCreateManyArgs>(args?: SelectSubset<T, PengumumanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pengumumen and returns the data saved in the database.
     * @param {PengumumanCreateManyAndReturnArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pengumumen and only return the `id_pengumuman`
     * const pengumumanWithId_pengumumanOnly = await prisma.pengumuman.createManyAndReturn({ 
     *   select: { id_pengumuman: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PengumumanCreateManyAndReturnArgs>(args?: SelectSubset<T, PengumumanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pengumuman.
     * @param {PengumumanDeleteArgs} args - Arguments to delete one Pengumuman.
     * @example
     * // Delete one Pengumuman
     * const Pengumuman = await prisma.pengumuman.delete({
     *   where: {
     *     // ... filter to delete one Pengumuman
     *   }
     * })
     * 
     */
    delete<T extends PengumumanDeleteArgs>(args: SelectSubset<T, PengumumanDeleteArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pengumuman.
     * @param {PengumumanUpdateArgs} args - Arguments to update one Pengumuman.
     * @example
     * // Update one Pengumuman
     * const pengumuman = await prisma.pengumuman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PengumumanUpdateArgs>(args: SelectSubset<T, PengumumanUpdateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pengumumen.
     * @param {PengumumanDeleteManyArgs} args - Arguments to filter Pengumumen to delete.
     * @example
     * // Delete a few Pengumumen
     * const { count } = await prisma.pengumuman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PengumumanDeleteManyArgs>(args?: SelectSubset<T, PengumumanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengumumen
     * const pengumuman = await prisma.pengumuman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PengumumanUpdateManyArgs>(args: SelectSubset<T, PengumumanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengumuman.
     * @param {PengumumanUpsertArgs} args - Arguments to update or create a Pengumuman.
     * @example
     * // Update or create a Pengumuman
     * const pengumuman = await prisma.pengumuman.upsert({
     *   create: {
     *     // ... data to create a Pengumuman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengumuman we want to update
     *   }
     * })
     */
    upsert<T extends PengumumanUpsertArgs>(args: SelectSubset<T, PengumumanUpsertArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanCountArgs} args - Arguments to filter Pengumumen to count.
     * @example
     * // Count the number of Pengumumen
     * const count = await prisma.pengumuman.count({
     *   where: {
     *     // ... the filter for the Pengumumen we want to count
     *   }
     * })
    **/
    count<T extends PengumumanCountArgs>(
      args?: Subset<T, PengumumanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengumumanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengumumanAggregateArgs>(args: Subset<T, PengumumanAggregateArgs>): Prisma.PrismaPromise<GetPengumumanAggregateType<T>>

    /**
     * Group by Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PengumumanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PengumumanGroupByArgs['orderBy'] }
        : { orderBy?: PengumumanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PengumumanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengumumanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pengumuman model
   */
  readonly fields: PengumumanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pengumuman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PengumumanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    KoorMbkm<T extends KoorMbkmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KoorMbkmDefaultArgs<ExtArgs>>): Prisma__KoorMbkmClient<$Result.GetResult<Prisma.$KoorMbkmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pengumuman model
   */ 
  interface PengumumanFieldRefs {
    readonly id_pengumuman: FieldRef<"Pengumuman", 'Int'>
    readonly judul: FieldRef<"Pengumuman", 'String'>
    readonly isi: FieldRef<"Pengumuman", 'String'>
    readonly tanggal: FieldRef<"Pengumuman", 'DateTime'>
    readonly NIP_koor_mbkm: FieldRef<"Pengumuman", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Pengumuman findUnique
   */
  export type PengumumanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findUniqueOrThrow
   */
  export type PengumumanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findFirst
   */
  export type PengumumanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findFirstOrThrow
   */
  export type PengumumanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findMany
   */
  export type PengumumanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumumen to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman create
   */
  export type PengumumanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pengumuman.
     */
    data: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
  }

  /**
   * Pengumuman createMany
   */
  export type PengumumanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pengumuman createManyAndReturn
   */
  export type PengumumanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pengumuman update
   */
  export type PengumumanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pengumuman.
     */
    data: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
    /**
     * Choose, which Pengumuman to update.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman updateMany
   */
  export type PengumumanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pengumumen.
     */
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyInput>
    /**
     * Filter which Pengumumen to update
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman upsert
   */
  export type PengumumanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pengumuman to update in case it exists.
     */
    where: PengumumanWhereUniqueInput
    /**
     * In case the Pengumuman found by the `where` argument doesn't exist, create a new Pengumuman with this data.
     */
    create: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
    /**
     * In case the Pengumuman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
  }

  /**
   * Pengumuman delete
   */
  export type PengumumanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter which Pengumuman to delete.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman deleteMany
   */
  export type PengumumanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumumen to delete
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman without action
   */
  export type PengumumanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
  }


  /**
   * Model ProgramMbkm
   */

  export type AggregateProgramMbkm = {
    _count: ProgramMbkmCountAggregateOutputType | null
    _avg: ProgramMbkmAvgAggregateOutputType | null
    _sum: ProgramMbkmSumAggregateOutputType | null
    _min: ProgramMbkmMinAggregateOutputType | null
    _max: ProgramMbkmMaxAggregateOutputType | null
  }

  export type ProgramMbkmAvgAggregateOutputType = {
    id_program_mbkm: number | null
  }

  export type ProgramMbkmSumAggregateOutputType = {
    id_program_mbkm: number | null
  }

  export type ProgramMbkmMinAggregateOutputType = {
    id_program_mbkm: number | null
    company: string | null
    deskripsi: string | null
    role: string | null
    status: string | null
    date: Date | null
    category_id: string | null
  }

  export type ProgramMbkmMaxAggregateOutputType = {
    id_program_mbkm: number | null
    company: string | null
    deskripsi: string | null
    role: string | null
    status: string | null
    date: Date | null
    category_id: string | null
  }

  export type ProgramMbkmCountAggregateOutputType = {
    id_program_mbkm: number
    company: number
    deskripsi: number
    role: number
    status: number
    date: number
    category_id: number
    _all: number
  }


  export type ProgramMbkmAvgAggregateInputType = {
    id_program_mbkm?: true
  }

  export type ProgramMbkmSumAggregateInputType = {
    id_program_mbkm?: true
  }

  export type ProgramMbkmMinAggregateInputType = {
    id_program_mbkm?: true
    company?: true
    deskripsi?: true
    role?: true
    status?: true
    date?: true
    category_id?: true
  }

  export type ProgramMbkmMaxAggregateInputType = {
    id_program_mbkm?: true
    company?: true
    deskripsi?: true
    role?: true
    status?: true
    date?: true
    category_id?: true
  }

  export type ProgramMbkmCountAggregateInputType = {
    id_program_mbkm?: true
    company?: true
    deskripsi?: true
    role?: true
    status?: true
    date?: true
    category_id?: true
    _all?: true
  }

  export type ProgramMbkmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramMbkm to aggregate.
     */
    where?: ProgramMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramMbkms to fetch.
     */
    orderBy?: ProgramMbkmOrderByWithRelationInput | ProgramMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramMbkms
    **/
    _count?: true | ProgramMbkmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramMbkmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramMbkmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMbkmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMbkmMaxAggregateInputType
  }

  export type GetProgramMbkmAggregateType<T extends ProgramMbkmAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramMbkm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramMbkm[P]>
      : GetScalarType<T[P], AggregateProgramMbkm[P]>
  }




  export type ProgramMbkmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramMbkmWhereInput
    orderBy?: ProgramMbkmOrderByWithAggregationInput | ProgramMbkmOrderByWithAggregationInput[]
    by: ProgramMbkmScalarFieldEnum[] | ProgramMbkmScalarFieldEnum
    having?: ProgramMbkmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramMbkmCountAggregateInputType | true
    _avg?: ProgramMbkmAvgAggregateInputType
    _sum?: ProgramMbkmSumAggregateInputType
    _min?: ProgramMbkmMinAggregateInputType
    _max?: ProgramMbkmMaxAggregateInputType
  }

  export type ProgramMbkmGroupByOutputType = {
    id_program_mbkm: number
    company: string
    deskripsi: string | null
    role: string | null
    status: string | null
    date: Date | null
    category_id: string
    _count: ProgramMbkmCountAggregateOutputType | null
    _avg: ProgramMbkmAvgAggregateOutputType | null
    _sum: ProgramMbkmSumAggregateOutputType | null
    _min: ProgramMbkmMinAggregateOutputType | null
    _max: ProgramMbkmMaxAggregateOutputType | null
  }

  type GetProgramMbkmGroupByPayload<T extends ProgramMbkmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramMbkmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramMbkmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramMbkmGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramMbkmGroupByOutputType[P]>
        }
      >
    >


  export type ProgramMbkmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_program_mbkm?: boolean
    company?: boolean
    deskripsi?: boolean
    role?: boolean
    status?: boolean
    date?: boolean
    category_id?: boolean
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Mahasiswa?: boolean | ProgramMbkm$MahasiswaArgs<ExtArgs>
    _count?: boolean | ProgramMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programMbkm"]>

  export type ProgramMbkmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_program_mbkm?: boolean
    company?: boolean
    deskripsi?: boolean
    role?: boolean
    status?: boolean
    date?: boolean
    category_id?: boolean
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programMbkm"]>

  export type ProgramMbkmSelectScalar = {
    id_program_mbkm?: boolean
    company?: boolean
    deskripsi?: boolean
    role?: boolean
    status?: boolean
    date?: boolean
    category_id?: boolean
  }

  export type ProgramMbkmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Mahasiswa?: boolean | ProgramMbkm$MahasiswaArgs<ExtArgs>
    _count?: boolean | ProgramMbkmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramMbkmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
  }

  export type $ProgramMbkmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramMbkm"
    objects: {
      Categories: Prisma.$CategoriesPayload<ExtArgs>
      Mahasiswa: Prisma.$MahasiswaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_program_mbkm: number
      company: string
      deskripsi: string | null
      role: string | null
      status: string | null
      date: Date | null
      category_id: string
    }, ExtArgs["result"]["programMbkm"]>
    composites: {}
  }

  type ProgramMbkmGetPayload<S extends boolean | null | undefined | ProgramMbkmDefaultArgs> = $Result.GetResult<Prisma.$ProgramMbkmPayload, S>

  type ProgramMbkmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramMbkmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramMbkmCountAggregateInputType | true
    }

  export interface ProgramMbkmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramMbkm'], meta: { name: 'ProgramMbkm' } }
    /**
     * Find zero or one ProgramMbkm that matches the filter.
     * @param {ProgramMbkmFindUniqueArgs} args - Arguments to find a ProgramMbkm
     * @example
     * // Get one ProgramMbkm
     * const programMbkm = await prisma.programMbkm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramMbkmFindUniqueArgs>(args: SelectSubset<T, ProgramMbkmFindUniqueArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramMbkm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramMbkmFindUniqueOrThrowArgs} args - Arguments to find a ProgramMbkm
     * @example
     * // Get one ProgramMbkm
     * const programMbkm = await prisma.programMbkm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramMbkmFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramMbkmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramMbkm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmFindFirstArgs} args - Arguments to find a ProgramMbkm
     * @example
     * // Get one ProgramMbkm
     * const programMbkm = await prisma.programMbkm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramMbkmFindFirstArgs>(args?: SelectSubset<T, ProgramMbkmFindFirstArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramMbkm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmFindFirstOrThrowArgs} args - Arguments to find a ProgramMbkm
     * @example
     * // Get one ProgramMbkm
     * const programMbkm = await prisma.programMbkm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramMbkmFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramMbkmFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramMbkms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramMbkms
     * const programMbkms = await prisma.programMbkm.findMany()
     * 
     * // Get first 10 ProgramMbkms
     * const programMbkms = await prisma.programMbkm.findMany({ take: 10 })
     * 
     * // Only select the `id_program_mbkm`
     * const programMbkmWithId_program_mbkmOnly = await prisma.programMbkm.findMany({ select: { id_program_mbkm: true } })
     * 
     */
    findMany<T extends ProgramMbkmFindManyArgs>(args?: SelectSubset<T, ProgramMbkmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramMbkm.
     * @param {ProgramMbkmCreateArgs} args - Arguments to create a ProgramMbkm.
     * @example
     * // Create one ProgramMbkm
     * const ProgramMbkm = await prisma.programMbkm.create({
     *   data: {
     *     // ... data to create a ProgramMbkm
     *   }
     * })
     * 
     */
    create<T extends ProgramMbkmCreateArgs>(args: SelectSubset<T, ProgramMbkmCreateArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramMbkms.
     * @param {ProgramMbkmCreateManyArgs} args - Arguments to create many ProgramMbkms.
     * @example
     * // Create many ProgramMbkms
     * const programMbkm = await prisma.programMbkm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramMbkmCreateManyArgs>(args?: SelectSubset<T, ProgramMbkmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramMbkms and returns the data saved in the database.
     * @param {ProgramMbkmCreateManyAndReturnArgs} args - Arguments to create many ProgramMbkms.
     * @example
     * // Create many ProgramMbkms
     * const programMbkm = await prisma.programMbkm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramMbkms and only return the `id_program_mbkm`
     * const programMbkmWithId_program_mbkmOnly = await prisma.programMbkm.createManyAndReturn({ 
     *   select: { id_program_mbkm: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramMbkmCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramMbkmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramMbkm.
     * @param {ProgramMbkmDeleteArgs} args - Arguments to delete one ProgramMbkm.
     * @example
     * // Delete one ProgramMbkm
     * const ProgramMbkm = await prisma.programMbkm.delete({
     *   where: {
     *     // ... filter to delete one ProgramMbkm
     *   }
     * })
     * 
     */
    delete<T extends ProgramMbkmDeleteArgs>(args: SelectSubset<T, ProgramMbkmDeleteArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramMbkm.
     * @param {ProgramMbkmUpdateArgs} args - Arguments to update one ProgramMbkm.
     * @example
     * // Update one ProgramMbkm
     * const programMbkm = await prisma.programMbkm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramMbkmUpdateArgs>(args: SelectSubset<T, ProgramMbkmUpdateArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramMbkms.
     * @param {ProgramMbkmDeleteManyArgs} args - Arguments to filter ProgramMbkms to delete.
     * @example
     * // Delete a few ProgramMbkms
     * const { count } = await prisma.programMbkm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramMbkmDeleteManyArgs>(args?: SelectSubset<T, ProgramMbkmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramMbkms
     * const programMbkm = await prisma.programMbkm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramMbkmUpdateManyArgs>(args: SelectSubset<T, ProgramMbkmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramMbkm.
     * @param {ProgramMbkmUpsertArgs} args - Arguments to update or create a ProgramMbkm.
     * @example
     * // Update or create a ProgramMbkm
     * const programMbkm = await prisma.programMbkm.upsert({
     *   create: {
     *     // ... data to create a ProgramMbkm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramMbkm we want to update
     *   }
     * })
     */
    upsert<T extends ProgramMbkmUpsertArgs>(args: SelectSubset<T, ProgramMbkmUpsertArgs<ExtArgs>>): Prisma__ProgramMbkmClient<$Result.GetResult<Prisma.$ProgramMbkmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramMbkms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmCountArgs} args - Arguments to filter ProgramMbkms to count.
     * @example
     * // Count the number of ProgramMbkms
     * const count = await prisma.programMbkm.count({
     *   where: {
     *     // ... the filter for the ProgramMbkms we want to count
     *   }
     * })
    **/
    count<T extends ProgramMbkmCountArgs>(
      args?: Subset<T, ProgramMbkmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramMbkmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramMbkmAggregateArgs>(args: Subset<T, ProgramMbkmAggregateArgs>): Prisma.PrismaPromise<GetProgramMbkmAggregateType<T>>

    /**
     * Group by ProgramMbkm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramMbkmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramMbkmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramMbkmGroupByArgs['orderBy'] }
        : { orderBy?: ProgramMbkmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramMbkmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramMbkmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramMbkm model
   */
  readonly fields: ProgramMbkmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramMbkm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramMbkmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Categories<T extends CategoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriesDefaultArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Mahasiswa<T extends ProgramMbkm$MahasiswaArgs<ExtArgs> = {}>(args?: Subset<T, ProgramMbkm$MahasiswaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MahasiswaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramMbkm model
   */ 
  interface ProgramMbkmFieldRefs {
    readonly id_program_mbkm: FieldRef<"ProgramMbkm", 'Int'>
    readonly company: FieldRef<"ProgramMbkm", 'String'>
    readonly deskripsi: FieldRef<"ProgramMbkm", 'String'>
    readonly role: FieldRef<"ProgramMbkm", 'String'>
    readonly status: FieldRef<"ProgramMbkm", 'String'>
    readonly date: FieldRef<"ProgramMbkm", 'DateTime'>
    readonly category_id: FieldRef<"ProgramMbkm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProgramMbkm findUnique
   */
  export type ProgramMbkmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter, which ProgramMbkm to fetch.
     */
    where: ProgramMbkmWhereUniqueInput
  }

  /**
   * ProgramMbkm findUniqueOrThrow
   */
  export type ProgramMbkmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter, which ProgramMbkm to fetch.
     */
    where: ProgramMbkmWhereUniqueInput
  }

  /**
   * ProgramMbkm findFirst
   */
  export type ProgramMbkmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter, which ProgramMbkm to fetch.
     */
    where?: ProgramMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramMbkms to fetch.
     */
    orderBy?: ProgramMbkmOrderByWithRelationInput | ProgramMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramMbkms.
     */
    cursor?: ProgramMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramMbkms.
     */
    distinct?: ProgramMbkmScalarFieldEnum | ProgramMbkmScalarFieldEnum[]
  }

  /**
   * ProgramMbkm findFirstOrThrow
   */
  export type ProgramMbkmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter, which ProgramMbkm to fetch.
     */
    where?: ProgramMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramMbkms to fetch.
     */
    orderBy?: ProgramMbkmOrderByWithRelationInput | ProgramMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramMbkms.
     */
    cursor?: ProgramMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramMbkms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramMbkms.
     */
    distinct?: ProgramMbkmScalarFieldEnum | ProgramMbkmScalarFieldEnum[]
  }

  /**
   * ProgramMbkm findMany
   */
  export type ProgramMbkmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter, which ProgramMbkms to fetch.
     */
    where?: ProgramMbkmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramMbkms to fetch.
     */
    orderBy?: ProgramMbkmOrderByWithRelationInput | ProgramMbkmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramMbkms.
     */
    cursor?: ProgramMbkmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramMbkms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramMbkms.
     */
    skip?: number
    distinct?: ProgramMbkmScalarFieldEnum | ProgramMbkmScalarFieldEnum[]
  }

  /**
   * ProgramMbkm create
   */
  export type ProgramMbkmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramMbkm.
     */
    data: XOR<ProgramMbkmCreateInput, ProgramMbkmUncheckedCreateInput>
  }

  /**
   * ProgramMbkm createMany
   */
  export type ProgramMbkmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramMbkms.
     */
    data: ProgramMbkmCreateManyInput | ProgramMbkmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramMbkm createManyAndReturn
   */
  export type ProgramMbkmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramMbkms.
     */
    data: ProgramMbkmCreateManyInput | ProgramMbkmCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramMbkm update
   */
  export type ProgramMbkmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramMbkm.
     */
    data: XOR<ProgramMbkmUpdateInput, ProgramMbkmUncheckedUpdateInput>
    /**
     * Choose, which ProgramMbkm to update.
     */
    where: ProgramMbkmWhereUniqueInput
  }

  /**
   * ProgramMbkm updateMany
   */
  export type ProgramMbkmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramMbkms.
     */
    data: XOR<ProgramMbkmUpdateManyMutationInput, ProgramMbkmUncheckedUpdateManyInput>
    /**
     * Filter which ProgramMbkms to update
     */
    where?: ProgramMbkmWhereInput
  }

  /**
   * ProgramMbkm upsert
   */
  export type ProgramMbkmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramMbkm to update in case it exists.
     */
    where: ProgramMbkmWhereUniqueInput
    /**
     * In case the ProgramMbkm found by the `where` argument doesn't exist, create a new ProgramMbkm with this data.
     */
    create: XOR<ProgramMbkmCreateInput, ProgramMbkmUncheckedCreateInput>
    /**
     * In case the ProgramMbkm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramMbkmUpdateInput, ProgramMbkmUncheckedUpdateInput>
  }

  /**
   * ProgramMbkm delete
   */
  export type ProgramMbkmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
    /**
     * Filter which ProgramMbkm to delete.
     */
    where: ProgramMbkmWhereUniqueInput
  }

  /**
   * ProgramMbkm deleteMany
   */
  export type ProgramMbkmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramMbkms to delete
     */
    where?: ProgramMbkmWhereInput
  }

  /**
   * ProgramMbkm.Mahasiswa
   */
  export type ProgramMbkm$MahasiswaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mahasiswa
     */
    select?: MahasiswaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MahasiswaInclude<ExtArgs> | null
    where?: MahasiswaWhereInput
    orderBy?: MahasiswaOrderByWithRelationInput | MahasiswaOrderByWithRelationInput[]
    cursor?: MahasiswaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MahasiswaScalarFieldEnum | MahasiswaScalarFieldEnum[]
  }

  /**
   * ProgramMbkm without action
   */
  export type ProgramMbkmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramMbkm
     */
    select?: ProgramMbkmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramMbkmInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminSiapScalarFieldEnum: {
    NIP_admin_siap: 'NIP_admin_siap',
    nama_admin_siap: 'nama_admin_siap'
  };

  export type AdminSiapScalarFieldEnum = (typeof AdminSiapScalarFieldEnum)[keyof typeof AdminSiapScalarFieldEnum]


  export const BerkasPenilaianScalarFieldEnum: {
    id_berkas_penilaian: 'id_berkas_penilaian',
    id_pendaftaran_mbkm: 'id_pendaftaran_mbkm',
    nama_berkas: 'nama_berkas'
  };

  export type BerkasPenilaianScalarFieldEnum = (typeof BerkasPenilaianScalarFieldEnum)[keyof typeof BerkasPenilaianScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const DosbingScalarFieldEnum: {
    NIP_dosbing: 'NIP_dosbing',
    nama_dosbing: 'nama_dosbing'
  };

  export type DosbingScalarFieldEnum = (typeof DosbingScalarFieldEnum)[keyof typeof DosbingScalarFieldEnum]


  export const KonversiNilaiScalarFieldEnum: {
    id_konversi_nilai: 'id_konversi_nilai',
    NIP_admin_siap: 'NIP_admin_siap',
    id_berkas_penilaian: 'id_berkas_penilaian',
    nilai_akhir: 'nilai_akhir',
    grade: 'grade'
  };

  export type KonversiNilaiScalarFieldEnum = (typeof KonversiNilaiScalarFieldEnum)[keyof typeof KonversiNilaiScalarFieldEnum]


  export const KoorMbkmScalarFieldEnum: {
    NIP_koor_mbkm: 'NIP_koor_mbkm',
    nama_koor_mbkm: 'nama_koor_mbkm'
  };

  export type KoorMbkmScalarFieldEnum = (typeof KoorMbkmScalarFieldEnum)[keyof typeof KoorMbkmScalarFieldEnum]


  export const MahasiswaScalarFieldEnum: {
    NIM: 'NIM',
    nama_mahasiswa: 'nama_mahasiswa',
    semester: 'semester',
    id_program_mbkm: 'id_program_mbkm',
    NIP_dosbing: 'NIP_dosbing'
  };

  export type MahasiswaScalarFieldEnum = (typeof MahasiswaScalarFieldEnum)[keyof typeof MahasiswaScalarFieldEnum]


  export const PendaftaranAkunScalarFieldEnum: {
    id_pendaftaran_akun: 'id_pendaftaran_akun',
    NIM: 'NIM',
    NIP_koor_mbkm: 'NIP_koor_mbkm',
    tanggal: 'tanggal'
  };

  export type PendaftaranAkunScalarFieldEnum = (typeof PendaftaranAkunScalarFieldEnum)[keyof typeof PendaftaranAkunScalarFieldEnum]


  export const PendaftaranMbkmScalarFieldEnum: {
    id_pendaftaran_mbkm: 'id_pendaftaran_mbkm',
    NIM: 'NIM',
    NIP_dosbing: 'NIP_dosbing',
    NIP_koor_mbkm: 'NIP_koor_mbkm',
    tanggal: 'tanggal'
  };

  export type PendaftaranMbkmScalarFieldEnum = (typeof PendaftaranMbkmScalarFieldEnum)[keyof typeof PendaftaranMbkmScalarFieldEnum]


  export const PengumumanScalarFieldEnum: {
    id_pengumuman: 'id_pengumuman',
    judul: 'judul',
    isi: 'isi',
    tanggal: 'tanggal',
    NIP_koor_mbkm: 'NIP_koor_mbkm'
  };

  export type PengumumanScalarFieldEnum = (typeof PengumumanScalarFieldEnum)[keyof typeof PengumumanScalarFieldEnum]


  export const ProgramMbkmScalarFieldEnum: {
    id_program_mbkm: 'id_program_mbkm',
    company: 'company',
    deskripsi: 'deskripsi',
    role: 'role',
    status: 'status',
    date: 'date',
    category_id: 'category_id'
  };

  export type ProgramMbkmScalarFieldEnum = (typeof ProgramMbkmScalarFieldEnum)[keyof typeof ProgramMbkmScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminSiapWhereInput = {
    AND?: AdminSiapWhereInput | AdminSiapWhereInput[]
    OR?: AdminSiapWhereInput[]
    NOT?: AdminSiapWhereInput | AdminSiapWhereInput[]
    NIP_admin_siap?: BigIntFilter<"AdminSiap"> | bigint | number
    nama_admin_siap?: StringFilter<"AdminSiap"> | string
    KonversiNilai?: KonversiNilaiListRelationFilter
  }

  export type AdminSiapOrderByWithRelationInput = {
    NIP_admin_siap?: SortOrder
    nama_admin_siap?: SortOrder
    KonversiNilai?: KonversiNilaiOrderByRelationAggregateInput
  }

  export type AdminSiapWhereUniqueInput = Prisma.AtLeast<{
    NIP_admin_siap?: bigint | number
    AND?: AdminSiapWhereInput | AdminSiapWhereInput[]
    OR?: AdminSiapWhereInput[]
    NOT?: AdminSiapWhereInput | AdminSiapWhereInput[]
    nama_admin_siap?: StringFilter<"AdminSiap"> | string
    KonversiNilai?: KonversiNilaiListRelationFilter
  }, "NIP_admin_siap">

  export type AdminSiapOrderByWithAggregationInput = {
    NIP_admin_siap?: SortOrder
    nama_admin_siap?: SortOrder
    _count?: AdminSiapCountOrderByAggregateInput
    _avg?: AdminSiapAvgOrderByAggregateInput
    _max?: AdminSiapMaxOrderByAggregateInput
    _min?: AdminSiapMinOrderByAggregateInput
    _sum?: AdminSiapSumOrderByAggregateInput
  }

  export type AdminSiapScalarWhereWithAggregatesInput = {
    AND?: AdminSiapScalarWhereWithAggregatesInput | AdminSiapScalarWhereWithAggregatesInput[]
    OR?: AdminSiapScalarWhereWithAggregatesInput[]
    NOT?: AdminSiapScalarWhereWithAggregatesInput | AdminSiapScalarWhereWithAggregatesInput[]
    NIP_admin_siap?: BigIntWithAggregatesFilter<"AdminSiap"> | bigint | number
    nama_admin_siap?: StringWithAggregatesFilter<"AdminSiap"> | string
  }

  export type BerkasPenilaianWhereInput = {
    AND?: BerkasPenilaianWhereInput | BerkasPenilaianWhereInput[]
    OR?: BerkasPenilaianWhereInput[]
    NOT?: BerkasPenilaianWhereInput | BerkasPenilaianWhereInput[]
    id_berkas_penilaian?: IntFilter<"BerkasPenilaian"> | number
    id_pendaftaran_mbkm?: IntFilter<"BerkasPenilaian"> | number
    nama_berkas?: StringFilter<"BerkasPenilaian"> | string
    PendaftaranMbkm?: XOR<PendaftaranMbkmRelationFilter, PendaftaranMbkmWhereInput>
    KonversiNilai?: KonversiNilaiListRelationFilter
  }

  export type BerkasPenilaianOrderByWithRelationInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
    nama_berkas?: SortOrder
    PendaftaranMbkm?: PendaftaranMbkmOrderByWithRelationInput
    KonversiNilai?: KonversiNilaiOrderByRelationAggregateInput
  }

  export type BerkasPenilaianWhereUniqueInput = Prisma.AtLeast<{
    id_berkas_penilaian?: number
    AND?: BerkasPenilaianWhereInput | BerkasPenilaianWhereInput[]
    OR?: BerkasPenilaianWhereInput[]
    NOT?: BerkasPenilaianWhereInput | BerkasPenilaianWhereInput[]
    id_pendaftaran_mbkm?: IntFilter<"BerkasPenilaian"> | number
    nama_berkas?: StringFilter<"BerkasPenilaian"> | string
    PendaftaranMbkm?: XOR<PendaftaranMbkmRelationFilter, PendaftaranMbkmWhereInput>
    KonversiNilai?: KonversiNilaiListRelationFilter
  }, "id_berkas_penilaian">

  export type BerkasPenilaianOrderByWithAggregationInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
    nama_berkas?: SortOrder
    _count?: BerkasPenilaianCountOrderByAggregateInput
    _avg?: BerkasPenilaianAvgOrderByAggregateInput
    _max?: BerkasPenilaianMaxOrderByAggregateInput
    _min?: BerkasPenilaianMinOrderByAggregateInput
    _sum?: BerkasPenilaianSumOrderByAggregateInput
  }

  export type BerkasPenilaianScalarWhereWithAggregatesInput = {
    AND?: BerkasPenilaianScalarWhereWithAggregatesInput | BerkasPenilaianScalarWhereWithAggregatesInput[]
    OR?: BerkasPenilaianScalarWhereWithAggregatesInput[]
    NOT?: BerkasPenilaianScalarWhereWithAggregatesInput | BerkasPenilaianScalarWhereWithAggregatesInput[]
    id_berkas_penilaian?: IntWithAggregatesFilter<"BerkasPenilaian"> | number
    id_pendaftaran_mbkm?: IntWithAggregatesFilter<"BerkasPenilaian"> | number
    nama_berkas?: StringWithAggregatesFilter<"BerkasPenilaian"> | string
  }

  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: StringFilter<"Categories"> | string
    name?: StringFilter<"Categories"> | string
    ProgramMbkm?: ProgramMbkmListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ProgramMbkm?: ProgramMbkmOrderByRelationAggregateInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    name?: StringFilter<"Categories"> | string
    ProgramMbkm?: ProgramMbkmListRelationFilter
  }, "id">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Categories"> | string
    name?: StringWithAggregatesFilter<"Categories"> | string
  }

  export type DosbingWhereInput = {
    AND?: DosbingWhereInput | DosbingWhereInput[]
    OR?: DosbingWhereInput[]
    NOT?: DosbingWhereInput | DosbingWhereInput[]
    NIP_dosbing?: BigIntFilter<"Dosbing"> | bigint | number
    nama_dosbing?: StringFilter<"Dosbing"> | string
    Mahasiswa?: MahasiswaListRelationFilter
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
  }

  export type DosbingOrderByWithRelationInput = {
    NIP_dosbing?: SortOrder
    nama_dosbing?: SortOrder
    Mahasiswa?: MahasiswaOrderByRelationAggregateInput
    PendaftaranMbkm?: PendaftaranMbkmOrderByRelationAggregateInput
  }

  export type DosbingWhereUniqueInput = Prisma.AtLeast<{
    NIP_dosbing?: bigint | number
    AND?: DosbingWhereInput | DosbingWhereInput[]
    OR?: DosbingWhereInput[]
    NOT?: DosbingWhereInput | DosbingWhereInput[]
    nama_dosbing?: StringFilter<"Dosbing"> | string
    Mahasiswa?: MahasiswaListRelationFilter
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
  }, "NIP_dosbing">

  export type DosbingOrderByWithAggregationInput = {
    NIP_dosbing?: SortOrder
    nama_dosbing?: SortOrder
    _count?: DosbingCountOrderByAggregateInput
    _avg?: DosbingAvgOrderByAggregateInput
    _max?: DosbingMaxOrderByAggregateInput
    _min?: DosbingMinOrderByAggregateInput
    _sum?: DosbingSumOrderByAggregateInput
  }

  export type DosbingScalarWhereWithAggregatesInput = {
    AND?: DosbingScalarWhereWithAggregatesInput | DosbingScalarWhereWithAggregatesInput[]
    OR?: DosbingScalarWhereWithAggregatesInput[]
    NOT?: DosbingScalarWhereWithAggregatesInput | DosbingScalarWhereWithAggregatesInput[]
    NIP_dosbing?: BigIntWithAggregatesFilter<"Dosbing"> | bigint | number
    nama_dosbing?: StringWithAggregatesFilter<"Dosbing"> | string
  }

  export type KonversiNilaiWhereInput = {
    AND?: KonversiNilaiWhereInput | KonversiNilaiWhereInput[]
    OR?: KonversiNilaiWhereInput[]
    NOT?: KonversiNilaiWhereInput | KonversiNilaiWhereInput[]
    id_konversi_nilai?: IntFilter<"KonversiNilai"> | number
    NIP_admin_siap?: BigIntFilter<"KonversiNilai"> | bigint | number
    id_berkas_penilaian?: IntFilter<"KonversiNilai"> | number
    nilai_akhir?: IntFilter<"KonversiNilai"> | number
    grade?: StringFilter<"KonversiNilai"> | string
    AdminSiap?: XOR<AdminSiapRelationFilter, AdminSiapWhereInput>
    BerkasPenilaian?: XOR<BerkasPenilaianRelationFilter, BerkasPenilaianWhereInput>
  }

  export type KonversiNilaiOrderByWithRelationInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
    grade?: SortOrder
    AdminSiap?: AdminSiapOrderByWithRelationInput
    BerkasPenilaian?: BerkasPenilaianOrderByWithRelationInput
  }

  export type KonversiNilaiWhereUniqueInput = Prisma.AtLeast<{
    id_konversi_nilai?: number
    AND?: KonversiNilaiWhereInput | KonversiNilaiWhereInput[]
    OR?: KonversiNilaiWhereInput[]
    NOT?: KonversiNilaiWhereInput | KonversiNilaiWhereInput[]
    NIP_admin_siap?: BigIntFilter<"KonversiNilai"> | bigint | number
    id_berkas_penilaian?: IntFilter<"KonversiNilai"> | number
    nilai_akhir?: IntFilter<"KonversiNilai"> | number
    grade?: StringFilter<"KonversiNilai"> | string
    AdminSiap?: XOR<AdminSiapRelationFilter, AdminSiapWhereInput>
    BerkasPenilaian?: XOR<BerkasPenilaianRelationFilter, BerkasPenilaianWhereInput>
  }, "id_konversi_nilai">

  export type KonversiNilaiOrderByWithAggregationInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
    grade?: SortOrder
    _count?: KonversiNilaiCountOrderByAggregateInput
    _avg?: KonversiNilaiAvgOrderByAggregateInput
    _max?: KonversiNilaiMaxOrderByAggregateInput
    _min?: KonversiNilaiMinOrderByAggregateInput
    _sum?: KonversiNilaiSumOrderByAggregateInput
  }

  export type KonversiNilaiScalarWhereWithAggregatesInput = {
    AND?: KonversiNilaiScalarWhereWithAggregatesInput | KonversiNilaiScalarWhereWithAggregatesInput[]
    OR?: KonversiNilaiScalarWhereWithAggregatesInput[]
    NOT?: KonversiNilaiScalarWhereWithAggregatesInput | KonversiNilaiScalarWhereWithAggregatesInput[]
    id_konversi_nilai?: IntWithAggregatesFilter<"KonversiNilai"> | number
    NIP_admin_siap?: BigIntWithAggregatesFilter<"KonversiNilai"> | bigint | number
    id_berkas_penilaian?: IntWithAggregatesFilter<"KonversiNilai"> | number
    nilai_akhir?: IntWithAggregatesFilter<"KonversiNilai"> | number
    grade?: StringWithAggregatesFilter<"KonversiNilai"> | string
  }

  export type KoorMbkmWhereInput = {
    AND?: KoorMbkmWhereInput | KoorMbkmWhereInput[]
    OR?: KoorMbkmWhereInput[]
    NOT?: KoorMbkmWhereInput | KoorMbkmWhereInput[]
    NIP_koor_mbkm?: BigIntFilter<"KoorMbkm"> | bigint | number
    nama_koor_mbkm?: StringFilter<"KoorMbkm"> | string
    PendaftaranAkun?: PendaftaranAkunListRelationFilter
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
    Pengumuman?: PengumumanListRelationFilter
  }

  export type KoorMbkmOrderByWithRelationInput = {
    NIP_koor_mbkm?: SortOrder
    nama_koor_mbkm?: SortOrder
    PendaftaranAkun?: PendaftaranAkunOrderByRelationAggregateInput
    PendaftaranMbkm?: PendaftaranMbkmOrderByRelationAggregateInput
    Pengumuman?: PengumumanOrderByRelationAggregateInput
  }

  export type KoorMbkmWhereUniqueInput = Prisma.AtLeast<{
    NIP_koor_mbkm?: bigint | number
    AND?: KoorMbkmWhereInput | KoorMbkmWhereInput[]
    OR?: KoorMbkmWhereInput[]
    NOT?: KoorMbkmWhereInput | KoorMbkmWhereInput[]
    nama_koor_mbkm?: StringFilter<"KoorMbkm"> | string
    PendaftaranAkun?: PendaftaranAkunListRelationFilter
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
    Pengumuman?: PengumumanListRelationFilter
  }, "NIP_koor_mbkm">

  export type KoorMbkmOrderByWithAggregationInput = {
    NIP_koor_mbkm?: SortOrder
    nama_koor_mbkm?: SortOrder
    _count?: KoorMbkmCountOrderByAggregateInput
    _avg?: KoorMbkmAvgOrderByAggregateInput
    _max?: KoorMbkmMaxOrderByAggregateInput
    _min?: KoorMbkmMinOrderByAggregateInput
    _sum?: KoorMbkmSumOrderByAggregateInput
  }

  export type KoorMbkmScalarWhereWithAggregatesInput = {
    AND?: KoorMbkmScalarWhereWithAggregatesInput | KoorMbkmScalarWhereWithAggregatesInput[]
    OR?: KoorMbkmScalarWhereWithAggregatesInput[]
    NOT?: KoorMbkmScalarWhereWithAggregatesInput | KoorMbkmScalarWhereWithAggregatesInput[]
    NIP_koor_mbkm?: BigIntWithAggregatesFilter<"KoorMbkm"> | bigint | number
    nama_koor_mbkm?: StringWithAggregatesFilter<"KoorMbkm"> | string
  }

  export type MahasiswaWhereInput = {
    AND?: MahasiswaWhereInput | MahasiswaWhereInput[]
    OR?: MahasiswaWhereInput[]
    NOT?: MahasiswaWhereInput | MahasiswaWhereInput[]
    NIM?: BigIntFilter<"Mahasiswa"> | bigint | number
    nama_mahasiswa?: StringFilter<"Mahasiswa"> | string
    semester?: IntFilter<"Mahasiswa"> | number
    id_program_mbkm?: IntFilter<"Mahasiswa"> | number
    NIP_dosbing?: BigIntFilter<"Mahasiswa"> | bigint | number
    ProgramMbkm?: XOR<ProgramMbkmRelationFilter, ProgramMbkmWhereInput>
    Dosbing?: XOR<DosbingRelationFilter, DosbingWhereInput>
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
    PendaftaranAkun?: PendaftaranAkunListRelationFilter
  }

  export type MahasiswaOrderByWithRelationInput = {
    NIM?: SortOrder
    nama_mahasiswa?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
    ProgramMbkm?: ProgramMbkmOrderByWithRelationInput
    Dosbing?: DosbingOrderByWithRelationInput
    PendaftaranMbkm?: PendaftaranMbkmOrderByRelationAggregateInput
    PendaftaranAkun?: PendaftaranAkunOrderByRelationAggregateInput
  }

  export type MahasiswaWhereUniqueInput = Prisma.AtLeast<{
    NIM?: bigint | number
    AND?: MahasiswaWhereInput | MahasiswaWhereInput[]
    OR?: MahasiswaWhereInput[]
    NOT?: MahasiswaWhereInput | MahasiswaWhereInput[]
    nama_mahasiswa?: StringFilter<"Mahasiswa"> | string
    semester?: IntFilter<"Mahasiswa"> | number
    id_program_mbkm?: IntFilter<"Mahasiswa"> | number
    NIP_dosbing?: BigIntFilter<"Mahasiswa"> | bigint | number
    ProgramMbkm?: XOR<ProgramMbkmRelationFilter, ProgramMbkmWhereInput>
    Dosbing?: XOR<DosbingRelationFilter, DosbingWhereInput>
    PendaftaranMbkm?: PendaftaranMbkmListRelationFilter
    PendaftaranAkun?: PendaftaranAkunListRelationFilter
  }, "NIM">

  export type MahasiswaOrderByWithAggregationInput = {
    NIM?: SortOrder
    nama_mahasiswa?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
    _count?: MahasiswaCountOrderByAggregateInput
    _avg?: MahasiswaAvgOrderByAggregateInput
    _max?: MahasiswaMaxOrderByAggregateInput
    _min?: MahasiswaMinOrderByAggregateInput
    _sum?: MahasiswaSumOrderByAggregateInput
  }

  export type MahasiswaScalarWhereWithAggregatesInput = {
    AND?: MahasiswaScalarWhereWithAggregatesInput | MahasiswaScalarWhereWithAggregatesInput[]
    OR?: MahasiswaScalarWhereWithAggregatesInput[]
    NOT?: MahasiswaScalarWhereWithAggregatesInput | MahasiswaScalarWhereWithAggregatesInput[]
    NIM?: BigIntWithAggregatesFilter<"Mahasiswa"> | bigint | number
    nama_mahasiswa?: StringWithAggregatesFilter<"Mahasiswa"> | string
    semester?: IntWithAggregatesFilter<"Mahasiswa"> | number
    id_program_mbkm?: IntWithAggregatesFilter<"Mahasiswa"> | number
    NIP_dosbing?: BigIntWithAggregatesFilter<"Mahasiswa"> | bigint | number
  }

  export type PendaftaranAkunWhereInput = {
    AND?: PendaftaranAkunWhereInput | PendaftaranAkunWhereInput[]
    OR?: PendaftaranAkunWhereInput[]
    NOT?: PendaftaranAkunWhereInput | PendaftaranAkunWhereInput[]
    id_pendaftaran_akun?: IntFilter<"PendaftaranAkun"> | number
    NIM?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranAkun"> | Date | string
    Mahasiswa?: XOR<MahasiswaRelationFilter, MahasiswaWhereInput>
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
  }

  export type PendaftaranAkunOrderByWithRelationInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
    Mahasiswa?: MahasiswaOrderByWithRelationInput
    KoorMbkm?: KoorMbkmOrderByWithRelationInput
  }

  export type PendaftaranAkunWhereUniqueInput = Prisma.AtLeast<{
    id_pendaftaran_akun?: number
    AND?: PendaftaranAkunWhereInput | PendaftaranAkunWhereInput[]
    OR?: PendaftaranAkunWhereInput[]
    NOT?: PendaftaranAkunWhereInput | PendaftaranAkunWhereInput[]
    NIM?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranAkun"> | Date | string
    Mahasiswa?: XOR<MahasiswaRelationFilter, MahasiswaWhereInput>
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
  }, "id_pendaftaran_akun">

  export type PendaftaranAkunOrderByWithAggregationInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
    _count?: PendaftaranAkunCountOrderByAggregateInput
    _avg?: PendaftaranAkunAvgOrderByAggregateInput
    _max?: PendaftaranAkunMaxOrderByAggregateInput
    _min?: PendaftaranAkunMinOrderByAggregateInput
    _sum?: PendaftaranAkunSumOrderByAggregateInput
  }

  export type PendaftaranAkunScalarWhereWithAggregatesInput = {
    AND?: PendaftaranAkunScalarWhereWithAggregatesInput | PendaftaranAkunScalarWhereWithAggregatesInput[]
    OR?: PendaftaranAkunScalarWhereWithAggregatesInput[]
    NOT?: PendaftaranAkunScalarWhereWithAggregatesInput | PendaftaranAkunScalarWhereWithAggregatesInput[]
    id_pendaftaran_akun?: IntWithAggregatesFilter<"PendaftaranAkun"> | number
    NIM?: BigIntWithAggregatesFilter<"PendaftaranAkun"> | bigint | number
    NIP_koor_mbkm?: BigIntWithAggregatesFilter<"PendaftaranAkun"> | bigint | number
    tanggal?: DateTimeWithAggregatesFilter<"PendaftaranAkun"> | Date | string
  }

  export type PendaftaranMbkmWhereInput = {
    AND?: PendaftaranMbkmWhereInput | PendaftaranMbkmWhereInput[]
    OR?: PendaftaranMbkmWhereInput[]
    NOT?: PendaftaranMbkmWhereInput | PendaftaranMbkmWhereInput[]
    id_pendaftaran_mbkm?: IntFilter<"PendaftaranMbkm"> | number
    NIM?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_dosbing?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranMbkm"> | Date | string
    Mahasiswa?: XOR<MahasiswaRelationFilter, MahasiswaWhereInput>
    Dosbing?: XOR<DosbingRelationFilter, DosbingWhereInput>
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
    BerkasPenilaian?: BerkasPenilaianListRelationFilter
  }

  export type PendaftaranMbkmOrderByWithRelationInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
    Mahasiswa?: MahasiswaOrderByWithRelationInput
    Dosbing?: DosbingOrderByWithRelationInput
    KoorMbkm?: KoorMbkmOrderByWithRelationInput
    BerkasPenilaian?: BerkasPenilaianOrderByRelationAggregateInput
  }

  export type PendaftaranMbkmWhereUniqueInput = Prisma.AtLeast<{
    id_pendaftaran_mbkm?: number
    AND?: PendaftaranMbkmWhereInput | PendaftaranMbkmWhereInput[]
    OR?: PendaftaranMbkmWhereInput[]
    NOT?: PendaftaranMbkmWhereInput | PendaftaranMbkmWhereInput[]
    NIM?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_dosbing?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranMbkm"> | Date | string
    Mahasiswa?: XOR<MahasiswaRelationFilter, MahasiswaWhereInput>
    Dosbing?: XOR<DosbingRelationFilter, DosbingWhereInput>
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
    BerkasPenilaian?: BerkasPenilaianListRelationFilter
  }, "id_pendaftaran_mbkm">

  export type PendaftaranMbkmOrderByWithAggregationInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
    _count?: PendaftaranMbkmCountOrderByAggregateInput
    _avg?: PendaftaranMbkmAvgOrderByAggregateInput
    _max?: PendaftaranMbkmMaxOrderByAggregateInput
    _min?: PendaftaranMbkmMinOrderByAggregateInput
    _sum?: PendaftaranMbkmSumOrderByAggregateInput
  }

  export type PendaftaranMbkmScalarWhereWithAggregatesInput = {
    AND?: PendaftaranMbkmScalarWhereWithAggregatesInput | PendaftaranMbkmScalarWhereWithAggregatesInput[]
    OR?: PendaftaranMbkmScalarWhereWithAggregatesInput[]
    NOT?: PendaftaranMbkmScalarWhereWithAggregatesInput | PendaftaranMbkmScalarWhereWithAggregatesInput[]
    id_pendaftaran_mbkm?: IntWithAggregatesFilter<"PendaftaranMbkm"> | number
    NIM?: BigIntWithAggregatesFilter<"PendaftaranMbkm"> | bigint | number
    NIP_dosbing?: BigIntWithAggregatesFilter<"PendaftaranMbkm"> | bigint | number
    NIP_koor_mbkm?: BigIntWithAggregatesFilter<"PendaftaranMbkm"> | bigint | number
    tanggal?: DateTimeWithAggregatesFilter<"PendaftaranMbkm"> | Date | string
  }

  export type PengumumanWhereInput = {
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    id_pengumuman?: IntFilter<"Pengumuman"> | number
    judul?: StringFilter<"Pengumuman"> | string
    isi?: StringFilter<"Pengumuman"> | string
    tanggal?: DateTimeFilter<"Pengumuman"> | Date | string
    NIP_koor_mbkm?: BigIntFilter<"Pengumuman"> | bigint | number
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
  }

  export type PengumumanOrderByWithRelationInput = {
    id_pengumuman?: SortOrder
    judul?: SortOrder
    isi?: SortOrder
    tanggal?: SortOrder
    NIP_koor_mbkm?: SortOrder
    KoorMbkm?: KoorMbkmOrderByWithRelationInput
  }

  export type PengumumanWhereUniqueInput = Prisma.AtLeast<{
    id_pengumuman?: number
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    judul?: StringFilter<"Pengumuman"> | string
    isi?: StringFilter<"Pengumuman"> | string
    tanggal?: DateTimeFilter<"Pengumuman"> | Date | string
    NIP_koor_mbkm?: BigIntFilter<"Pengumuman"> | bigint | number
    KoorMbkm?: XOR<KoorMbkmRelationFilter, KoorMbkmWhereInput>
  }, "id_pengumuman">

  export type PengumumanOrderByWithAggregationInput = {
    id_pengumuman?: SortOrder
    judul?: SortOrder
    isi?: SortOrder
    tanggal?: SortOrder
    NIP_koor_mbkm?: SortOrder
    _count?: PengumumanCountOrderByAggregateInput
    _avg?: PengumumanAvgOrderByAggregateInput
    _max?: PengumumanMaxOrderByAggregateInput
    _min?: PengumumanMinOrderByAggregateInput
    _sum?: PengumumanSumOrderByAggregateInput
  }

  export type PengumumanScalarWhereWithAggregatesInput = {
    AND?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    OR?: PengumumanScalarWhereWithAggregatesInput[]
    NOT?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    id_pengumuman?: IntWithAggregatesFilter<"Pengumuman"> | number
    judul?: StringWithAggregatesFilter<"Pengumuman"> | string
    isi?: StringWithAggregatesFilter<"Pengumuman"> | string
    tanggal?: DateTimeWithAggregatesFilter<"Pengumuman"> | Date | string
    NIP_koor_mbkm?: BigIntWithAggregatesFilter<"Pengumuman"> | bigint | number
  }

  export type ProgramMbkmWhereInput = {
    AND?: ProgramMbkmWhereInput | ProgramMbkmWhereInput[]
    OR?: ProgramMbkmWhereInput[]
    NOT?: ProgramMbkmWhereInput | ProgramMbkmWhereInput[]
    id_program_mbkm?: IntFilter<"ProgramMbkm"> | number
    company?: StringFilter<"ProgramMbkm"> | string
    deskripsi?: StringNullableFilter<"ProgramMbkm"> | string | null
    role?: StringNullableFilter<"ProgramMbkm"> | string | null
    status?: StringNullableFilter<"ProgramMbkm"> | string | null
    date?: DateTimeNullableFilter<"ProgramMbkm"> | Date | string | null
    category_id?: StringFilter<"ProgramMbkm"> | string
    Categories?: XOR<CategoriesRelationFilter, CategoriesWhereInput>
    Mahasiswa?: MahasiswaListRelationFilter
  }

  export type ProgramMbkmOrderByWithRelationInput = {
    id_program_mbkm?: SortOrder
    company?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    category_id?: SortOrder
    Categories?: CategoriesOrderByWithRelationInput
    Mahasiswa?: MahasiswaOrderByRelationAggregateInput
  }

  export type ProgramMbkmWhereUniqueInput = Prisma.AtLeast<{
    id_program_mbkm?: number
    AND?: ProgramMbkmWhereInput | ProgramMbkmWhereInput[]
    OR?: ProgramMbkmWhereInput[]
    NOT?: ProgramMbkmWhereInput | ProgramMbkmWhereInput[]
    company?: StringFilter<"ProgramMbkm"> | string
    deskripsi?: StringNullableFilter<"ProgramMbkm"> | string | null
    role?: StringNullableFilter<"ProgramMbkm"> | string | null
    status?: StringNullableFilter<"ProgramMbkm"> | string | null
    date?: DateTimeNullableFilter<"ProgramMbkm"> | Date | string | null
    category_id?: StringFilter<"ProgramMbkm"> | string
    Categories?: XOR<CategoriesRelationFilter, CategoriesWhereInput>
    Mahasiswa?: MahasiswaListRelationFilter
  }, "id_program_mbkm">

  export type ProgramMbkmOrderByWithAggregationInput = {
    id_program_mbkm?: SortOrder
    company?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    category_id?: SortOrder
    _count?: ProgramMbkmCountOrderByAggregateInput
    _avg?: ProgramMbkmAvgOrderByAggregateInput
    _max?: ProgramMbkmMaxOrderByAggregateInput
    _min?: ProgramMbkmMinOrderByAggregateInput
    _sum?: ProgramMbkmSumOrderByAggregateInput
  }

  export type ProgramMbkmScalarWhereWithAggregatesInput = {
    AND?: ProgramMbkmScalarWhereWithAggregatesInput | ProgramMbkmScalarWhereWithAggregatesInput[]
    OR?: ProgramMbkmScalarWhereWithAggregatesInput[]
    NOT?: ProgramMbkmScalarWhereWithAggregatesInput | ProgramMbkmScalarWhereWithAggregatesInput[]
    id_program_mbkm?: IntWithAggregatesFilter<"ProgramMbkm"> | number
    company?: StringWithAggregatesFilter<"ProgramMbkm"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"ProgramMbkm"> | string | null
    role?: StringNullableWithAggregatesFilter<"ProgramMbkm"> | string | null
    status?: StringNullableWithAggregatesFilter<"ProgramMbkm"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"ProgramMbkm"> | Date | string | null
    category_id?: StringWithAggregatesFilter<"ProgramMbkm"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type AdminSiapCreateInput = {
    NIP_admin_siap: bigint | number
    nama_admin_siap: string
    KonversiNilai?: KonversiNilaiCreateNestedManyWithoutAdminSiapInput
  }

  export type AdminSiapUncheckedCreateInput = {
    NIP_admin_siap: bigint | number
    nama_admin_siap: string
    KonversiNilai?: KonversiNilaiUncheckedCreateNestedManyWithoutAdminSiapInput
  }

  export type AdminSiapUpdateInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
    KonversiNilai?: KonversiNilaiUpdateManyWithoutAdminSiapNestedInput
  }

  export type AdminSiapUncheckedUpdateInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
    KonversiNilai?: KonversiNilaiUncheckedUpdateManyWithoutAdminSiapNestedInput
  }

  export type AdminSiapCreateManyInput = {
    NIP_admin_siap: bigint | number
    nama_admin_siap: string
  }

  export type AdminSiapUpdateManyMutationInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
  }

  export type AdminSiapUncheckedUpdateManyInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
  }

  export type BerkasPenilaianCreateInput = {
    nama_berkas: string
    PendaftaranMbkm: PendaftaranMbkmCreateNestedOneWithoutBerkasPenilaianInput
    KonversiNilai?: KonversiNilaiCreateNestedManyWithoutBerkasPenilaianInput
  }

  export type BerkasPenilaianUncheckedCreateInput = {
    id_berkas_penilaian?: number
    id_pendaftaran_mbkm: number
    nama_berkas: string
    KonversiNilai?: KonversiNilaiUncheckedCreateNestedManyWithoutBerkasPenilaianInput
  }

  export type BerkasPenilaianUpdateInput = {
    nama_berkas?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUpdateOneRequiredWithoutBerkasPenilaianNestedInput
    KonversiNilai?: KonversiNilaiUpdateManyWithoutBerkasPenilaianNestedInput
  }

  export type BerkasPenilaianUncheckedUpdateInput = {
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    nama_berkas?: StringFieldUpdateOperationsInput | string
    KonversiNilai?: KonversiNilaiUncheckedUpdateManyWithoutBerkasPenilaianNestedInput
  }

  export type BerkasPenilaianCreateManyInput = {
    id_berkas_penilaian?: number
    id_pendaftaran_mbkm: number
    nama_berkas: string
  }

  export type BerkasPenilaianUpdateManyMutationInput = {
    nama_berkas?: StringFieldUpdateOperationsInput | string
  }

  export type BerkasPenilaianUncheckedUpdateManyInput = {
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    nama_berkas?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesCreateInput = {
    id: string
    name: string
    ProgramMbkm?: ProgramMbkmCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id: string
    name: string
    ProgramMbkm?: ProgramMbkmUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ProgramMbkm?: ProgramMbkmUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ProgramMbkm?: ProgramMbkmUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesCreateManyInput = {
    id: string
    name: string
  }

  export type CategoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DosbingCreateInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    Mahasiswa?: MahasiswaCreateNestedManyWithoutDosbingInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutDosbingInput
  }

  export type DosbingUncheckedCreateInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    Mahasiswa?: MahasiswaUncheckedCreateNestedManyWithoutDosbingInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutDosbingInput
  }

  export type DosbingUpdateInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    Mahasiswa?: MahasiswaUpdateManyWithoutDosbingNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutDosbingNestedInput
  }

  export type DosbingUncheckedUpdateInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    Mahasiswa?: MahasiswaUncheckedUpdateManyWithoutDosbingNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutDosbingNestedInput
  }

  export type DosbingCreateManyInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
  }

  export type DosbingUpdateManyMutationInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
  }

  export type DosbingUncheckedUpdateManyInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiCreateInput = {
    nilai_akhir: number
    grade: string
    AdminSiap: AdminSiapCreateNestedOneWithoutKonversiNilaiInput
    BerkasPenilaian: BerkasPenilaianCreateNestedOneWithoutKonversiNilaiInput
  }

  export type KonversiNilaiUncheckedCreateInput = {
    id_konversi_nilai?: number
    NIP_admin_siap: bigint | number
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiUpdateInput = {
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    AdminSiap?: AdminSiapUpdateOneRequiredWithoutKonversiNilaiNestedInput
    BerkasPenilaian?: BerkasPenilaianUpdateOneRequiredWithoutKonversiNilaiNestedInput
  }

  export type KonversiNilaiUncheckedUpdateInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiCreateManyInput = {
    id_konversi_nilai?: number
    NIP_admin_siap: bigint | number
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiUpdateManyMutationInput = {
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiUncheckedUpdateManyInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KoorMbkmCreateInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutKoorMbkmInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmUncheckedCreateInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutKoorMbkmInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanUncheckedCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmUpdateInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutKoorMbkmNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUpdateManyWithoutKoorMbkmNestedInput
  }

  export type KoorMbkmUncheckedUpdateInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUncheckedUpdateManyWithoutKoorMbkmNestedInput
  }

  export type KoorMbkmCreateManyInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
  }

  export type KoorMbkmUpdateManyMutationInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
  }

  export type KoorMbkmUncheckedUpdateManyInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
  }

  export type MahasiswaCreateInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    ProgramMbkm: ProgramMbkmCreateNestedOneWithoutMahasiswaInput
    Dosbing: DosbingCreateNestedOneWithoutMahasiswaInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUncheckedCreateInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    NIP_dosbing: bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUpdateInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    ProgramMbkm?: ProgramMbkmUpdateOneRequiredWithoutMahasiswaNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutMahasiswaNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaCreateManyInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    NIP_dosbing: bigint | number
  }

  export type MahasiswaUpdateManyMutationInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
  }

  export type MahasiswaUncheckedUpdateManyInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PendaftaranAkunCreateInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranAkunInput
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranAkunInput
  }

  export type PendaftaranAkunUncheckedCreateInput = {
    id_pendaftaran_akun?: number
    NIM: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranAkunUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranAkunNestedInput
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranAkunNestedInput
  }

  export type PendaftaranAkunUncheckedUpdateInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunCreateManyInput = {
    id_pendaftaran_akun?: number
    NIM: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranAkunUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunUncheckedUpdateManyInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranMbkmCreateInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranMbkmInput
    Dosbing: DosbingCreateNestedOneWithoutPendaftaranMbkmInput
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranMbkmInput
    BerkasPenilaian?: BerkasPenilaianCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUncheckedCreateInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_dosbing: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    BerkasPenilaian?: BerkasPenilaianUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmCreateManyInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_dosbing: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranMbkmUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranMbkmUncheckedUpdateManyInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanCreateInput = {
    judul: string
    isi: string
    tanggal: Date | string
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPengumumanInput
  }

  export type PengumumanUncheckedCreateInput = {
    id_pengumuman?: number
    judul: string
    isi: string
    tanggal: Date | string
    NIP_koor_mbkm: bigint | number
  }

  export type PengumumanUpdateInput = {
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type PengumumanUncheckedUpdateInput = {
    id_pengumuman?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PengumumanCreateManyInput = {
    id_pengumuman?: number
    judul: string
    isi: string
    tanggal: Date | string
    NIP_koor_mbkm: bigint | number
  }

  export type PengumumanUpdateManyMutationInput = {
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyInput = {
    id_pengumuman?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramMbkmCreateInput = {
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    Categories: CategoriesCreateNestedOneWithoutProgramMbkmInput
    Mahasiswa?: MahasiswaCreateNestedManyWithoutProgramMbkmInput
  }

  export type ProgramMbkmUncheckedCreateInput = {
    id_program_mbkm?: number
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    category_id: string
    Mahasiswa?: MahasiswaUncheckedCreateNestedManyWithoutProgramMbkmInput
  }

  export type ProgramMbkmUpdateInput = {
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Categories?: CategoriesUpdateOneRequiredWithoutProgramMbkmNestedInput
    Mahasiswa?: MahasiswaUpdateManyWithoutProgramMbkmNestedInput
  }

  export type ProgramMbkmUncheckedUpdateInput = {
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    Mahasiswa?: MahasiswaUncheckedUpdateManyWithoutProgramMbkmNestedInput
  }

  export type ProgramMbkmCreateManyInput = {
    id_program_mbkm?: number
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    category_id: string
  }

  export type ProgramMbkmUpdateManyMutationInput = {
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramMbkmUncheckedUpdateManyInput = {
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role: $Enums.Role
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role: $Enums.Role
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type KonversiNilaiListRelationFilter = {
    every?: KonversiNilaiWhereInput
    some?: KonversiNilaiWhereInput
    none?: KonversiNilaiWhereInput
  }

  export type KonversiNilaiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminSiapCountOrderByAggregateInput = {
    NIP_admin_siap?: SortOrder
    nama_admin_siap?: SortOrder
  }

  export type AdminSiapAvgOrderByAggregateInput = {
    NIP_admin_siap?: SortOrder
  }

  export type AdminSiapMaxOrderByAggregateInput = {
    NIP_admin_siap?: SortOrder
    nama_admin_siap?: SortOrder
  }

  export type AdminSiapMinOrderByAggregateInput = {
    NIP_admin_siap?: SortOrder
    nama_admin_siap?: SortOrder
  }

  export type AdminSiapSumOrderByAggregateInput = {
    NIP_admin_siap?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PendaftaranMbkmRelationFilter = {
    is?: PendaftaranMbkmWhereInput
    isNot?: PendaftaranMbkmWhereInput
  }

  export type BerkasPenilaianCountOrderByAggregateInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
    nama_berkas?: SortOrder
  }

  export type BerkasPenilaianAvgOrderByAggregateInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
  }

  export type BerkasPenilaianMaxOrderByAggregateInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
    nama_berkas?: SortOrder
  }

  export type BerkasPenilaianMinOrderByAggregateInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
    nama_berkas?: SortOrder
  }

  export type BerkasPenilaianSumOrderByAggregateInput = {
    id_berkas_penilaian?: SortOrder
    id_pendaftaran_mbkm?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProgramMbkmListRelationFilter = {
    every?: ProgramMbkmWhereInput
    some?: ProgramMbkmWhereInput
    none?: ProgramMbkmWhereInput
  }

  export type ProgramMbkmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MahasiswaListRelationFilter = {
    every?: MahasiswaWhereInput
    some?: MahasiswaWhereInput
    none?: MahasiswaWhereInput
  }

  export type PendaftaranMbkmListRelationFilter = {
    every?: PendaftaranMbkmWhereInput
    some?: PendaftaranMbkmWhereInput
    none?: PendaftaranMbkmWhereInput
  }

  export type MahasiswaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendaftaranMbkmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DosbingCountOrderByAggregateInput = {
    NIP_dosbing?: SortOrder
    nama_dosbing?: SortOrder
  }

  export type DosbingAvgOrderByAggregateInput = {
    NIP_dosbing?: SortOrder
  }

  export type DosbingMaxOrderByAggregateInput = {
    NIP_dosbing?: SortOrder
    nama_dosbing?: SortOrder
  }

  export type DosbingMinOrderByAggregateInput = {
    NIP_dosbing?: SortOrder
    nama_dosbing?: SortOrder
  }

  export type DosbingSumOrderByAggregateInput = {
    NIP_dosbing?: SortOrder
  }

  export type AdminSiapRelationFilter = {
    is?: AdminSiapWhereInput
    isNot?: AdminSiapWhereInput
  }

  export type BerkasPenilaianRelationFilter = {
    is?: BerkasPenilaianWhereInput
    isNot?: BerkasPenilaianWhereInput
  }

  export type KonversiNilaiCountOrderByAggregateInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
    grade?: SortOrder
  }

  export type KonversiNilaiAvgOrderByAggregateInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
  }

  export type KonversiNilaiMaxOrderByAggregateInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
    grade?: SortOrder
  }

  export type KonversiNilaiMinOrderByAggregateInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
    grade?: SortOrder
  }

  export type KonversiNilaiSumOrderByAggregateInput = {
    id_konversi_nilai?: SortOrder
    NIP_admin_siap?: SortOrder
    id_berkas_penilaian?: SortOrder
    nilai_akhir?: SortOrder
  }

  export type PendaftaranAkunListRelationFilter = {
    every?: PendaftaranAkunWhereInput
    some?: PendaftaranAkunWhereInput
    none?: PendaftaranAkunWhereInput
  }

  export type PengumumanListRelationFilter = {
    every?: PengumumanWhereInput
    some?: PengumumanWhereInput
    none?: PengumumanWhereInput
  }

  export type PendaftaranAkunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PengumumanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KoorMbkmCountOrderByAggregateInput = {
    NIP_koor_mbkm?: SortOrder
    nama_koor_mbkm?: SortOrder
  }

  export type KoorMbkmAvgOrderByAggregateInput = {
    NIP_koor_mbkm?: SortOrder
  }

  export type KoorMbkmMaxOrderByAggregateInput = {
    NIP_koor_mbkm?: SortOrder
    nama_koor_mbkm?: SortOrder
  }

  export type KoorMbkmMinOrderByAggregateInput = {
    NIP_koor_mbkm?: SortOrder
    nama_koor_mbkm?: SortOrder
  }

  export type KoorMbkmSumOrderByAggregateInput = {
    NIP_koor_mbkm?: SortOrder
  }

  export type ProgramMbkmRelationFilter = {
    is?: ProgramMbkmWhereInput
    isNot?: ProgramMbkmWhereInput
  }

  export type DosbingRelationFilter = {
    is?: DosbingWhereInput
    isNot?: DosbingWhereInput
  }

  export type MahasiswaCountOrderByAggregateInput = {
    NIM?: SortOrder
    nama_mahasiswa?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
  }

  export type MahasiswaAvgOrderByAggregateInput = {
    NIM?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
  }

  export type MahasiswaMaxOrderByAggregateInput = {
    NIM?: SortOrder
    nama_mahasiswa?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
  }

  export type MahasiswaMinOrderByAggregateInput = {
    NIM?: SortOrder
    nama_mahasiswa?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
  }

  export type MahasiswaSumOrderByAggregateInput = {
    NIM?: SortOrder
    semester?: SortOrder
    id_program_mbkm?: SortOrder
    NIP_dosbing?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MahasiswaRelationFilter = {
    is?: MahasiswaWhereInput
    isNot?: MahasiswaWhereInput
  }

  export type KoorMbkmRelationFilter = {
    is?: KoorMbkmWhereInput
    isNot?: KoorMbkmWhereInput
  }

  export type PendaftaranAkunCountOrderByAggregateInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranAkunAvgOrderByAggregateInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PendaftaranAkunMaxOrderByAggregateInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranAkunMinOrderByAggregateInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranAkunSumOrderByAggregateInput = {
    id_pendaftaran_akun?: SortOrder
    NIM?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BerkasPenilaianListRelationFilter = {
    every?: BerkasPenilaianWhereInput
    some?: BerkasPenilaianWhereInput
    none?: BerkasPenilaianWhereInput
  }

  export type BerkasPenilaianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendaftaranMbkmCountOrderByAggregateInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranMbkmAvgOrderByAggregateInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PendaftaranMbkmMaxOrderByAggregateInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranMbkmMinOrderByAggregateInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
    tanggal?: SortOrder
  }

  export type PendaftaranMbkmSumOrderByAggregateInput = {
    id_pendaftaran_mbkm?: SortOrder
    NIM?: SortOrder
    NIP_dosbing?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PengumumanCountOrderByAggregateInput = {
    id_pengumuman?: SortOrder
    judul?: SortOrder
    isi?: SortOrder
    tanggal?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PengumumanAvgOrderByAggregateInput = {
    id_pengumuman?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PengumumanMaxOrderByAggregateInput = {
    id_pengumuman?: SortOrder
    judul?: SortOrder
    isi?: SortOrder
    tanggal?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PengumumanMinOrderByAggregateInput = {
    id_pengumuman?: SortOrder
    judul?: SortOrder
    isi?: SortOrder
    tanggal?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type PengumumanSumOrderByAggregateInput = {
    id_pengumuman?: SortOrder
    NIP_koor_mbkm?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CategoriesRelationFilter = {
    is?: CategoriesWhereInput
    isNot?: CategoriesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProgramMbkmCountOrderByAggregateInput = {
    id_program_mbkm?: SortOrder
    company?: SortOrder
    deskripsi?: SortOrder
    role?: SortOrder
    status?: SortOrder
    date?: SortOrder
    category_id?: SortOrder
  }

  export type ProgramMbkmAvgOrderByAggregateInput = {
    id_program_mbkm?: SortOrder
  }

  export type ProgramMbkmMaxOrderByAggregateInput = {
    id_program_mbkm?: SortOrder
    company?: SortOrder
    deskripsi?: SortOrder
    role?: SortOrder
    status?: SortOrder
    date?: SortOrder
    category_id?: SortOrder
  }

  export type ProgramMbkmMinOrderByAggregateInput = {
    id_program_mbkm?: SortOrder
    company?: SortOrder
    deskripsi?: SortOrder
    role?: SortOrder
    status?: SortOrder
    date?: SortOrder
    category_id?: SortOrder
  }

  export type ProgramMbkmSumOrderByAggregateInput = {
    id_program_mbkm?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type KonversiNilaiCreateNestedManyWithoutAdminSiapInput = {
    create?: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput> | KonversiNilaiCreateWithoutAdminSiapInput[] | KonversiNilaiUncheckedCreateWithoutAdminSiapInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutAdminSiapInput | KonversiNilaiCreateOrConnectWithoutAdminSiapInput[]
    createMany?: KonversiNilaiCreateManyAdminSiapInputEnvelope
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
  }

  export type KonversiNilaiUncheckedCreateNestedManyWithoutAdminSiapInput = {
    create?: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput> | KonversiNilaiCreateWithoutAdminSiapInput[] | KonversiNilaiUncheckedCreateWithoutAdminSiapInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutAdminSiapInput | KonversiNilaiCreateOrConnectWithoutAdminSiapInput[]
    createMany?: KonversiNilaiCreateManyAdminSiapInputEnvelope
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type KonversiNilaiUpdateManyWithoutAdminSiapNestedInput = {
    create?: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput> | KonversiNilaiCreateWithoutAdminSiapInput[] | KonversiNilaiUncheckedCreateWithoutAdminSiapInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutAdminSiapInput | KonversiNilaiCreateOrConnectWithoutAdminSiapInput[]
    upsert?: KonversiNilaiUpsertWithWhereUniqueWithoutAdminSiapInput | KonversiNilaiUpsertWithWhereUniqueWithoutAdminSiapInput[]
    createMany?: KonversiNilaiCreateManyAdminSiapInputEnvelope
    set?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    disconnect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    delete?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    update?: KonversiNilaiUpdateWithWhereUniqueWithoutAdminSiapInput | KonversiNilaiUpdateWithWhereUniqueWithoutAdminSiapInput[]
    updateMany?: KonversiNilaiUpdateManyWithWhereWithoutAdminSiapInput | KonversiNilaiUpdateManyWithWhereWithoutAdminSiapInput[]
    deleteMany?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
  }

  export type KonversiNilaiUncheckedUpdateManyWithoutAdminSiapNestedInput = {
    create?: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput> | KonversiNilaiCreateWithoutAdminSiapInput[] | KonversiNilaiUncheckedCreateWithoutAdminSiapInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutAdminSiapInput | KonversiNilaiCreateOrConnectWithoutAdminSiapInput[]
    upsert?: KonversiNilaiUpsertWithWhereUniqueWithoutAdminSiapInput | KonversiNilaiUpsertWithWhereUniqueWithoutAdminSiapInput[]
    createMany?: KonversiNilaiCreateManyAdminSiapInputEnvelope
    set?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    disconnect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    delete?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    update?: KonversiNilaiUpdateWithWhereUniqueWithoutAdminSiapInput | KonversiNilaiUpdateWithWhereUniqueWithoutAdminSiapInput[]
    updateMany?: KonversiNilaiUpdateManyWithWhereWithoutAdminSiapInput | KonversiNilaiUpdateManyWithWhereWithoutAdminSiapInput[]
    deleteMany?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
  }

  export type PendaftaranMbkmCreateNestedOneWithoutBerkasPenilaianInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedCreateWithoutBerkasPenilaianInput>
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutBerkasPenilaianInput
    connect?: PendaftaranMbkmWhereUniqueInput
  }

  export type KonversiNilaiCreateNestedManyWithoutBerkasPenilaianInput = {
    create?: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput> | KonversiNilaiCreateWithoutBerkasPenilaianInput[] | KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput | KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput[]
    createMany?: KonversiNilaiCreateManyBerkasPenilaianInputEnvelope
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
  }

  export type KonversiNilaiUncheckedCreateNestedManyWithoutBerkasPenilaianInput = {
    create?: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput> | KonversiNilaiCreateWithoutBerkasPenilaianInput[] | KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput | KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput[]
    createMany?: KonversiNilaiCreateManyBerkasPenilaianInputEnvelope
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
  }

  export type PendaftaranMbkmUpdateOneRequiredWithoutBerkasPenilaianNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedCreateWithoutBerkasPenilaianInput>
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutBerkasPenilaianInput
    upsert?: PendaftaranMbkmUpsertWithoutBerkasPenilaianInput
    connect?: PendaftaranMbkmWhereUniqueInput
    update?: XOR<XOR<PendaftaranMbkmUpdateToOneWithWhereWithoutBerkasPenilaianInput, PendaftaranMbkmUpdateWithoutBerkasPenilaianInput>, PendaftaranMbkmUncheckedUpdateWithoutBerkasPenilaianInput>
  }

  export type KonversiNilaiUpdateManyWithoutBerkasPenilaianNestedInput = {
    create?: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput> | KonversiNilaiCreateWithoutBerkasPenilaianInput[] | KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput | KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput[]
    upsert?: KonversiNilaiUpsertWithWhereUniqueWithoutBerkasPenilaianInput | KonversiNilaiUpsertWithWhereUniqueWithoutBerkasPenilaianInput[]
    createMany?: KonversiNilaiCreateManyBerkasPenilaianInputEnvelope
    set?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    disconnect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    delete?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    update?: KonversiNilaiUpdateWithWhereUniqueWithoutBerkasPenilaianInput | KonversiNilaiUpdateWithWhereUniqueWithoutBerkasPenilaianInput[]
    updateMany?: KonversiNilaiUpdateManyWithWhereWithoutBerkasPenilaianInput | KonversiNilaiUpdateManyWithWhereWithoutBerkasPenilaianInput[]
    deleteMany?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KonversiNilaiUncheckedUpdateManyWithoutBerkasPenilaianNestedInput = {
    create?: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput> | KonversiNilaiCreateWithoutBerkasPenilaianInput[] | KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput[]
    connectOrCreate?: KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput | KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput[]
    upsert?: KonversiNilaiUpsertWithWhereUniqueWithoutBerkasPenilaianInput | KonversiNilaiUpsertWithWhereUniqueWithoutBerkasPenilaianInput[]
    createMany?: KonversiNilaiCreateManyBerkasPenilaianInputEnvelope
    set?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    disconnect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    delete?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    connect?: KonversiNilaiWhereUniqueInput | KonversiNilaiWhereUniqueInput[]
    update?: KonversiNilaiUpdateWithWhereUniqueWithoutBerkasPenilaianInput | KonversiNilaiUpdateWithWhereUniqueWithoutBerkasPenilaianInput[]
    updateMany?: KonversiNilaiUpdateManyWithWhereWithoutBerkasPenilaianInput | KonversiNilaiUpdateManyWithWhereWithoutBerkasPenilaianInput[]
    deleteMany?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
  }

  export type ProgramMbkmCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput> | ProgramMbkmCreateWithoutCategoriesInput[] | ProgramMbkmUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutCategoriesInput | ProgramMbkmCreateOrConnectWithoutCategoriesInput[]
    createMany?: ProgramMbkmCreateManyCategoriesInputEnvelope
    connect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
  }

  export type ProgramMbkmUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput> | ProgramMbkmCreateWithoutCategoriesInput[] | ProgramMbkmUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutCategoriesInput | ProgramMbkmCreateOrConnectWithoutCategoriesInput[]
    createMany?: ProgramMbkmCreateManyCategoriesInputEnvelope
    connect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
  }

  export type ProgramMbkmUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput> | ProgramMbkmCreateWithoutCategoriesInput[] | ProgramMbkmUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutCategoriesInput | ProgramMbkmCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProgramMbkmUpsertWithWhereUniqueWithoutCategoriesInput | ProgramMbkmUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ProgramMbkmCreateManyCategoriesInputEnvelope
    set?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    disconnect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    delete?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    connect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    update?: ProgramMbkmUpdateWithWhereUniqueWithoutCategoriesInput | ProgramMbkmUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProgramMbkmUpdateManyWithWhereWithoutCategoriesInput | ProgramMbkmUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProgramMbkmScalarWhereInput | ProgramMbkmScalarWhereInput[]
  }

  export type ProgramMbkmUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput> | ProgramMbkmCreateWithoutCategoriesInput[] | ProgramMbkmUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutCategoriesInput | ProgramMbkmCreateOrConnectWithoutCategoriesInput[]
    upsert?: ProgramMbkmUpsertWithWhereUniqueWithoutCategoriesInput | ProgramMbkmUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: ProgramMbkmCreateManyCategoriesInputEnvelope
    set?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    disconnect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    delete?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    connect?: ProgramMbkmWhereUniqueInput | ProgramMbkmWhereUniqueInput[]
    update?: ProgramMbkmUpdateWithWhereUniqueWithoutCategoriesInput | ProgramMbkmUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: ProgramMbkmUpdateManyWithWhereWithoutCategoriesInput | ProgramMbkmUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: ProgramMbkmScalarWhereInput | ProgramMbkmScalarWhereInput[]
  }

  export type MahasiswaCreateNestedManyWithoutDosbingInput = {
    create?: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput> | MahasiswaCreateWithoutDosbingInput[] | MahasiswaUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutDosbingInput | MahasiswaCreateOrConnectWithoutDosbingInput[]
    createMany?: MahasiswaCreateManyDosbingInputEnvelope
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
  }

  export type PendaftaranMbkmCreateNestedManyWithoutDosbingInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput> | PendaftaranMbkmCreateWithoutDosbingInput[] | PendaftaranMbkmUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutDosbingInput | PendaftaranMbkmCreateOrConnectWithoutDosbingInput[]
    createMany?: PendaftaranMbkmCreateManyDosbingInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type MahasiswaUncheckedCreateNestedManyWithoutDosbingInput = {
    create?: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput> | MahasiswaCreateWithoutDosbingInput[] | MahasiswaUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutDosbingInput | MahasiswaCreateOrConnectWithoutDosbingInput[]
    createMany?: MahasiswaCreateManyDosbingInputEnvelope
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
  }

  export type PendaftaranMbkmUncheckedCreateNestedManyWithoutDosbingInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput> | PendaftaranMbkmCreateWithoutDosbingInput[] | PendaftaranMbkmUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutDosbingInput | PendaftaranMbkmCreateOrConnectWithoutDosbingInput[]
    createMany?: PendaftaranMbkmCreateManyDosbingInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type MahasiswaUpdateManyWithoutDosbingNestedInput = {
    create?: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput> | MahasiswaCreateWithoutDosbingInput[] | MahasiswaUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutDosbingInput | MahasiswaCreateOrConnectWithoutDosbingInput[]
    upsert?: MahasiswaUpsertWithWhereUniqueWithoutDosbingInput | MahasiswaUpsertWithWhereUniqueWithoutDosbingInput[]
    createMany?: MahasiswaCreateManyDosbingInputEnvelope
    set?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    disconnect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    delete?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    update?: MahasiswaUpdateWithWhereUniqueWithoutDosbingInput | MahasiswaUpdateWithWhereUniqueWithoutDosbingInput[]
    updateMany?: MahasiswaUpdateManyWithWhereWithoutDosbingInput | MahasiswaUpdateManyWithWhereWithoutDosbingInput[]
    deleteMany?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
  }

  export type PendaftaranMbkmUpdateManyWithoutDosbingNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput> | PendaftaranMbkmCreateWithoutDosbingInput[] | PendaftaranMbkmUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutDosbingInput | PendaftaranMbkmCreateOrConnectWithoutDosbingInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutDosbingInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutDosbingInput[]
    createMany?: PendaftaranMbkmCreateManyDosbingInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutDosbingInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutDosbingInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutDosbingInput | PendaftaranMbkmUpdateManyWithWhereWithoutDosbingInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type MahasiswaUncheckedUpdateManyWithoutDosbingNestedInput = {
    create?: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput> | MahasiswaCreateWithoutDosbingInput[] | MahasiswaUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutDosbingInput | MahasiswaCreateOrConnectWithoutDosbingInput[]
    upsert?: MahasiswaUpsertWithWhereUniqueWithoutDosbingInput | MahasiswaUpsertWithWhereUniqueWithoutDosbingInput[]
    createMany?: MahasiswaCreateManyDosbingInputEnvelope
    set?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    disconnect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    delete?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    update?: MahasiswaUpdateWithWhereUniqueWithoutDosbingInput | MahasiswaUpdateWithWhereUniqueWithoutDosbingInput[]
    updateMany?: MahasiswaUpdateManyWithWhereWithoutDosbingInput | MahasiswaUpdateManyWithWhereWithoutDosbingInput[]
    deleteMany?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutDosbingNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput> | PendaftaranMbkmCreateWithoutDosbingInput[] | PendaftaranMbkmUncheckedCreateWithoutDosbingInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutDosbingInput | PendaftaranMbkmCreateOrConnectWithoutDosbingInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutDosbingInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutDosbingInput[]
    createMany?: PendaftaranMbkmCreateManyDosbingInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutDosbingInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutDosbingInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutDosbingInput | PendaftaranMbkmUpdateManyWithWhereWithoutDosbingInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type AdminSiapCreateNestedOneWithoutKonversiNilaiInput = {
    create?: XOR<AdminSiapCreateWithoutKonversiNilaiInput, AdminSiapUncheckedCreateWithoutKonversiNilaiInput>
    connectOrCreate?: AdminSiapCreateOrConnectWithoutKonversiNilaiInput
    connect?: AdminSiapWhereUniqueInput
  }

  export type BerkasPenilaianCreateNestedOneWithoutKonversiNilaiInput = {
    create?: XOR<BerkasPenilaianCreateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedCreateWithoutKonversiNilaiInput>
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutKonversiNilaiInput
    connect?: BerkasPenilaianWhereUniqueInput
  }

  export type AdminSiapUpdateOneRequiredWithoutKonversiNilaiNestedInput = {
    create?: XOR<AdminSiapCreateWithoutKonversiNilaiInput, AdminSiapUncheckedCreateWithoutKonversiNilaiInput>
    connectOrCreate?: AdminSiapCreateOrConnectWithoutKonversiNilaiInput
    upsert?: AdminSiapUpsertWithoutKonversiNilaiInput
    connect?: AdminSiapWhereUniqueInput
    update?: XOR<XOR<AdminSiapUpdateToOneWithWhereWithoutKonversiNilaiInput, AdminSiapUpdateWithoutKonversiNilaiInput>, AdminSiapUncheckedUpdateWithoutKonversiNilaiInput>
  }

  export type BerkasPenilaianUpdateOneRequiredWithoutKonversiNilaiNestedInput = {
    create?: XOR<BerkasPenilaianCreateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedCreateWithoutKonversiNilaiInput>
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutKonversiNilaiInput
    upsert?: BerkasPenilaianUpsertWithoutKonversiNilaiInput
    connect?: BerkasPenilaianWhereUniqueInput
    update?: XOR<XOR<BerkasPenilaianUpdateToOneWithWhereWithoutKonversiNilaiInput, BerkasPenilaianUpdateWithoutKonversiNilaiInput>, BerkasPenilaianUncheckedUpdateWithoutKonversiNilaiInput>
  }

  export type PendaftaranAkunCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput> | PendaftaranAkunCreateWithoutKoorMbkmInput[] | PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput | PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PendaftaranAkunCreateManyKoorMbkmInputEnvelope
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
  }

  export type PendaftaranMbkmCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput> | PendaftaranMbkmCreateWithoutKoorMbkmInput[] | PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput | PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PendaftaranMbkmCreateManyKoorMbkmInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type PengumumanCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput> | PengumumanCreateWithoutKoorMbkmInput[] | PengumumanUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutKoorMbkmInput | PengumumanCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PengumumanCreateManyKoorMbkmInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type PendaftaranAkunUncheckedCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput> | PendaftaranAkunCreateWithoutKoorMbkmInput[] | PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput | PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PendaftaranAkunCreateManyKoorMbkmInputEnvelope
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
  }

  export type PendaftaranMbkmUncheckedCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput> | PendaftaranMbkmCreateWithoutKoorMbkmInput[] | PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput | PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PendaftaranMbkmCreateManyKoorMbkmInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type PengumumanUncheckedCreateNestedManyWithoutKoorMbkmInput = {
    create?: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput> | PengumumanCreateWithoutKoorMbkmInput[] | PengumumanUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutKoorMbkmInput | PengumumanCreateOrConnectWithoutKoorMbkmInput[]
    createMany?: PengumumanCreateManyKoorMbkmInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type PendaftaranAkunUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput> | PendaftaranAkunCreateWithoutKoorMbkmInput[] | PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput | PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PendaftaranAkunUpsertWithWhereUniqueWithoutKoorMbkmInput | PendaftaranAkunUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PendaftaranAkunCreateManyKoorMbkmInputEnvelope
    set?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    disconnect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    delete?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    update?: PendaftaranAkunUpdateWithWhereUniqueWithoutKoorMbkmInput | PendaftaranAkunUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PendaftaranAkunUpdateManyWithWhereWithoutKoorMbkmInput | PendaftaranAkunUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
  }

  export type PendaftaranMbkmUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput> | PendaftaranMbkmCreateWithoutKoorMbkmInput[] | PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput | PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutKoorMbkmInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PendaftaranMbkmCreateManyKoorMbkmInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutKoorMbkmInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutKoorMbkmInput | PendaftaranMbkmUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type PengumumanUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput> | PengumumanCreateWithoutKoorMbkmInput[] | PengumumanUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutKoorMbkmInput | PengumumanCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutKoorMbkmInput | PengumumanUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PengumumanCreateManyKoorMbkmInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutKoorMbkmInput | PengumumanUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutKoorMbkmInput | PengumumanUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput> | PendaftaranAkunCreateWithoutKoorMbkmInput[] | PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput | PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PendaftaranAkunUpsertWithWhereUniqueWithoutKoorMbkmInput | PendaftaranAkunUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PendaftaranAkunCreateManyKoorMbkmInputEnvelope
    set?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    disconnect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    delete?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    update?: PendaftaranAkunUpdateWithWhereUniqueWithoutKoorMbkmInput | PendaftaranAkunUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PendaftaranAkunUpdateManyWithWhereWithoutKoorMbkmInput | PendaftaranAkunUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput> | PendaftaranMbkmCreateWithoutKoorMbkmInput[] | PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput | PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutKoorMbkmInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PendaftaranMbkmCreateManyKoorMbkmInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutKoorMbkmInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutKoorMbkmInput | PendaftaranMbkmUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type PengumumanUncheckedUpdateManyWithoutKoorMbkmNestedInput = {
    create?: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput> | PengumumanCreateWithoutKoorMbkmInput[] | PengumumanUncheckedCreateWithoutKoorMbkmInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutKoorMbkmInput | PengumumanCreateOrConnectWithoutKoorMbkmInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutKoorMbkmInput | PengumumanUpsertWithWhereUniqueWithoutKoorMbkmInput[]
    createMany?: PengumumanCreateManyKoorMbkmInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutKoorMbkmInput | PengumumanUpdateWithWhereUniqueWithoutKoorMbkmInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutKoorMbkmInput | PengumumanUpdateManyWithWhereWithoutKoorMbkmInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type ProgramMbkmCreateNestedOneWithoutMahasiswaInput = {
    create?: XOR<ProgramMbkmCreateWithoutMahasiswaInput, ProgramMbkmUncheckedCreateWithoutMahasiswaInput>
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutMahasiswaInput
    connect?: ProgramMbkmWhereUniqueInput
  }

  export type DosbingCreateNestedOneWithoutMahasiswaInput = {
    create?: XOR<DosbingCreateWithoutMahasiswaInput, DosbingUncheckedCreateWithoutMahasiswaInput>
    connectOrCreate?: DosbingCreateOrConnectWithoutMahasiswaInput
    connect?: DosbingWhereUniqueInput
  }

  export type PendaftaranMbkmCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput> | PendaftaranMbkmCreateWithoutMahasiswaInput[] | PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput | PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PendaftaranMbkmCreateManyMahasiswaInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type PendaftaranAkunCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput> | PendaftaranAkunCreateWithoutMahasiswaInput[] | PendaftaranAkunUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutMahasiswaInput | PendaftaranAkunCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PendaftaranAkunCreateManyMahasiswaInputEnvelope
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
  }

  export type PendaftaranMbkmUncheckedCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput> | PendaftaranMbkmCreateWithoutMahasiswaInput[] | PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput | PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PendaftaranMbkmCreateManyMahasiswaInputEnvelope
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
  }

  export type PendaftaranAkunUncheckedCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput> | PendaftaranAkunCreateWithoutMahasiswaInput[] | PendaftaranAkunUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutMahasiswaInput | PendaftaranAkunCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PendaftaranAkunCreateManyMahasiswaInputEnvelope
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
  }

  export type ProgramMbkmUpdateOneRequiredWithoutMahasiswaNestedInput = {
    create?: XOR<ProgramMbkmCreateWithoutMahasiswaInput, ProgramMbkmUncheckedCreateWithoutMahasiswaInput>
    connectOrCreate?: ProgramMbkmCreateOrConnectWithoutMahasiswaInput
    upsert?: ProgramMbkmUpsertWithoutMahasiswaInput
    connect?: ProgramMbkmWhereUniqueInput
    update?: XOR<XOR<ProgramMbkmUpdateToOneWithWhereWithoutMahasiswaInput, ProgramMbkmUpdateWithoutMahasiswaInput>, ProgramMbkmUncheckedUpdateWithoutMahasiswaInput>
  }

  export type DosbingUpdateOneRequiredWithoutMahasiswaNestedInput = {
    create?: XOR<DosbingCreateWithoutMahasiswaInput, DosbingUncheckedCreateWithoutMahasiswaInput>
    connectOrCreate?: DosbingCreateOrConnectWithoutMahasiswaInput
    upsert?: DosbingUpsertWithoutMahasiswaInput
    connect?: DosbingWhereUniqueInput
    update?: XOR<XOR<DosbingUpdateToOneWithWhereWithoutMahasiswaInput, DosbingUpdateWithoutMahasiswaInput>, DosbingUncheckedUpdateWithoutMahasiswaInput>
  }

  export type PendaftaranMbkmUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput> | PendaftaranMbkmCreateWithoutMahasiswaInput[] | PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput | PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutMahasiswaInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PendaftaranMbkmCreateManyMahasiswaInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutMahasiswaInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutMahasiswaInput | PendaftaranMbkmUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type PendaftaranAkunUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput> | PendaftaranAkunCreateWithoutMahasiswaInput[] | PendaftaranAkunUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutMahasiswaInput | PendaftaranAkunCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PendaftaranAkunUpsertWithWhereUniqueWithoutMahasiswaInput | PendaftaranAkunUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PendaftaranAkunCreateManyMahasiswaInputEnvelope
    set?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    disconnect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    delete?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    update?: PendaftaranAkunUpdateWithWhereUniqueWithoutMahasiswaInput | PendaftaranAkunUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PendaftaranAkunUpdateManyWithWhereWithoutMahasiswaInput | PendaftaranAkunUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput> | PendaftaranMbkmCreateWithoutMahasiswaInput[] | PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput | PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PendaftaranMbkmUpsertWithWhereUniqueWithoutMahasiswaInput | PendaftaranMbkmUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PendaftaranMbkmCreateManyMahasiswaInputEnvelope
    set?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    disconnect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    delete?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    connect?: PendaftaranMbkmWhereUniqueInput | PendaftaranMbkmWhereUniqueInput[]
    update?: PendaftaranMbkmUpdateWithWhereUniqueWithoutMahasiswaInput | PendaftaranMbkmUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PendaftaranMbkmUpdateManyWithWhereWithoutMahasiswaInput | PendaftaranMbkmUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
  }

  export type PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput> | PendaftaranAkunCreateWithoutMahasiswaInput[] | PendaftaranAkunUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PendaftaranAkunCreateOrConnectWithoutMahasiswaInput | PendaftaranAkunCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PendaftaranAkunUpsertWithWhereUniqueWithoutMahasiswaInput | PendaftaranAkunUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PendaftaranAkunCreateManyMahasiswaInputEnvelope
    set?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    disconnect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    delete?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    connect?: PendaftaranAkunWhereUniqueInput | PendaftaranAkunWhereUniqueInput[]
    update?: PendaftaranAkunUpdateWithWhereUniqueWithoutMahasiswaInput | PendaftaranAkunUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PendaftaranAkunUpdateManyWithWhereWithoutMahasiswaInput | PendaftaranAkunUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
  }

  export type MahasiswaCreateNestedOneWithoutPendaftaranAkunInput = {
    create?: XOR<MahasiswaCreateWithoutPendaftaranAkunInput, MahasiswaUncheckedCreateWithoutPendaftaranAkunInput>
    connectOrCreate?: MahasiswaCreateOrConnectWithoutPendaftaranAkunInput
    connect?: MahasiswaWhereUniqueInput
  }

  export type KoorMbkmCreateNestedOneWithoutPendaftaranAkunInput = {
    create?: XOR<KoorMbkmCreateWithoutPendaftaranAkunInput, KoorMbkmUncheckedCreateWithoutPendaftaranAkunInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPendaftaranAkunInput
    connect?: KoorMbkmWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MahasiswaUpdateOneRequiredWithoutPendaftaranAkunNestedInput = {
    create?: XOR<MahasiswaCreateWithoutPendaftaranAkunInput, MahasiswaUncheckedCreateWithoutPendaftaranAkunInput>
    connectOrCreate?: MahasiswaCreateOrConnectWithoutPendaftaranAkunInput
    upsert?: MahasiswaUpsertWithoutPendaftaranAkunInput
    connect?: MahasiswaWhereUniqueInput
    update?: XOR<XOR<MahasiswaUpdateToOneWithWhereWithoutPendaftaranAkunInput, MahasiswaUpdateWithoutPendaftaranAkunInput>, MahasiswaUncheckedUpdateWithoutPendaftaranAkunInput>
  }

  export type KoorMbkmUpdateOneRequiredWithoutPendaftaranAkunNestedInput = {
    create?: XOR<KoorMbkmCreateWithoutPendaftaranAkunInput, KoorMbkmUncheckedCreateWithoutPendaftaranAkunInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPendaftaranAkunInput
    upsert?: KoorMbkmUpsertWithoutPendaftaranAkunInput
    connect?: KoorMbkmWhereUniqueInput
    update?: XOR<XOR<KoorMbkmUpdateToOneWithWhereWithoutPendaftaranAkunInput, KoorMbkmUpdateWithoutPendaftaranAkunInput>, KoorMbkmUncheckedUpdateWithoutPendaftaranAkunInput>
  }

  export type MahasiswaCreateNestedOneWithoutPendaftaranMbkmInput = {
    create?: XOR<MahasiswaCreateWithoutPendaftaranMbkmInput, MahasiswaUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: MahasiswaCreateOrConnectWithoutPendaftaranMbkmInput
    connect?: MahasiswaWhereUniqueInput
  }

  export type DosbingCreateNestedOneWithoutPendaftaranMbkmInput = {
    create?: XOR<DosbingCreateWithoutPendaftaranMbkmInput, DosbingUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: DosbingCreateOrConnectWithoutPendaftaranMbkmInput
    connect?: DosbingWhereUniqueInput
  }

  export type KoorMbkmCreateNestedOneWithoutPendaftaranMbkmInput = {
    create?: XOR<KoorMbkmCreateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPendaftaranMbkmInput
    connect?: KoorMbkmWhereUniqueInput
  }

  export type BerkasPenilaianCreateNestedManyWithoutPendaftaranMbkmInput = {
    create?: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput> | BerkasPenilaianCreateWithoutPendaftaranMbkmInput[] | BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput[]
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput | BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput[]
    createMany?: BerkasPenilaianCreateManyPendaftaranMbkmInputEnvelope
    connect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
  }

  export type BerkasPenilaianUncheckedCreateNestedManyWithoutPendaftaranMbkmInput = {
    create?: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput> | BerkasPenilaianCreateWithoutPendaftaranMbkmInput[] | BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput[]
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput | BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput[]
    createMany?: BerkasPenilaianCreateManyPendaftaranMbkmInputEnvelope
    connect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
  }

  export type MahasiswaUpdateOneRequiredWithoutPendaftaranMbkmNestedInput = {
    create?: XOR<MahasiswaCreateWithoutPendaftaranMbkmInput, MahasiswaUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: MahasiswaCreateOrConnectWithoutPendaftaranMbkmInput
    upsert?: MahasiswaUpsertWithoutPendaftaranMbkmInput
    connect?: MahasiswaWhereUniqueInput
    update?: XOR<XOR<MahasiswaUpdateToOneWithWhereWithoutPendaftaranMbkmInput, MahasiswaUpdateWithoutPendaftaranMbkmInput>, MahasiswaUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type DosbingUpdateOneRequiredWithoutPendaftaranMbkmNestedInput = {
    create?: XOR<DosbingCreateWithoutPendaftaranMbkmInput, DosbingUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: DosbingCreateOrConnectWithoutPendaftaranMbkmInput
    upsert?: DosbingUpsertWithoutPendaftaranMbkmInput
    connect?: DosbingWhereUniqueInput
    update?: XOR<XOR<DosbingUpdateToOneWithWhereWithoutPendaftaranMbkmInput, DosbingUpdateWithoutPendaftaranMbkmInput>, DosbingUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type KoorMbkmUpdateOneRequiredWithoutPendaftaranMbkmNestedInput = {
    create?: XOR<KoorMbkmCreateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedCreateWithoutPendaftaranMbkmInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPendaftaranMbkmInput
    upsert?: KoorMbkmUpsertWithoutPendaftaranMbkmInput
    connect?: KoorMbkmWhereUniqueInput
    update?: XOR<XOR<KoorMbkmUpdateToOneWithWhereWithoutPendaftaranMbkmInput, KoorMbkmUpdateWithoutPendaftaranMbkmInput>, KoorMbkmUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianUpdateManyWithoutPendaftaranMbkmNestedInput = {
    create?: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput> | BerkasPenilaianCreateWithoutPendaftaranMbkmInput[] | BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput[]
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput | BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput[]
    upsert?: BerkasPenilaianUpsertWithWhereUniqueWithoutPendaftaranMbkmInput | BerkasPenilaianUpsertWithWhereUniqueWithoutPendaftaranMbkmInput[]
    createMany?: BerkasPenilaianCreateManyPendaftaranMbkmInputEnvelope
    set?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    disconnect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    delete?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    connect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    update?: BerkasPenilaianUpdateWithWhereUniqueWithoutPendaftaranMbkmInput | BerkasPenilaianUpdateWithWhereUniqueWithoutPendaftaranMbkmInput[]
    updateMany?: BerkasPenilaianUpdateManyWithWhereWithoutPendaftaranMbkmInput | BerkasPenilaianUpdateManyWithWhereWithoutPendaftaranMbkmInput[]
    deleteMany?: BerkasPenilaianScalarWhereInput | BerkasPenilaianScalarWhereInput[]
  }

  export type BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmNestedInput = {
    create?: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput> | BerkasPenilaianCreateWithoutPendaftaranMbkmInput[] | BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput[]
    connectOrCreate?: BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput | BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput[]
    upsert?: BerkasPenilaianUpsertWithWhereUniqueWithoutPendaftaranMbkmInput | BerkasPenilaianUpsertWithWhereUniqueWithoutPendaftaranMbkmInput[]
    createMany?: BerkasPenilaianCreateManyPendaftaranMbkmInputEnvelope
    set?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    disconnect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    delete?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    connect?: BerkasPenilaianWhereUniqueInput | BerkasPenilaianWhereUniqueInput[]
    update?: BerkasPenilaianUpdateWithWhereUniqueWithoutPendaftaranMbkmInput | BerkasPenilaianUpdateWithWhereUniqueWithoutPendaftaranMbkmInput[]
    updateMany?: BerkasPenilaianUpdateManyWithWhereWithoutPendaftaranMbkmInput | BerkasPenilaianUpdateManyWithWhereWithoutPendaftaranMbkmInput[]
    deleteMany?: BerkasPenilaianScalarWhereInput | BerkasPenilaianScalarWhereInput[]
  }

  export type KoorMbkmCreateNestedOneWithoutPengumumanInput = {
    create?: XOR<KoorMbkmCreateWithoutPengumumanInput, KoorMbkmUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPengumumanInput
    connect?: KoorMbkmWhereUniqueInput
  }

  export type KoorMbkmUpdateOneRequiredWithoutPengumumanNestedInput = {
    create?: XOR<KoorMbkmCreateWithoutPengumumanInput, KoorMbkmUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: KoorMbkmCreateOrConnectWithoutPengumumanInput
    upsert?: KoorMbkmUpsertWithoutPengumumanInput
    connect?: KoorMbkmWhereUniqueInput
    update?: XOR<XOR<KoorMbkmUpdateToOneWithWhereWithoutPengumumanInput, KoorMbkmUpdateWithoutPengumumanInput>, KoorMbkmUncheckedUpdateWithoutPengumumanInput>
  }

  export type CategoriesCreateNestedOneWithoutProgramMbkmInput = {
    create?: XOR<CategoriesCreateWithoutProgramMbkmInput, CategoriesUncheckedCreateWithoutProgramMbkmInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutProgramMbkmInput
    connect?: CategoriesWhereUniqueInput
  }

  export type MahasiswaCreateNestedManyWithoutProgramMbkmInput = {
    create?: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput> | MahasiswaCreateWithoutProgramMbkmInput[] | MahasiswaUncheckedCreateWithoutProgramMbkmInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutProgramMbkmInput | MahasiswaCreateOrConnectWithoutProgramMbkmInput[]
    createMany?: MahasiswaCreateManyProgramMbkmInputEnvelope
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
  }

  export type MahasiswaUncheckedCreateNestedManyWithoutProgramMbkmInput = {
    create?: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput> | MahasiswaCreateWithoutProgramMbkmInput[] | MahasiswaUncheckedCreateWithoutProgramMbkmInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutProgramMbkmInput | MahasiswaCreateOrConnectWithoutProgramMbkmInput[]
    createMany?: MahasiswaCreateManyProgramMbkmInputEnvelope
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CategoriesUpdateOneRequiredWithoutProgramMbkmNestedInput = {
    create?: XOR<CategoriesCreateWithoutProgramMbkmInput, CategoriesUncheckedCreateWithoutProgramMbkmInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutProgramMbkmInput
    upsert?: CategoriesUpsertWithoutProgramMbkmInput
    connect?: CategoriesWhereUniqueInput
    update?: XOR<XOR<CategoriesUpdateToOneWithWhereWithoutProgramMbkmInput, CategoriesUpdateWithoutProgramMbkmInput>, CategoriesUncheckedUpdateWithoutProgramMbkmInput>
  }

  export type MahasiswaUpdateManyWithoutProgramMbkmNestedInput = {
    create?: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput> | MahasiswaCreateWithoutProgramMbkmInput[] | MahasiswaUncheckedCreateWithoutProgramMbkmInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutProgramMbkmInput | MahasiswaCreateOrConnectWithoutProgramMbkmInput[]
    upsert?: MahasiswaUpsertWithWhereUniqueWithoutProgramMbkmInput | MahasiswaUpsertWithWhereUniqueWithoutProgramMbkmInput[]
    createMany?: MahasiswaCreateManyProgramMbkmInputEnvelope
    set?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    disconnect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    delete?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    update?: MahasiswaUpdateWithWhereUniqueWithoutProgramMbkmInput | MahasiswaUpdateWithWhereUniqueWithoutProgramMbkmInput[]
    updateMany?: MahasiswaUpdateManyWithWhereWithoutProgramMbkmInput | MahasiswaUpdateManyWithWhereWithoutProgramMbkmInput[]
    deleteMany?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
  }

  export type MahasiswaUncheckedUpdateManyWithoutProgramMbkmNestedInput = {
    create?: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput> | MahasiswaCreateWithoutProgramMbkmInput[] | MahasiswaUncheckedCreateWithoutProgramMbkmInput[]
    connectOrCreate?: MahasiswaCreateOrConnectWithoutProgramMbkmInput | MahasiswaCreateOrConnectWithoutProgramMbkmInput[]
    upsert?: MahasiswaUpsertWithWhereUniqueWithoutProgramMbkmInput | MahasiswaUpsertWithWhereUniqueWithoutProgramMbkmInput[]
    createMany?: MahasiswaCreateManyProgramMbkmInputEnvelope
    set?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    disconnect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    delete?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    connect?: MahasiswaWhereUniqueInput | MahasiswaWhereUniqueInput[]
    update?: MahasiswaUpdateWithWhereUniqueWithoutProgramMbkmInput | MahasiswaUpdateWithWhereUniqueWithoutProgramMbkmInput[]
    updateMany?: MahasiswaUpdateManyWithWhereWithoutProgramMbkmInput | MahasiswaUpdateManyWithWhereWithoutProgramMbkmInput[]
    deleteMany?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type KonversiNilaiCreateWithoutAdminSiapInput = {
    nilai_akhir: number
    grade: string
    BerkasPenilaian: BerkasPenilaianCreateNestedOneWithoutKonversiNilaiInput
  }

  export type KonversiNilaiUncheckedCreateWithoutAdminSiapInput = {
    id_konversi_nilai?: number
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiCreateOrConnectWithoutAdminSiapInput = {
    where: KonversiNilaiWhereUniqueInput
    create: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput>
  }

  export type KonversiNilaiCreateManyAdminSiapInputEnvelope = {
    data: KonversiNilaiCreateManyAdminSiapInput | KonversiNilaiCreateManyAdminSiapInput[]
    skipDuplicates?: boolean
  }

  export type KonversiNilaiUpsertWithWhereUniqueWithoutAdminSiapInput = {
    where: KonversiNilaiWhereUniqueInput
    update: XOR<KonversiNilaiUpdateWithoutAdminSiapInput, KonversiNilaiUncheckedUpdateWithoutAdminSiapInput>
    create: XOR<KonversiNilaiCreateWithoutAdminSiapInput, KonversiNilaiUncheckedCreateWithoutAdminSiapInput>
  }

  export type KonversiNilaiUpdateWithWhereUniqueWithoutAdminSiapInput = {
    where: KonversiNilaiWhereUniqueInput
    data: XOR<KonversiNilaiUpdateWithoutAdminSiapInput, KonversiNilaiUncheckedUpdateWithoutAdminSiapInput>
  }

  export type KonversiNilaiUpdateManyWithWhereWithoutAdminSiapInput = {
    where: KonversiNilaiScalarWhereInput
    data: XOR<KonversiNilaiUpdateManyMutationInput, KonversiNilaiUncheckedUpdateManyWithoutAdminSiapInput>
  }

  export type KonversiNilaiScalarWhereInput = {
    AND?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
    OR?: KonversiNilaiScalarWhereInput[]
    NOT?: KonversiNilaiScalarWhereInput | KonversiNilaiScalarWhereInput[]
    id_konversi_nilai?: IntFilter<"KonversiNilai"> | number
    NIP_admin_siap?: BigIntFilter<"KonversiNilai"> | bigint | number
    id_berkas_penilaian?: IntFilter<"KonversiNilai"> | number
    nilai_akhir?: IntFilter<"KonversiNilai"> | number
    grade?: StringFilter<"KonversiNilai"> | string
  }

  export type PendaftaranMbkmCreateWithoutBerkasPenilaianInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranMbkmInput
    Dosbing: DosbingCreateNestedOneWithoutPendaftaranMbkmInput
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUncheckedCreateWithoutBerkasPenilaianInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_dosbing: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranMbkmCreateOrConnectWithoutBerkasPenilaianInput = {
    where: PendaftaranMbkmWhereUniqueInput
    create: XOR<PendaftaranMbkmCreateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedCreateWithoutBerkasPenilaianInput>
  }

  export type KonversiNilaiCreateWithoutBerkasPenilaianInput = {
    nilai_akhir: number
    grade: string
    AdminSiap: AdminSiapCreateNestedOneWithoutKonversiNilaiInput
  }

  export type KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput = {
    id_konversi_nilai?: number
    NIP_admin_siap: bigint | number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiCreateOrConnectWithoutBerkasPenilaianInput = {
    where: KonversiNilaiWhereUniqueInput
    create: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput>
  }

  export type KonversiNilaiCreateManyBerkasPenilaianInputEnvelope = {
    data: KonversiNilaiCreateManyBerkasPenilaianInput | KonversiNilaiCreateManyBerkasPenilaianInput[]
    skipDuplicates?: boolean
  }

  export type PendaftaranMbkmUpsertWithoutBerkasPenilaianInput = {
    update: XOR<PendaftaranMbkmUpdateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedUpdateWithoutBerkasPenilaianInput>
    create: XOR<PendaftaranMbkmCreateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedCreateWithoutBerkasPenilaianInput>
    where?: PendaftaranMbkmWhereInput
  }

  export type PendaftaranMbkmUpdateToOneWithWhereWithoutBerkasPenilaianInput = {
    where?: PendaftaranMbkmWhereInput
    data: XOR<PendaftaranMbkmUpdateWithoutBerkasPenilaianInput, PendaftaranMbkmUncheckedUpdateWithoutBerkasPenilaianInput>
  }

  export type PendaftaranMbkmUpdateWithoutBerkasPenilaianInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateWithoutBerkasPenilaianInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KonversiNilaiUpsertWithWhereUniqueWithoutBerkasPenilaianInput = {
    where: KonversiNilaiWhereUniqueInput
    update: XOR<KonversiNilaiUpdateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedUpdateWithoutBerkasPenilaianInput>
    create: XOR<KonversiNilaiCreateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedCreateWithoutBerkasPenilaianInput>
  }

  export type KonversiNilaiUpdateWithWhereUniqueWithoutBerkasPenilaianInput = {
    where: KonversiNilaiWhereUniqueInput
    data: XOR<KonversiNilaiUpdateWithoutBerkasPenilaianInput, KonversiNilaiUncheckedUpdateWithoutBerkasPenilaianInput>
  }

  export type KonversiNilaiUpdateManyWithWhereWithoutBerkasPenilaianInput = {
    where: KonversiNilaiScalarWhereInput
    data: XOR<KonversiNilaiUpdateManyMutationInput, KonversiNilaiUncheckedUpdateManyWithoutBerkasPenilaianInput>
  }

  export type ProgramMbkmCreateWithoutCategoriesInput = {
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    Mahasiswa?: MahasiswaCreateNestedManyWithoutProgramMbkmInput
  }

  export type ProgramMbkmUncheckedCreateWithoutCategoriesInput = {
    id_program_mbkm?: number
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    Mahasiswa?: MahasiswaUncheckedCreateNestedManyWithoutProgramMbkmInput
  }

  export type ProgramMbkmCreateOrConnectWithoutCategoriesInput = {
    where: ProgramMbkmWhereUniqueInput
    create: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput>
  }

  export type ProgramMbkmCreateManyCategoriesInputEnvelope = {
    data: ProgramMbkmCreateManyCategoriesInput | ProgramMbkmCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type ProgramMbkmUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProgramMbkmWhereUniqueInput
    update: XOR<ProgramMbkmUpdateWithoutCategoriesInput, ProgramMbkmUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProgramMbkmCreateWithoutCategoriesInput, ProgramMbkmUncheckedCreateWithoutCategoriesInput>
  }

  export type ProgramMbkmUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProgramMbkmWhereUniqueInput
    data: XOR<ProgramMbkmUpdateWithoutCategoriesInput, ProgramMbkmUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProgramMbkmUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProgramMbkmScalarWhereInput
    data: XOR<ProgramMbkmUpdateManyMutationInput, ProgramMbkmUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ProgramMbkmScalarWhereInput = {
    AND?: ProgramMbkmScalarWhereInput | ProgramMbkmScalarWhereInput[]
    OR?: ProgramMbkmScalarWhereInput[]
    NOT?: ProgramMbkmScalarWhereInput | ProgramMbkmScalarWhereInput[]
    id_program_mbkm?: IntFilter<"ProgramMbkm"> | number
    company?: StringFilter<"ProgramMbkm"> | string
    deskripsi?: StringNullableFilter<"ProgramMbkm"> | string | null
    role?: StringNullableFilter<"ProgramMbkm"> | string | null
    status?: StringNullableFilter<"ProgramMbkm"> | string | null
    date?: DateTimeNullableFilter<"ProgramMbkm"> | Date | string | null
    category_id?: StringFilter<"ProgramMbkm"> | string
  }

  export type MahasiswaCreateWithoutDosbingInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    ProgramMbkm: ProgramMbkmCreateNestedOneWithoutMahasiswaInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUncheckedCreateWithoutDosbingInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaCreateOrConnectWithoutDosbingInput = {
    where: MahasiswaWhereUniqueInput
    create: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput>
  }

  export type MahasiswaCreateManyDosbingInputEnvelope = {
    data: MahasiswaCreateManyDosbingInput | MahasiswaCreateManyDosbingInput[]
    skipDuplicates?: boolean
  }

  export type PendaftaranMbkmCreateWithoutDosbingInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranMbkmInput
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranMbkmInput
    BerkasPenilaian?: BerkasPenilaianCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUncheckedCreateWithoutDosbingInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmCreateOrConnectWithoutDosbingInput = {
    where: PendaftaranMbkmWhereUniqueInput
    create: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput>
  }

  export type PendaftaranMbkmCreateManyDosbingInputEnvelope = {
    data: PendaftaranMbkmCreateManyDosbingInput | PendaftaranMbkmCreateManyDosbingInput[]
    skipDuplicates?: boolean
  }

  export type MahasiswaUpsertWithWhereUniqueWithoutDosbingInput = {
    where: MahasiswaWhereUniqueInput
    update: XOR<MahasiswaUpdateWithoutDosbingInput, MahasiswaUncheckedUpdateWithoutDosbingInput>
    create: XOR<MahasiswaCreateWithoutDosbingInput, MahasiswaUncheckedCreateWithoutDosbingInput>
  }

  export type MahasiswaUpdateWithWhereUniqueWithoutDosbingInput = {
    where: MahasiswaWhereUniqueInput
    data: XOR<MahasiswaUpdateWithoutDosbingInput, MahasiswaUncheckedUpdateWithoutDosbingInput>
  }

  export type MahasiswaUpdateManyWithWhereWithoutDosbingInput = {
    where: MahasiswaScalarWhereInput
    data: XOR<MahasiswaUpdateManyMutationInput, MahasiswaUncheckedUpdateManyWithoutDosbingInput>
  }

  export type MahasiswaScalarWhereInput = {
    AND?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
    OR?: MahasiswaScalarWhereInput[]
    NOT?: MahasiswaScalarWhereInput | MahasiswaScalarWhereInput[]
    NIM?: BigIntFilter<"Mahasiswa"> | bigint | number
    nama_mahasiswa?: StringFilter<"Mahasiswa"> | string
    semester?: IntFilter<"Mahasiswa"> | number
    id_program_mbkm?: IntFilter<"Mahasiswa"> | number
    NIP_dosbing?: BigIntFilter<"Mahasiswa"> | bigint | number
  }

  export type PendaftaranMbkmUpsertWithWhereUniqueWithoutDosbingInput = {
    where: PendaftaranMbkmWhereUniqueInput
    update: XOR<PendaftaranMbkmUpdateWithoutDosbingInput, PendaftaranMbkmUncheckedUpdateWithoutDosbingInput>
    create: XOR<PendaftaranMbkmCreateWithoutDosbingInput, PendaftaranMbkmUncheckedCreateWithoutDosbingInput>
  }

  export type PendaftaranMbkmUpdateWithWhereUniqueWithoutDosbingInput = {
    where: PendaftaranMbkmWhereUniqueInput
    data: XOR<PendaftaranMbkmUpdateWithoutDosbingInput, PendaftaranMbkmUncheckedUpdateWithoutDosbingInput>
  }

  export type PendaftaranMbkmUpdateManyWithWhereWithoutDosbingInput = {
    where: PendaftaranMbkmScalarWhereInput
    data: XOR<PendaftaranMbkmUpdateManyMutationInput, PendaftaranMbkmUncheckedUpdateManyWithoutDosbingInput>
  }

  export type PendaftaranMbkmScalarWhereInput = {
    AND?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
    OR?: PendaftaranMbkmScalarWhereInput[]
    NOT?: PendaftaranMbkmScalarWhereInput | PendaftaranMbkmScalarWhereInput[]
    id_pendaftaran_mbkm?: IntFilter<"PendaftaranMbkm"> | number
    NIM?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_dosbing?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranMbkm"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranMbkm"> | Date | string
  }

  export type AdminSiapCreateWithoutKonversiNilaiInput = {
    NIP_admin_siap: bigint | number
    nama_admin_siap: string
  }

  export type AdminSiapUncheckedCreateWithoutKonversiNilaiInput = {
    NIP_admin_siap: bigint | number
    nama_admin_siap: string
  }

  export type AdminSiapCreateOrConnectWithoutKonversiNilaiInput = {
    where: AdminSiapWhereUniqueInput
    create: XOR<AdminSiapCreateWithoutKonversiNilaiInput, AdminSiapUncheckedCreateWithoutKonversiNilaiInput>
  }

  export type BerkasPenilaianCreateWithoutKonversiNilaiInput = {
    nama_berkas: string
    PendaftaranMbkm: PendaftaranMbkmCreateNestedOneWithoutBerkasPenilaianInput
  }

  export type BerkasPenilaianUncheckedCreateWithoutKonversiNilaiInput = {
    id_berkas_penilaian?: number
    id_pendaftaran_mbkm: number
    nama_berkas: string
  }

  export type BerkasPenilaianCreateOrConnectWithoutKonversiNilaiInput = {
    where: BerkasPenilaianWhereUniqueInput
    create: XOR<BerkasPenilaianCreateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedCreateWithoutKonversiNilaiInput>
  }

  export type AdminSiapUpsertWithoutKonversiNilaiInput = {
    update: XOR<AdminSiapUpdateWithoutKonversiNilaiInput, AdminSiapUncheckedUpdateWithoutKonversiNilaiInput>
    create: XOR<AdminSiapCreateWithoutKonversiNilaiInput, AdminSiapUncheckedCreateWithoutKonversiNilaiInput>
    where?: AdminSiapWhereInput
  }

  export type AdminSiapUpdateToOneWithWhereWithoutKonversiNilaiInput = {
    where?: AdminSiapWhereInput
    data: XOR<AdminSiapUpdateWithoutKonversiNilaiInput, AdminSiapUncheckedUpdateWithoutKonversiNilaiInput>
  }

  export type AdminSiapUpdateWithoutKonversiNilaiInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
  }

  export type AdminSiapUncheckedUpdateWithoutKonversiNilaiInput = {
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_admin_siap?: StringFieldUpdateOperationsInput | string
  }

  export type BerkasPenilaianUpsertWithoutKonversiNilaiInput = {
    update: XOR<BerkasPenilaianUpdateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedUpdateWithoutKonversiNilaiInput>
    create: XOR<BerkasPenilaianCreateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedCreateWithoutKonversiNilaiInput>
    where?: BerkasPenilaianWhereInput
  }

  export type BerkasPenilaianUpdateToOneWithWhereWithoutKonversiNilaiInput = {
    where?: BerkasPenilaianWhereInput
    data: XOR<BerkasPenilaianUpdateWithoutKonversiNilaiInput, BerkasPenilaianUncheckedUpdateWithoutKonversiNilaiInput>
  }

  export type BerkasPenilaianUpdateWithoutKonversiNilaiInput = {
    nama_berkas?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUpdateOneRequiredWithoutBerkasPenilaianNestedInput
  }

  export type BerkasPenilaianUncheckedUpdateWithoutKonversiNilaiInput = {
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    nama_berkas?: StringFieldUpdateOperationsInput | string
  }

  export type PendaftaranAkunCreateWithoutKoorMbkmInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranAkunInput
  }

  export type PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput = {
    id_pendaftaran_akun?: number
    NIM: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranAkunCreateOrConnectWithoutKoorMbkmInput = {
    where: PendaftaranAkunWhereUniqueInput
    create: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PendaftaranAkunCreateManyKoorMbkmInputEnvelope = {
    data: PendaftaranAkunCreateManyKoorMbkmInput | PendaftaranAkunCreateManyKoorMbkmInput[]
    skipDuplicates?: boolean
  }

  export type PendaftaranMbkmCreateWithoutKoorMbkmInput = {
    tanggal: Date | string
    Mahasiswa: MahasiswaCreateNestedOneWithoutPendaftaranMbkmInput
    Dosbing: DosbingCreateNestedOneWithoutPendaftaranMbkmInput
    BerkasPenilaian?: BerkasPenilaianCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_dosbing: bigint | number
    tanggal: Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmCreateOrConnectWithoutKoorMbkmInput = {
    where: PendaftaranMbkmWhereUniqueInput
    create: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PendaftaranMbkmCreateManyKoorMbkmInputEnvelope = {
    data: PendaftaranMbkmCreateManyKoorMbkmInput | PendaftaranMbkmCreateManyKoorMbkmInput[]
    skipDuplicates?: boolean
  }

  export type PengumumanCreateWithoutKoorMbkmInput = {
    judul: string
    isi: string
    tanggal: Date | string
  }

  export type PengumumanUncheckedCreateWithoutKoorMbkmInput = {
    id_pengumuman?: number
    judul: string
    isi: string
    tanggal: Date | string
  }

  export type PengumumanCreateOrConnectWithoutKoorMbkmInput = {
    where: PengumumanWhereUniqueInput
    create: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PengumumanCreateManyKoorMbkmInputEnvelope = {
    data: PengumumanCreateManyKoorMbkmInput | PengumumanCreateManyKoorMbkmInput[]
    skipDuplicates?: boolean
  }

  export type PendaftaranAkunUpsertWithWhereUniqueWithoutKoorMbkmInput = {
    where: PendaftaranAkunWhereUniqueInput
    update: XOR<PendaftaranAkunUpdateWithoutKoorMbkmInput, PendaftaranAkunUncheckedUpdateWithoutKoorMbkmInput>
    create: XOR<PendaftaranAkunCreateWithoutKoorMbkmInput, PendaftaranAkunUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PendaftaranAkunUpdateWithWhereUniqueWithoutKoorMbkmInput = {
    where: PendaftaranAkunWhereUniqueInput
    data: XOR<PendaftaranAkunUpdateWithoutKoorMbkmInput, PendaftaranAkunUncheckedUpdateWithoutKoorMbkmInput>
  }

  export type PendaftaranAkunUpdateManyWithWhereWithoutKoorMbkmInput = {
    where: PendaftaranAkunScalarWhereInput
    data: XOR<PendaftaranAkunUpdateManyMutationInput, PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmInput>
  }

  export type PendaftaranAkunScalarWhereInput = {
    AND?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
    OR?: PendaftaranAkunScalarWhereInput[]
    NOT?: PendaftaranAkunScalarWhereInput | PendaftaranAkunScalarWhereInput[]
    id_pendaftaran_akun?: IntFilter<"PendaftaranAkun"> | number
    NIM?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    NIP_koor_mbkm?: BigIntFilter<"PendaftaranAkun"> | bigint | number
    tanggal?: DateTimeFilter<"PendaftaranAkun"> | Date | string
  }

  export type PendaftaranMbkmUpsertWithWhereUniqueWithoutKoorMbkmInput = {
    where: PendaftaranMbkmWhereUniqueInput
    update: XOR<PendaftaranMbkmUpdateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedUpdateWithoutKoorMbkmInput>
    create: XOR<PendaftaranMbkmCreateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PendaftaranMbkmUpdateWithWhereUniqueWithoutKoorMbkmInput = {
    where: PendaftaranMbkmWhereUniqueInput
    data: XOR<PendaftaranMbkmUpdateWithoutKoorMbkmInput, PendaftaranMbkmUncheckedUpdateWithoutKoorMbkmInput>
  }

  export type PendaftaranMbkmUpdateManyWithWhereWithoutKoorMbkmInput = {
    where: PendaftaranMbkmScalarWhereInput
    data: XOR<PendaftaranMbkmUpdateManyMutationInput, PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmInput>
  }

  export type PengumumanUpsertWithWhereUniqueWithoutKoorMbkmInput = {
    where: PengumumanWhereUniqueInput
    update: XOR<PengumumanUpdateWithoutKoorMbkmInput, PengumumanUncheckedUpdateWithoutKoorMbkmInput>
    create: XOR<PengumumanCreateWithoutKoorMbkmInput, PengumumanUncheckedCreateWithoutKoorMbkmInput>
  }

  export type PengumumanUpdateWithWhereUniqueWithoutKoorMbkmInput = {
    where: PengumumanWhereUniqueInput
    data: XOR<PengumumanUpdateWithoutKoorMbkmInput, PengumumanUncheckedUpdateWithoutKoorMbkmInput>
  }

  export type PengumumanUpdateManyWithWhereWithoutKoorMbkmInput = {
    where: PengumumanScalarWhereInput
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyWithoutKoorMbkmInput>
  }

  export type PengumumanScalarWhereInput = {
    AND?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    OR?: PengumumanScalarWhereInput[]
    NOT?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    id_pengumuman?: IntFilter<"Pengumuman"> | number
    judul?: StringFilter<"Pengumuman"> | string
    isi?: StringFilter<"Pengumuman"> | string
    tanggal?: DateTimeFilter<"Pengumuman"> | Date | string
    NIP_koor_mbkm?: BigIntFilter<"Pengumuman"> | bigint | number
  }

  export type ProgramMbkmCreateWithoutMahasiswaInput = {
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    Categories: CategoriesCreateNestedOneWithoutProgramMbkmInput
  }

  export type ProgramMbkmUncheckedCreateWithoutMahasiswaInput = {
    id_program_mbkm?: number
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
    category_id: string
  }

  export type ProgramMbkmCreateOrConnectWithoutMahasiswaInput = {
    where: ProgramMbkmWhereUniqueInput
    create: XOR<ProgramMbkmCreateWithoutMahasiswaInput, ProgramMbkmUncheckedCreateWithoutMahasiswaInput>
  }

  export type DosbingCreateWithoutMahasiswaInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutDosbingInput
  }

  export type DosbingUncheckedCreateWithoutMahasiswaInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutDosbingInput
  }

  export type DosbingCreateOrConnectWithoutMahasiswaInput = {
    where: DosbingWhereUniqueInput
    create: XOR<DosbingCreateWithoutMahasiswaInput, DosbingUncheckedCreateWithoutMahasiswaInput>
  }

  export type PendaftaranMbkmCreateWithoutMahasiswaInput = {
    tanggal: Date | string
    Dosbing: DosbingCreateNestedOneWithoutPendaftaranMbkmInput
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranMbkmInput
    BerkasPenilaian?: BerkasPenilaianCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput = {
    id_pendaftaran_mbkm?: number
    NIP_dosbing: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedCreateNestedManyWithoutPendaftaranMbkmInput
  }

  export type PendaftaranMbkmCreateOrConnectWithoutMahasiswaInput = {
    where: PendaftaranMbkmWhereUniqueInput
    create: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput>
  }

  export type PendaftaranMbkmCreateManyMahasiswaInputEnvelope = {
    data: PendaftaranMbkmCreateManyMahasiswaInput | PendaftaranMbkmCreateManyMahasiswaInput[]
    skipDuplicates?: boolean
  }

  export type PendaftaranAkunCreateWithoutMahasiswaInput = {
    tanggal: Date | string
    KoorMbkm: KoorMbkmCreateNestedOneWithoutPendaftaranAkunInput
  }

  export type PendaftaranAkunUncheckedCreateWithoutMahasiswaInput = {
    id_pendaftaran_akun?: number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranAkunCreateOrConnectWithoutMahasiswaInput = {
    where: PendaftaranAkunWhereUniqueInput
    create: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput>
  }

  export type PendaftaranAkunCreateManyMahasiswaInputEnvelope = {
    data: PendaftaranAkunCreateManyMahasiswaInput | PendaftaranAkunCreateManyMahasiswaInput[]
    skipDuplicates?: boolean
  }

  export type ProgramMbkmUpsertWithoutMahasiswaInput = {
    update: XOR<ProgramMbkmUpdateWithoutMahasiswaInput, ProgramMbkmUncheckedUpdateWithoutMahasiswaInput>
    create: XOR<ProgramMbkmCreateWithoutMahasiswaInput, ProgramMbkmUncheckedCreateWithoutMahasiswaInput>
    where?: ProgramMbkmWhereInput
  }

  export type ProgramMbkmUpdateToOneWithWhereWithoutMahasiswaInput = {
    where?: ProgramMbkmWhereInput
    data: XOR<ProgramMbkmUpdateWithoutMahasiswaInput, ProgramMbkmUncheckedUpdateWithoutMahasiswaInput>
  }

  export type ProgramMbkmUpdateWithoutMahasiswaInput = {
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Categories?: CategoriesUpdateOneRequiredWithoutProgramMbkmNestedInput
  }

  export type ProgramMbkmUncheckedUpdateWithoutMahasiswaInput = {
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type DosbingUpsertWithoutMahasiswaInput = {
    update: XOR<DosbingUpdateWithoutMahasiswaInput, DosbingUncheckedUpdateWithoutMahasiswaInput>
    create: XOR<DosbingCreateWithoutMahasiswaInput, DosbingUncheckedCreateWithoutMahasiswaInput>
    where?: DosbingWhereInput
  }

  export type DosbingUpdateToOneWithWhereWithoutMahasiswaInput = {
    where?: DosbingWhereInput
    data: XOR<DosbingUpdateWithoutMahasiswaInput, DosbingUncheckedUpdateWithoutMahasiswaInput>
  }

  export type DosbingUpdateWithoutMahasiswaInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutDosbingNestedInput
  }

  export type DosbingUncheckedUpdateWithoutMahasiswaInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutDosbingNestedInput
  }

  export type PendaftaranMbkmUpsertWithWhereUniqueWithoutMahasiswaInput = {
    where: PendaftaranMbkmWhereUniqueInput
    update: XOR<PendaftaranMbkmUpdateWithoutMahasiswaInput, PendaftaranMbkmUncheckedUpdateWithoutMahasiswaInput>
    create: XOR<PendaftaranMbkmCreateWithoutMahasiswaInput, PendaftaranMbkmUncheckedCreateWithoutMahasiswaInput>
  }

  export type PendaftaranMbkmUpdateWithWhereUniqueWithoutMahasiswaInput = {
    where: PendaftaranMbkmWhereUniqueInput
    data: XOR<PendaftaranMbkmUpdateWithoutMahasiswaInput, PendaftaranMbkmUncheckedUpdateWithoutMahasiswaInput>
  }

  export type PendaftaranMbkmUpdateManyWithWhereWithoutMahasiswaInput = {
    where: PendaftaranMbkmScalarWhereInput
    data: XOR<PendaftaranMbkmUpdateManyMutationInput, PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaInput>
  }

  export type PendaftaranAkunUpsertWithWhereUniqueWithoutMahasiswaInput = {
    where: PendaftaranAkunWhereUniqueInput
    update: XOR<PendaftaranAkunUpdateWithoutMahasiswaInput, PendaftaranAkunUncheckedUpdateWithoutMahasiswaInput>
    create: XOR<PendaftaranAkunCreateWithoutMahasiswaInput, PendaftaranAkunUncheckedCreateWithoutMahasiswaInput>
  }

  export type PendaftaranAkunUpdateWithWhereUniqueWithoutMahasiswaInput = {
    where: PendaftaranAkunWhereUniqueInput
    data: XOR<PendaftaranAkunUpdateWithoutMahasiswaInput, PendaftaranAkunUncheckedUpdateWithoutMahasiswaInput>
  }

  export type PendaftaranAkunUpdateManyWithWhereWithoutMahasiswaInput = {
    where: PendaftaranAkunScalarWhereInput
    data: XOR<PendaftaranAkunUpdateManyMutationInput, PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaInput>
  }

  export type MahasiswaCreateWithoutPendaftaranAkunInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    ProgramMbkm: ProgramMbkmCreateNestedOneWithoutMahasiswaInput
    Dosbing: DosbingCreateNestedOneWithoutMahasiswaInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUncheckedCreateWithoutPendaftaranAkunInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    NIP_dosbing: bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaCreateOrConnectWithoutPendaftaranAkunInput = {
    where: MahasiswaWhereUniqueInput
    create: XOR<MahasiswaCreateWithoutPendaftaranAkunInput, MahasiswaUncheckedCreateWithoutPendaftaranAkunInput>
  }

  export type KoorMbkmCreateWithoutPendaftaranAkunInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmUncheckedCreateWithoutPendaftaranAkunInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanUncheckedCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmCreateOrConnectWithoutPendaftaranAkunInput = {
    where: KoorMbkmWhereUniqueInput
    create: XOR<KoorMbkmCreateWithoutPendaftaranAkunInput, KoorMbkmUncheckedCreateWithoutPendaftaranAkunInput>
  }

  export type MahasiswaUpsertWithoutPendaftaranAkunInput = {
    update: XOR<MahasiswaUpdateWithoutPendaftaranAkunInput, MahasiswaUncheckedUpdateWithoutPendaftaranAkunInput>
    create: XOR<MahasiswaCreateWithoutPendaftaranAkunInput, MahasiswaUncheckedCreateWithoutPendaftaranAkunInput>
    where?: MahasiswaWhereInput
  }

  export type MahasiswaUpdateToOneWithWhereWithoutPendaftaranAkunInput = {
    where?: MahasiswaWhereInput
    data: XOR<MahasiswaUpdateWithoutPendaftaranAkunInput, MahasiswaUncheckedUpdateWithoutPendaftaranAkunInput>
  }

  export type MahasiswaUpdateWithoutPendaftaranAkunInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    ProgramMbkm?: ProgramMbkmUpdateOneRequiredWithoutMahasiswaNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutMahasiswaNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateWithoutPendaftaranAkunInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type KoorMbkmUpsertWithoutPendaftaranAkunInput = {
    update: XOR<KoorMbkmUpdateWithoutPendaftaranAkunInput, KoorMbkmUncheckedUpdateWithoutPendaftaranAkunInput>
    create: XOR<KoorMbkmCreateWithoutPendaftaranAkunInput, KoorMbkmUncheckedCreateWithoutPendaftaranAkunInput>
    where?: KoorMbkmWhereInput
  }

  export type KoorMbkmUpdateToOneWithWhereWithoutPendaftaranAkunInput = {
    where?: KoorMbkmWhereInput
    data: XOR<KoorMbkmUpdateWithoutPendaftaranAkunInput, KoorMbkmUncheckedUpdateWithoutPendaftaranAkunInput>
  }

  export type KoorMbkmUpdateWithoutPendaftaranAkunInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUpdateManyWithoutKoorMbkmNestedInput
  }

  export type KoorMbkmUncheckedUpdateWithoutPendaftaranAkunInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUncheckedUpdateManyWithoutKoorMbkmNestedInput
  }

  export type MahasiswaCreateWithoutPendaftaranMbkmInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    ProgramMbkm: ProgramMbkmCreateNestedOneWithoutMahasiswaInput
    Dosbing: DosbingCreateNestedOneWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUncheckedCreateWithoutPendaftaranMbkmInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
    NIP_dosbing: bigint | number
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaCreateOrConnectWithoutPendaftaranMbkmInput = {
    where: MahasiswaWhereUniqueInput
    create: XOR<MahasiswaCreateWithoutPendaftaranMbkmInput, MahasiswaUncheckedCreateWithoutPendaftaranMbkmInput>
  }

  export type DosbingCreateWithoutPendaftaranMbkmInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    Mahasiswa?: MahasiswaCreateNestedManyWithoutDosbingInput
  }

  export type DosbingUncheckedCreateWithoutPendaftaranMbkmInput = {
    NIP_dosbing: bigint | number
    nama_dosbing: string
    Mahasiswa?: MahasiswaUncheckedCreateNestedManyWithoutDosbingInput
  }

  export type DosbingCreateOrConnectWithoutPendaftaranMbkmInput = {
    where: DosbingWhereUniqueInput
    create: XOR<DosbingCreateWithoutPendaftaranMbkmInput, DosbingUncheckedCreateWithoutPendaftaranMbkmInput>
  }

  export type KoorMbkmCreateWithoutPendaftaranMbkmInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmUncheckedCreateWithoutPendaftaranMbkmInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutKoorMbkmInput
    Pengumuman?: PengumumanUncheckedCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmCreateOrConnectWithoutPendaftaranMbkmInput = {
    where: KoorMbkmWhereUniqueInput
    create: XOR<KoorMbkmCreateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedCreateWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianCreateWithoutPendaftaranMbkmInput = {
    nama_berkas: string
    KonversiNilai?: KonversiNilaiCreateNestedManyWithoutBerkasPenilaianInput
  }

  export type BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput = {
    id_berkas_penilaian?: number
    nama_berkas: string
    KonversiNilai?: KonversiNilaiUncheckedCreateNestedManyWithoutBerkasPenilaianInput
  }

  export type BerkasPenilaianCreateOrConnectWithoutPendaftaranMbkmInput = {
    where: BerkasPenilaianWhereUniqueInput
    create: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianCreateManyPendaftaranMbkmInputEnvelope = {
    data: BerkasPenilaianCreateManyPendaftaranMbkmInput | BerkasPenilaianCreateManyPendaftaranMbkmInput[]
    skipDuplicates?: boolean
  }

  export type MahasiswaUpsertWithoutPendaftaranMbkmInput = {
    update: XOR<MahasiswaUpdateWithoutPendaftaranMbkmInput, MahasiswaUncheckedUpdateWithoutPendaftaranMbkmInput>
    create: XOR<MahasiswaCreateWithoutPendaftaranMbkmInput, MahasiswaUncheckedCreateWithoutPendaftaranMbkmInput>
    where?: MahasiswaWhereInput
  }

  export type MahasiswaUpdateToOneWithWhereWithoutPendaftaranMbkmInput = {
    where?: MahasiswaWhereInput
    data: XOR<MahasiswaUpdateWithoutPendaftaranMbkmInput, MahasiswaUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type MahasiswaUpdateWithoutPendaftaranMbkmInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    ProgramMbkm?: ProgramMbkmUpdateOneRequiredWithoutMahasiswaNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateWithoutPendaftaranMbkmInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type DosbingUpsertWithoutPendaftaranMbkmInput = {
    update: XOR<DosbingUpdateWithoutPendaftaranMbkmInput, DosbingUncheckedUpdateWithoutPendaftaranMbkmInput>
    create: XOR<DosbingCreateWithoutPendaftaranMbkmInput, DosbingUncheckedCreateWithoutPendaftaranMbkmInput>
    where?: DosbingWhereInput
  }

  export type DosbingUpdateToOneWithWhereWithoutPendaftaranMbkmInput = {
    where?: DosbingWhereInput
    data: XOR<DosbingUpdateWithoutPendaftaranMbkmInput, DosbingUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type DosbingUpdateWithoutPendaftaranMbkmInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    Mahasiswa?: MahasiswaUpdateManyWithoutDosbingNestedInput
  }

  export type DosbingUncheckedUpdateWithoutPendaftaranMbkmInput = {
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_dosbing?: StringFieldUpdateOperationsInput | string
    Mahasiswa?: MahasiswaUncheckedUpdateManyWithoutDosbingNestedInput
  }

  export type KoorMbkmUpsertWithoutPendaftaranMbkmInput = {
    update: XOR<KoorMbkmUpdateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedUpdateWithoutPendaftaranMbkmInput>
    create: XOR<KoorMbkmCreateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedCreateWithoutPendaftaranMbkmInput>
    where?: KoorMbkmWhereInput
  }

  export type KoorMbkmUpdateToOneWithWhereWithoutPendaftaranMbkmInput = {
    where?: KoorMbkmWhereInput
    data: XOR<KoorMbkmUpdateWithoutPendaftaranMbkmInput, KoorMbkmUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type KoorMbkmUpdateWithoutPendaftaranMbkmInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUpdateManyWithoutKoorMbkmNestedInput
  }

  export type KoorMbkmUncheckedUpdateWithoutPendaftaranMbkmInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmNestedInput
    Pengumuman?: PengumumanUncheckedUpdateManyWithoutKoorMbkmNestedInput
  }

  export type BerkasPenilaianUpsertWithWhereUniqueWithoutPendaftaranMbkmInput = {
    where: BerkasPenilaianWhereUniqueInput
    update: XOR<BerkasPenilaianUpdateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedUpdateWithoutPendaftaranMbkmInput>
    create: XOR<BerkasPenilaianCreateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedCreateWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianUpdateWithWhereUniqueWithoutPendaftaranMbkmInput = {
    where: BerkasPenilaianWhereUniqueInput
    data: XOR<BerkasPenilaianUpdateWithoutPendaftaranMbkmInput, BerkasPenilaianUncheckedUpdateWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianUpdateManyWithWhereWithoutPendaftaranMbkmInput = {
    where: BerkasPenilaianScalarWhereInput
    data: XOR<BerkasPenilaianUpdateManyMutationInput, BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmInput>
  }

  export type BerkasPenilaianScalarWhereInput = {
    AND?: BerkasPenilaianScalarWhereInput | BerkasPenilaianScalarWhereInput[]
    OR?: BerkasPenilaianScalarWhereInput[]
    NOT?: BerkasPenilaianScalarWhereInput | BerkasPenilaianScalarWhereInput[]
    id_berkas_penilaian?: IntFilter<"BerkasPenilaian"> | number
    id_pendaftaran_mbkm?: IntFilter<"BerkasPenilaian"> | number
    nama_berkas?: StringFilter<"BerkasPenilaian"> | string
  }

  export type KoorMbkmCreateWithoutPengumumanInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutKoorMbkmInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmUncheckedCreateWithoutPengumumanInput = {
    NIP_koor_mbkm: bigint | number
    nama_koor_mbkm: string
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutKoorMbkmInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutKoorMbkmInput
  }

  export type KoorMbkmCreateOrConnectWithoutPengumumanInput = {
    where: KoorMbkmWhereUniqueInput
    create: XOR<KoorMbkmCreateWithoutPengumumanInput, KoorMbkmUncheckedCreateWithoutPengumumanInput>
  }

  export type KoorMbkmUpsertWithoutPengumumanInput = {
    update: XOR<KoorMbkmUpdateWithoutPengumumanInput, KoorMbkmUncheckedUpdateWithoutPengumumanInput>
    create: XOR<KoorMbkmCreateWithoutPengumumanInput, KoorMbkmUncheckedCreateWithoutPengumumanInput>
    where?: KoorMbkmWhereInput
  }

  export type KoorMbkmUpdateToOneWithWhereWithoutPengumumanInput = {
    where?: KoorMbkmWhereInput
    data: XOR<KoorMbkmUpdateWithoutPengumumanInput, KoorMbkmUncheckedUpdateWithoutPengumumanInput>
  }

  export type KoorMbkmUpdateWithoutPengumumanInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutKoorMbkmNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutKoorMbkmNestedInput
  }

  export type KoorMbkmUncheckedUpdateWithoutPengumumanInput = {
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_koor_mbkm?: StringFieldUpdateOperationsInput | string
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmNestedInput
  }

  export type CategoriesCreateWithoutProgramMbkmInput = {
    id: string
    name: string
  }

  export type CategoriesUncheckedCreateWithoutProgramMbkmInput = {
    id: string
    name: string
  }

  export type CategoriesCreateOrConnectWithoutProgramMbkmInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutProgramMbkmInput, CategoriesUncheckedCreateWithoutProgramMbkmInput>
  }

  export type MahasiswaCreateWithoutProgramMbkmInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    Dosbing: DosbingCreateNestedOneWithoutMahasiswaInput
    PendaftaranMbkm?: PendaftaranMbkmCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaUncheckedCreateWithoutProgramMbkmInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    NIP_dosbing: bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedCreateNestedManyWithoutMahasiswaInput
    PendaftaranAkun?: PendaftaranAkunUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type MahasiswaCreateOrConnectWithoutProgramMbkmInput = {
    where: MahasiswaWhereUniqueInput
    create: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput>
  }

  export type MahasiswaCreateManyProgramMbkmInputEnvelope = {
    data: MahasiswaCreateManyProgramMbkmInput | MahasiswaCreateManyProgramMbkmInput[]
    skipDuplicates?: boolean
  }

  export type CategoriesUpsertWithoutProgramMbkmInput = {
    update: XOR<CategoriesUpdateWithoutProgramMbkmInput, CategoriesUncheckedUpdateWithoutProgramMbkmInput>
    create: XOR<CategoriesCreateWithoutProgramMbkmInput, CategoriesUncheckedCreateWithoutProgramMbkmInput>
    where?: CategoriesWhereInput
  }

  export type CategoriesUpdateToOneWithWhereWithoutProgramMbkmInput = {
    where?: CategoriesWhereInput
    data: XOR<CategoriesUpdateWithoutProgramMbkmInput, CategoriesUncheckedUpdateWithoutProgramMbkmInput>
  }

  export type CategoriesUpdateWithoutProgramMbkmInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutProgramMbkmInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MahasiswaUpsertWithWhereUniqueWithoutProgramMbkmInput = {
    where: MahasiswaWhereUniqueInput
    update: XOR<MahasiswaUpdateWithoutProgramMbkmInput, MahasiswaUncheckedUpdateWithoutProgramMbkmInput>
    create: XOR<MahasiswaCreateWithoutProgramMbkmInput, MahasiswaUncheckedCreateWithoutProgramMbkmInput>
  }

  export type MahasiswaUpdateWithWhereUniqueWithoutProgramMbkmInput = {
    where: MahasiswaWhereUniqueInput
    data: XOR<MahasiswaUpdateWithoutProgramMbkmInput, MahasiswaUncheckedUpdateWithoutProgramMbkmInput>
  }

  export type MahasiswaUpdateManyWithWhereWithoutProgramMbkmInput = {
    where: MahasiswaScalarWhereInput
    data: XOR<MahasiswaUpdateManyMutationInput, MahasiswaUncheckedUpdateManyWithoutProgramMbkmInput>
  }

  export type KonversiNilaiCreateManyAdminSiapInput = {
    id_konversi_nilai?: number
    id_berkas_penilaian: number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiUpdateWithoutAdminSiapInput = {
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    BerkasPenilaian?: BerkasPenilaianUpdateOneRequiredWithoutKonversiNilaiNestedInput
  }

  export type KonversiNilaiUncheckedUpdateWithoutAdminSiapInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiUncheckedUpdateManyWithoutAdminSiapInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiCreateManyBerkasPenilaianInput = {
    id_konversi_nilai?: number
    NIP_admin_siap: bigint | number
    nilai_akhir: number
    grade: string
  }

  export type KonversiNilaiUpdateWithoutBerkasPenilaianInput = {
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    AdminSiap?: AdminSiapUpdateOneRequiredWithoutKonversiNilaiNestedInput
  }

  export type KonversiNilaiUncheckedUpdateWithoutBerkasPenilaianInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type KonversiNilaiUncheckedUpdateManyWithoutBerkasPenilaianInput = {
    id_konversi_nilai?: IntFieldUpdateOperationsInput | number
    NIP_admin_siap?: BigIntFieldUpdateOperationsInput | bigint | number
    nilai_akhir?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramMbkmCreateManyCategoriesInput = {
    id_program_mbkm?: number
    company: string
    deskripsi?: string | null
    role?: string | null
    status?: string | null
    date?: Date | string | null
  }

  export type ProgramMbkmUpdateWithoutCategoriesInput = {
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Mahasiswa?: MahasiswaUpdateManyWithoutProgramMbkmNestedInput
  }

  export type ProgramMbkmUncheckedUpdateWithoutCategoriesInput = {
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Mahasiswa?: MahasiswaUncheckedUpdateManyWithoutProgramMbkmNestedInput
  }

  export type ProgramMbkmUncheckedUpdateManyWithoutCategoriesInput = {
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MahasiswaCreateManyDosbingInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    id_program_mbkm: number
  }

  export type PendaftaranMbkmCreateManyDosbingInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type MahasiswaUpdateWithoutDosbingInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    ProgramMbkm?: ProgramMbkmUpdateOneRequiredWithoutMahasiswaNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateWithoutDosbingInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateManyWithoutDosbingInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    id_program_mbkm?: IntFieldUpdateOperationsInput | number
  }

  export type PendaftaranMbkmUpdateWithoutDosbingInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    BerkasPenilaian?: BerkasPenilaianUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateWithoutDosbingInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutDosbingInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunCreateManyKoorMbkmInput = {
    id_pendaftaran_akun?: number
    NIM: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranMbkmCreateManyKoorMbkmInput = {
    id_pendaftaran_mbkm?: number
    NIM: bigint | number
    NIP_dosbing: bigint | number
    tanggal: Date | string
  }

  export type PengumumanCreateManyKoorMbkmInput = {
    id_pengumuman?: number
    judul: string
    isi: string
    tanggal: Date | string
  }

  export type PendaftaranAkunUpdateWithoutKoorMbkmInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranAkunNestedInput
  }

  export type PendaftaranAkunUncheckedUpdateWithoutKoorMbkmInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunUncheckedUpdateManyWithoutKoorMbkmInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranMbkmUpdateWithoutKoorMbkmInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Mahasiswa?: MahasiswaUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    Dosbing?: DosbingUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    BerkasPenilaian?: BerkasPenilaianUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateWithoutKoorMbkmInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutKoorMbkmInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUpdateWithoutKoorMbkmInput = {
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateWithoutKoorMbkmInput = {
    id_pengumuman?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyWithoutKoorMbkmInput = {
    id_pengumuman?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    isi?: StringFieldUpdateOperationsInput | string
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranMbkmCreateManyMahasiswaInput = {
    id_pendaftaran_mbkm?: number
    NIP_dosbing: bigint | number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranAkunCreateManyMahasiswaInput = {
    id_pendaftaran_akun?: number
    NIP_koor_mbkm: bigint | number
    tanggal: Date | string
  }

  export type PendaftaranMbkmUpdateWithoutMahasiswaInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    Dosbing?: DosbingUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranMbkmNestedInput
    BerkasPenilaian?: BerkasPenilaianUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateWithoutMahasiswaInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    BerkasPenilaian?: BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmNestedInput
  }

  export type PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaInput = {
    id_pendaftaran_mbkm?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunUpdateWithoutMahasiswaInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    KoorMbkm?: KoorMbkmUpdateOneRequiredWithoutPendaftaranAkunNestedInput
  }

  export type PendaftaranAkunUncheckedUpdateWithoutMahasiswaInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaInput = {
    id_pendaftaran_akun?: IntFieldUpdateOperationsInput | number
    NIP_koor_mbkm?: BigIntFieldUpdateOperationsInput | bigint | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BerkasPenilaianCreateManyPendaftaranMbkmInput = {
    id_berkas_penilaian?: number
    nama_berkas: string
  }

  export type BerkasPenilaianUpdateWithoutPendaftaranMbkmInput = {
    nama_berkas?: StringFieldUpdateOperationsInput | string
    KonversiNilai?: KonversiNilaiUpdateManyWithoutBerkasPenilaianNestedInput
  }

  export type BerkasPenilaianUncheckedUpdateWithoutPendaftaranMbkmInput = {
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nama_berkas?: StringFieldUpdateOperationsInput | string
    KonversiNilai?: KonversiNilaiUncheckedUpdateManyWithoutBerkasPenilaianNestedInput
  }

  export type BerkasPenilaianUncheckedUpdateManyWithoutPendaftaranMbkmInput = {
    id_berkas_penilaian?: IntFieldUpdateOperationsInput | number
    nama_berkas?: StringFieldUpdateOperationsInput | string
  }

  export type MahasiswaCreateManyProgramMbkmInput = {
    NIM: bigint | number
    nama_mahasiswa: string
    semester: number
    NIP_dosbing: bigint | number
  }

  export type MahasiswaUpdateWithoutProgramMbkmInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    Dosbing?: DosbingUpdateOneRequiredWithoutMahasiswaNestedInput
    PendaftaranMbkm?: PendaftaranMbkmUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateWithoutProgramMbkmInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
    PendaftaranMbkm?: PendaftaranMbkmUncheckedUpdateManyWithoutMahasiswaNestedInput
    PendaftaranAkun?: PendaftaranAkunUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type MahasiswaUncheckedUpdateManyWithoutProgramMbkmInput = {
    NIM?: BigIntFieldUpdateOperationsInput | bigint | number
    nama_mahasiswa?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    NIP_dosbing?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AdminSiapCountOutputTypeDefaultArgs instead
     */
    export type AdminSiapCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminSiapCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BerkasPenilaianCountOutputTypeDefaultArgs instead
     */
    export type BerkasPenilaianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BerkasPenilaianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriesCountOutputTypeDefaultArgs instead
     */
    export type CategoriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DosbingCountOutputTypeDefaultArgs instead
     */
    export type DosbingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DosbingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KoorMbkmCountOutputTypeDefaultArgs instead
     */
    export type KoorMbkmCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KoorMbkmCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MahasiswaCountOutputTypeDefaultArgs instead
     */
    export type MahasiswaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MahasiswaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendaftaranMbkmCountOutputTypeDefaultArgs instead
     */
    export type PendaftaranMbkmCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendaftaranMbkmCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramMbkmCountOutputTypeDefaultArgs instead
     */
    export type ProgramMbkmCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramMbkmCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminSiapDefaultArgs instead
     */
    export type AdminSiapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminSiapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BerkasPenilaianDefaultArgs instead
     */
    export type BerkasPenilaianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BerkasPenilaianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriesDefaultArgs instead
     */
    export type CategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DosbingDefaultArgs instead
     */
    export type DosbingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DosbingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KonversiNilaiDefaultArgs instead
     */
    export type KonversiNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KonversiNilaiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KoorMbkmDefaultArgs instead
     */
    export type KoorMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KoorMbkmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MahasiswaDefaultArgs instead
     */
    export type MahasiswaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MahasiswaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendaftaranAkunDefaultArgs instead
     */
    export type PendaftaranAkunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendaftaranAkunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PendaftaranMbkmDefaultArgs instead
     */
    export type PendaftaranMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PendaftaranMbkmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PengumumanDefaultArgs instead
     */
    export type PengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PengumumanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramMbkmDefaultArgs instead
     */
    export type ProgramMbkmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramMbkmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}